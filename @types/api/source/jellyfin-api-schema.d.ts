/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/System/ActivityLog/Entries": {
    /** Gets activity log entries. */
    get: operations["GetLogEntries"];
  };
  "/Auth/Keys": {
    /** Get all keys. */
    get: operations["GetKeys"];
    /** Create a new api key. */
    post: operations["CreateKey"];
  };
  "/Auth/Keys/{key}": {
    /** Remove an api key. */
    delete: operations["RevokeKey"];
  };
  "/Artists": {
    /** Gets all artists from a given item, folder, or the entire library. */
    get: operations["GetArtists"];
  };
  "/Artists/{name}": {
    /** Gets an artist by name. */
    get: operations["GetArtistByName"];
  };
  "/Artists/AlbumArtists": {
    /** Gets all album artists from a given item, folder, or the entire library. */
    get: operations["GetAlbumArtists"];
  };
  "/Audio/{itemId}/stream": {
    /** Gets an audio stream. */
    get: operations["GetAudioStream"];
    /** Gets an audio stream. */
    head: operations["HeadAudioStream"];
  };
  "/Audio/{itemId}/stream.{container}": {
    /** Gets an audio stream. */
    get: operations["GetAudioStreamByContainer"];
    /** Gets an audio stream. */
    head: operations["HeadAudioStreamByContainer"];
  };
  "/Branding/Configuration": {
    /** Gets branding configuration. */
    get: operations["GetBrandingOptions"];
  };
  "/Branding/Css": {
    /** Gets branding css. */
    get: operations["GetBrandingCss"];
  };
  "/Branding/Css.css": {
    /** Gets branding css. */
    get: operations["GetBrandingCss_2"];
  };
  "/Channels": {
    /** Gets available channels. */
    get: operations["GetChannels"];
  };
  "/Channels/{channelId}/Features": {
    /** Get channel features. */
    get: operations["GetChannelFeatures"];
  };
  "/Channels/{channelId}/Items": {
    /** Get channel items. */
    get: operations["GetChannelItems"];
  };
  "/Channels/Features": {
    /** Get all channel features. */
    get: operations["GetAllChannelFeatures"];
  };
  "/Channels/Items/Latest": {
    /** Gets latest channel items. */
    get: operations["GetLatestChannelItems"];
  };
  "/ClientLog/Document": {
    /** Upload a document. */
    post: operations["LogFile"];
  };
  "/Collections": {
    /** Creates a new collection. */
    post: operations["CreateCollection"];
  };
  "/Collections/{collectionId}/Items": {
    /** Adds items to a collection. */
    post: operations["AddToCollection"];
    /** Removes items from a collection. */
    delete: operations["RemoveFromCollection"];
  };
  "/System/Configuration": {
    /** Gets application configuration. */
    get: operations["GetConfiguration"];
    /** Updates application configuration. */
    post: operations["UpdateConfiguration"];
  };
  "/System/Configuration/{key}": {
    /** Gets a named configuration. */
    get: operations["GetNamedConfiguration"];
    /** Updates named configuration. */
    post: operations["UpdateNamedConfiguration"];
  };
  "/System/Configuration/MetadataOptions/Default": {
    /** Gets a default MetadataOptions object. */
    get: operations["GetDefaultMetadataOptions"];
  };
  "/web/ConfigurationPage": {
    /** Gets a dashboard configuration page. */
    get: operations["GetDashboardConfigurationPage"];
  };
  "/web/ConfigurationPages": {
    /** Gets the configuration pages. */
    get: operations["GetConfigurationPages"];
  };
  "/Devices": {
    /** Get Devices. */
    get: operations["GetDevices"];
    /** Deletes a device. */
    delete: operations["DeleteDevice"];
  };
  "/Devices/Info": {
    /** Get info for a device. */
    get: operations["GetDeviceInfo"];
  };
  "/Devices/Options": {
    /** Get options for a device. */
    get: operations["GetDeviceOptions"];
    /** Update device options. */
    post: operations["UpdateDeviceOptions"];
  };
  "/DisplayPreferences/{displayPreferencesId}": {
    /** Get Display Preferences. */
    get: operations["GetDisplayPreferences"];
    /** Update Display Preferences. */
    post: operations["UpdateDisplayPreferences"];
  };
  "/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}": {
    /** Gets a video stream using HTTP live streaming. */
    get: operations["GetHlsAudioSegment"];
  };
  "/Audio/{itemId}/main.m3u8": {
    /** Gets an audio stream using HTTP live streaming. */
    get: operations["GetVariantHlsAudioPlaylist"];
  };
  "/Audio/{itemId}/master.m3u8": {
    /** Gets an audio hls playlist stream. */
    get: operations["GetMasterHlsAudioPlaylist"];
    /** Gets an audio hls playlist stream. */
    head: operations["HeadMasterHlsAudioPlaylist"];
  };
  "/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}": {
    /** Gets a video stream using HTTP live streaming. */
    get: operations["GetHlsVideoSegment"];
  };
  "/Videos/{itemId}/live.m3u8": {
    /** Gets a hls live stream. */
    get: operations["GetLiveHlsStream"];
  };
  "/Videos/{itemId}/main.m3u8": {
    /** Gets a video stream using HTTP live streaming. */
    get: operations["GetVariantHlsVideoPlaylist"];
  };
  "/Videos/{itemId}/master.m3u8": {
    /** Gets a video hls playlist stream. */
    get: operations["GetMasterHlsVideoPlaylist"];
    /** Gets a video hls playlist stream. */
    head: operations["HeadMasterHlsVideoPlaylist"];
  };
  "/Environment/DefaultDirectoryBrowser": {
    /** Get Default directory browser. */
    get: operations["GetDefaultDirectoryBrowser"];
  };
  "/Environment/DirectoryContents": {
    /** Gets the contents of a given directory in the file system. */
    get: operations["GetDirectoryContents"];
  };
  "/Environment/Drives": {
    /** Gets available drives from the server's file system. */
    get: operations["GetDrives"];
  };
  "/Environment/NetworkShares": {
    /**
     * Gets network paths.
     * @deprecated
     */
    get: operations["GetNetworkShares"];
  };
  "/Environment/ParentPath": {
    /** Gets the parent path of a given path. */
    get: operations["GetParentPath"];
  };
  "/Environment/ValidatePath": {
    /** Validates path. */
    post: operations["ValidatePath"];
  };
  "/Items/Filters": {
    /** Gets legacy query filters. */
    get: operations["GetQueryFiltersLegacy"];
  };
  "/Items/Filters2": {
    /** Gets query filters. */
    get: operations["GetQueryFilters"];
  };
  "/Genres": {
    /** Gets all genres from a given item, folder, or the entire library. */
    get: operations["GetGenres"];
  };
  "/Genres/{genreName}": {
    /** Gets a genre, by name. */
    get: operations["GetGenre"];
  };
  "/Audio/{itemId}/hls/{segmentId}/stream.aac": {
    /** Gets the specified audio segment for an audio item. */
    get: operations["GetHlsAudioSegmentLegacyAac"];
  };
  "/Audio/{itemId}/hls/{segmentId}/stream.mp3": {
    /** Gets the specified audio segment for an audio item. */
    get: operations["GetHlsAudioSegmentLegacyMp3"];
  };
  "/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}": {
    /** Gets a hls video segment. */
    get: operations["GetHlsVideoSegmentLegacy"];
  };
  "/Videos/{itemId}/hls/{playlistId}/stream.m3u8": {
    /** Gets a hls video playlist. */
    get: operations["GetHlsPlaylistLegacy"];
  };
  "/Videos/ActiveEncodings": {
    /** Stops an active encoding. */
    delete: operations["StopEncodingProcess"];
  };
  "/Artists/{name}/Images/{imageType}/{imageIndex}": {
    /** Get artist image by name. */
    get: operations["GetArtistImage"];
    /** Get artist image by name. */
    head: operations["HeadArtistImage"];
  };
  "/Branding/Splashscreen": {
    /** Generates or gets the splashscreen. */
    get: operations["GetSplashscreen"];
    /**
     * Uploads a custom splashscreen.
     * The body is expected to the image contents base64 encoded.
     */
    post: operations["UploadCustomSplashscreen"];
    /** Delete a custom splashscreen. */
    delete: operations["DeleteCustomSplashscreen"];
  };
  "/Genres/{name}/Images/{imageType}": {
    /** Get genre image by name. */
    get: operations["GetGenreImage"];
    /** Get genre image by name. */
    head: operations["HeadGenreImage"];
  };
  "/Genres/{name}/Images/{imageType}/{imageIndex}": {
    /** Get genre image by name. */
    get: operations["GetGenreImageByIndex"];
    /** Get genre image by name. */
    head: operations["HeadGenreImageByIndex"];
  };
  "/Items/{itemId}/Images": {
    /** Get item image infos. */
    get: operations["GetItemImageInfos"];
  };
  "/Items/{itemId}/Images/{imageType}": {
    /** Gets the item's image. */
    get: operations["GetItemImage"];
    /** Set item image. */
    post: operations["SetItemImage"];
    /** Delete an item's image. */
    delete: operations["DeleteItemImage"];
    /** Gets the item's image. */
    head: operations["HeadItemImage"];
  };
  "/Items/{itemId}/Images/{imageType}/{imageIndex}": {
    /** Gets the item's image. */
    get: operations["GetItemImageByIndex"];
    /** Set item image. */
    post: operations["SetItemImageByIndex"];
    /** Delete an item's image. */
    delete: operations["DeleteItemImageByIndex"];
    /** Gets the item's image. */
    head: operations["HeadItemImageByIndex"];
  };
  "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}": {
    /** Gets the item's image. */
    get: operations["GetItemImage2"];
    /** Gets the item's image. */
    head: operations["HeadItemImage2"];
  };
  "/Items/{itemId}/Images/{imageType}/{imageIndex}/Index": {
    /** Updates the index for an item image. */
    post: operations["UpdateItemImageIndex"];
  };
  "/MusicGenres/{name}/Images/{imageType}": {
    /** Get music genre image by name. */
    get: operations["GetMusicGenreImage"];
    /** Get music genre image by name. */
    head: operations["HeadMusicGenreImage"];
  };
  "/MusicGenres/{name}/Images/{imageType}/{imageIndex}": {
    /** Get music genre image by name. */
    get: operations["GetMusicGenreImageByIndex"];
    /** Get music genre image by name. */
    head: operations["HeadMusicGenreImageByIndex"];
  };
  "/Persons/{name}/Images/{imageType}": {
    /** Get person image by name. */
    get: operations["GetPersonImage"];
    /** Get person image by name. */
    head: operations["HeadPersonImage"];
  };
  "/Persons/{name}/Images/{imageType}/{imageIndex}": {
    /** Get person image by name. */
    get: operations["GetPersonImageByIndex"];
    /** Get person image by name. */
    head: operations["HeadPersonImageByIndex"];
  };
  "/Studios/{name}/Images/{imageType}": {
    /** Get studio image by name. */
    get: operations["GetStudioImage"];
    /** Get studio image by name. */
    head: operations["HeadStudioImage"];
  };
  "/Studios/{name}/Images/{imageType}/{imageIndex}": {
    /** Get studio image by name. */
    get: operations["GetStudioImageByIndex"];
    /** Get studio image by name. */
    head: operations["HeadStudioImageByIndex"];
  };
  "/UserImage": {
    /** Get user profile image. */
    get: operations["GetUserImage"];
    /** Sets the user image. */
    post: operations["PostUserImage"];
    /** Delete the user's image. */
    delete: operations["DeleteUserImage"];
    /** Get user profile image. */
    head: operations["HeadUserImage"];
  };
  "/Albums/{itemId}/InstantMix": {
    /** Creates an instant playlist based on a given album. */
    get: operations["GetInstantMixFromAlbum"];
  };
  "/Artists/{itemId}/InstantMix": {
    /** Creates an instant playlist based on a given artist. */
    get: operations["GetInstantMixFromArtists"];
  };
  "/Artists/InstantMix": {
    /**
     * Creates an instant playlist based on a given artist.
     * @deprecated
     */
    get: operations["GetInstantMixFromArtists2"];
  };
  "/Items/{itemId}/InstantMix": {
    /** Creates an instant playlist based on a given item. */
    get: operations["GetInstantMixFromItem"];
  };
  "/MusicGenres/{name}/InstantMix": {
    /** Creates an instant playlist based on a given genre. */
    get: operations["GetInstantMixFromMusicGenreByName"];
  };
  "/MusicGenres/InstantMix": {
    /** Creates an instant playlist based on a given genre. */
    get: operations["GetInstantMixFromMusicGenreById"];
  };
  "/Playlists/{itemId}/InstantMix": {
    /** Creates an instant playlist based on a given playlist. */
    get: operations["GetInstantMixFromPlaylist"];
  };
  "/Songs/{itemId}/InstantMix": {
    /** Creates an instant playlist based on a given song. */
    get: operations["GetInstantMixFromSong"];
  };
  "/Items/{itemId}/ExternalIdInfos": {
    /** Get the item's external id info. */
    get: operations["GetExternalIdInfos"];
  };
  "/Items/RemoteSearch/Apply/{itemId}": {
    /** Applies search criteria to an item and refreshes metadata. */
    post: operations["ApplySearchCriteria"];
  };
  "/Items/RemoteSearch/Book": {
    /** Get book remote search. */
    post: operations["GetBookRemoteSearchResults"];
  };
  "/Items/RemoteSearch/BoxSet": {
    /** Get box set remote search. */
    post: operations["GetBoxSetRemoteSearchResults"];
  };
  "/Items/RemoteSearch/Movie": {
    /** Get movie remote search. */
    post: operations["GetMovieRemoteSearchResults"];
  };
  "/Items/RemoteSearch/MusicAlbum": {
    /** Get music album remote search. */
    post: operations["GetMusicAlbumRemoteSearchResults"];
  };
  "/Items/RemoteSearch/MusicArtist": {
    /** Get music artist remote search. */
    post: operations["GetMusicArtistRemoteSearchResults"];
  };
  "/Items/RemoteSearch/MusicVideo": {
    /** Get music video remote search. */
    post: operations["GetMusicVideoRemoteSearchResults"];
  };
  "/Items/RemoteSearch/Person": {
    /** Get person remote search. */
    post: operations["GetPersonRemoteSearchResults"];
  };
  "/Items/RemoteSearch/Series": {
    /** Get series remote search. */
    post: operations["GetSeriesRemoteSearchResults"];
  };
  "/Items/RemoteSearch/Trailer": {
    /** Get trailer remote search. */
    post: operations["GetTrailerRemoteSearchResults"];
  };
  "/Items/{itemId}/Refresh": {
    /** Refreshes metadata for an item. */
    post: operations["RefreshItem"];
  };
  "/Items": {
    /** Gets items based on a query. */
    get: operations["GetItems"];
    /** Deletes items from the library and filesystem. */
    delete: operations["DeleteItems"];
  };
  "/UserItems/{itemId}/UserData": {
    /** Get Item User Data. */
    get: operations["GetItemUserData"];
    /** Update Item User Data. */
    post: operations["UpdateItemUserData"];
  };
  "/UserItems/Resume": {
    /** Gets items based on a query. */
    get: operations["GetResumeItems"];
  };
  "/Items/{itemId}": {
    /** Gets an item from a user's library. */
    get: operations["GetItem"];
    /** Updates an item. */
    post: operations["UpdateItem"];
    /** Deletes an item from the library and filesystem. */
    delete: operations["DeleteItem"];
  };
  "/Items/{itemId}/ContentType": {
    /** Updates an item's content type. */
    post: operations["UpdateItemContentType"];
  };
  "/Items/{itemId}/MetadataEditor": {
    /** Gets metadata editor info for an item. */
    get: operations["GetMetadataEditorInfo"];
  };
  "/Albums/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarAlbums"];
  };
  "/Artists/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarArtists"];
  };
  "/Items/{itemId}/Ancestors": {
    /** Gets all parents of an item. */
    get: operations["GetAncestors"];
  };
  "/Items/{itemId}/CriticReviews": {
    /**
     * Gets critic review for an item.
     * @deprecated
     */
    get: operations["GetCriticReviews"];
  };
  "/Items/{itemId}/Download": {
    /** Downloads item media. */
    get: operations["GetDownload"];
  };
  "/Items/{itemId}/File": {
    /** Get the original file of an item. */
    get: operations["GetFile"];
  };
  "/Items/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarItems"];
  };
  "/Items/{itemId}/ThemeMedia": {
    /** Get theme songs and videos for an item. */
    get: operations["GetThemeMedia"];
  };
  "/Items/{itemId}/ThemeSongs": {
    /** Get theme songs for an item. */
    get: operations["GetThemeSongs"];
  };
  "/Items/{itemId}/ThemeVideos": {
    /** Get theme videos for an item. */
    get: operations["GetThemeVideos"];
  };
  "/Items/Counts": {
    /** Get item counts. */
    get: operations["GetItemCounts"];
  };
  "/Libraries/AvailableOptions": {
    /** Gets the library options info. */
    get: operations["GetLibraryOptionsInfo"];
  };
  "/Library/Media/Updated": {
    /** Reports that new movies have been added by an external source. */
    post: operations["PostUpdatedMedia"];
  };
  "/Library/MediaFolders": {
    /** Gets all user media folders. */
    get: operations["GetMediaFolders"];
  };
  "/Library/Movies/Added": {
    /** Reports that new movies have been added by an external source. */
    post: operations["PostAddedMovies"];
  };
  "/Library/Movies/Updated": {
    /** Reports that new movies have been added by an external source. */
    post: operations["PostUpdatedMovies"];
  };
  "/Library/PhysicalPaths": {
    /** Gets a list of physical paths from virtual folders. */
    get: operations["GetPhysicalPaths"];
  };
  "/Library/Refresh": {
    /** Starts a library scan. */
    post: operations["RefreshLibrary"];
  };
  "/Library/Series/Added": {
    /** Reports that new episodes of a series have been added by an external source. */
    post: operations["PostAddedSeries"];
  };
  "/Library/Series/Updated": {
    /** Reports that new episodes of a series have been added by an external source. */
    post: operations["PostUpdatedSeries"];
  };
  "/Movies/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarMovies"];
  };
  "/Shows/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarShows"];
  };
  "/Trailers/{itemId}/Similar": {
    /** Gets similar items. */
    get: operations["GetSimilarTrailers"];
  };
  "/Library/VirtualFolders": {
    /** Gets all virtual folders. */
    get: operations["GetVirtualFolders"];
    /** Adds a virtual folder. */
    post: operations["AddVirtualFolder"];
    /** Removes a virtual folder. */
    delete: operations["RemoveVirtualFolder"];
  };
  "/Library/VirtualFolders/LibraryOptions": {
    /** Update library options. */
    post: operations["UpdateLibraryOptions"];
  };
  "/Library/VirtualFolders/Name": {
    /** Renames a virtual folder. */
    post: operations["RenameVirtualFolder"];
  };
  "/Library/VirtualFolders/Paths": {
    /** Add a media path to a library. */
    post: operations["AddMediaPath"];
    /** Remove a media path. */
    delete: operations["RemoveMediaPath"];
  };
  "/Library/VirtualFolders/Paths/Update": {
    /** Updates a media path. */
    post: operations["UpdateMediaPath"];
  };
  "/LiveTv/ChannelMappingOptions": {
    /** Get channel mapping options. */
    get: operations["GetChannelMappingOptions"];
  };
  "/LiveTv/ChannelMappings": {
    /** Set channel mappings. */
    post: operations["SetChannelMapping"];
  };
  "/LiveTv/Channels": {
    /** Gets available live tv channels. */
    get: operations["GetLiveTvChannels"];
  };
  "/LiveTv/Channels/{channelId}": {
    /** Gets a live tv channel. */
    get: operations["GetChannel"];
  };
  "/LiveTv/GuideInfo": {
    /** Get guid info. */
    get: operations["GetGuideInfo"];
  };
  "/LiveTv/Info": {
    /** Gets available live tv services. */
    get: operations["GetLiveTvInfo"];
  };
  "/LiveTv/ListingProviders": {
    /** Adds a listings provider. */
    post: operations["AddListingProvider"];
    /** Delete listing provider. */
    delete: operations["DeleteListingProvider"];
  };
  "/LiveTv/ListingProviders/Default": {
    /** Gets default listings provider info. */
    get: operations["GetDefaultListingProvider"];
  };
  "/LiveTv/ListingProviders/Lineups": {
    /** Gets available lineups. */
    get: operations["GetLineups"];
  };
  "/LiveTv/ListingProviders/SchedulesDirect/Countries": {
    /** Gets available countries. */
    get: operations["GetSchedulesDirectCountries"];
  };
  "/LiveTv/LiveRecordings/{recordingId}/stream": {
    /** Gets a live tv recording stream. */
    get: operations["GetLiveRecordingFile"];
  };
  "/LiveTv/LiveStreamFiles/{streamId}/stream.{container}": {
    /** Gets a live tv channel stream. */
    get: operations["GetLiveStreamFile"];
  };
  "/LiveTv/Programs": {
    /** Gets available live tv epgs. */
    get: operations["GetLiveTvPrograms"];
    /** Gets available live tv epgs. */
    post: operations["GetPrograms"];
  };
  "/LiveTv/Programs/{programId}": {
    /** Gets a live tv program. */
    get: operations["GetProgram"];
  };
  "/LiveTv/Programs/Recommended": {
    /** Gets recommended live tv epgs. */
    get: operations["GetRecommendedPrograms"];
  };
  "/LiveTv/Recordings": {
    /** Gets live tv recordings. */
    get: operations["GetRecordings"];
  };
  "/LiveTv/Recordings/{recordingId}": {
    /** Gets a live tv recording. */
    get: operations["GetRecording"];
    /** Deletes a live tv recording. */
    delete: operations["DeleteRecording"];
  };
  "/LiveTv/Recordings/Folders": {
    /** Gets recording folders. */
    get: operations["GetRecordingFolders"];
  };
  "/LiveTv/Recordings/Groups": {
    /**
     * Gets live tv recording groups.
     * @deprecated
     */
    get: operations["GetRecordingGroups"];
  };
  "/LiveTv/Recordings/Groups/{groupId}": {
    /**
     * Get recording group.
     * @deprecated
     */
    get: operations["GetRecordingGroup"];
  };
  "/LiveTv/Recordings/Series": {
    /**
     * Gets live tv recording series.
     * @deprecated
     */
    get: operations["GetRecordingsSeries"];
  };
  "/LiveTv/SeriesTimers": {
    /** Gets live tv series timers. */
    get: operations["GetSeriesTimers"];
    /** Creates a live tv series timer. */
    post: operations["CreateSeriesTimer"];
  };
  "/LiveTv/SeriesTimers/{timerId}": {
    /** Gets a live tv series timer. */
    get: operations["GetSeriesTimer"];
    /** Updates a live tv series timer. */
    post: operations["UpdateSeriesTimer"];
    /** Cancels a live tv series timer. */
    delete: operations["CancelSeriesTimer"];
  };
  "/LiveTv/Timers": {
    /** Gets the live tv timers. */
    get: operations["GetTimers"];
    /** Creates a live tv timer. */
    post: operations["CreateTimer"];
  };
  "/LiveTv/Timers/{timerId}": {
    /** Gets a timer. */
    get: operations["GetTimer"];
    /** Updates a live tv timer. */
    post: operations["UpdateTimer"];
    /** Cancels a live tv timer. */
    delete: operations["CancelTimer"];
  };
  "/LiveTv/Timers/Defaults": {
    /** Gets the default values for a new timer. */
    get: operations["GetDefaultTimer"];
  };
  "/LiveTv/TunerHosts": {
    /** Adds a tuner host. */
    post: operations["AddTunerHost"];
    /** Deletes a tuner host. */
    delete: operations["DeleteTunerHost"];
  };
  "/LiveTv/TunerHosts/Types": {
    /** Get tuner host types. */
    get: operations["GetTunerHostTypes"];
  };
  "/LiveTv/Tuners/{tunerId}/Reset": {
    /** Resets a tv tuner. */
    post: operations["ResetTuner"];
  };
  "/LiveTv/Tuners/Discover": {
    /** Discover tuners. */
    get: operations["DiscoverTuners"];
  };
  "/LiveTv/Tuners/Discvover": {
    /** Discover tuners. */
    get: operations["DiscvoverTuners"];
  };
  "/Localization/Countries": {
    /** Gets known countries. */
    get: operations["GetCountries"];
  };
  "/Localization/Cultures": {
    /** Gets known cultures. */
    get: operations["GetCultures"];
  };
  "/Localization/Options": {
    /** Gets localization options. */
    get: operations["GetLocalizationOptions"];
  };
  "/Localization/ParentalRatings": {
    /** Gets known parental ratings. */
    get: operations["GetParentalRatings"];
  };
  "/Audio/{itemId}/Lyrics": {
    /** Gets an item's lyrics. */
    get: operations["GetLyrics"];
    /** Upload an external lyric file. */
    post: operations["UploadLyrics"];
    /** Deletes an external lyric file. */
    delete: operations["DeleteLyrics"];
  };
  "/Audio/{itemId}/RemoteSearch/Lyrics": {
    /** Search remote lyrics. */
    get: operations["SearchRemoteLyrics"];
  };
  "/Audio/{itemId}/RemoteSearch/Lyrics/{lyricId}": {
    /** Downloads a remote lyric. */
    post: operations["DownloadRemoteLyrics"];
  };
  "/Providers/Lyrics/{lyricId}": {
    /** Gets the remote lyrics. */
    get: operations["GetRemoteLyrics"];
  };
  "/Items/{itemId}/PlaybackInfo": {
    /** Gets live playback media info for an item. */
    get: operations["GetPlaybackInfo"];
    /**
     * Gets live playback media info for an item.
     * @description For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
     * Query parameters are obsolete.
     */
    post: operations["GetPostedPlaybackInfo"];
  };
  "/LiveStreams/Close": {
    /** Closes a media source. */
    post: operations["CloseLiveStream"];
  };
  "/LiveStreams/Open": {
    /** Opens a media source. */
    post: operations["OpenLiveStream"];
  };
  "/Playback/BitrateTest": {
    /** Tests the network with a request with the size of the bitrate. */
    get: operations["GetBitrateTestBytes"];
  };
  "/Movies/Recommendations": {
    /** Gets movie recommendations. */
    get: operations["GetMovieRecommendations"];
  };
  "/MusicGenres": {
    /**
     * Gets all music genres from a given item, folder, or the entire library.
     * @deprecated
     */
    get: operations["GetMusicGenres"];
  };
  "/MusicGenres/{genreName}": {
    /** Gets a music genre, by name. */
    get: operations["GetMusicGenre"];
  };
  "/Packages": {
    /** Gets available packages. */
    get: operations["GetPackages"];
  };
  "/Packages/{name}": {
    /** Gets a package by name or assembly GUID. */
    get: operations["GetPackageInfo"];
  };
  "/Packages/Installed/{name}": {
    /** Installs a package. */
    post: operations["InstallPackage"];
  };
  "/Packages/Installing/{packageId}": {
    /** Cancels a package installation. */
    delete: operations["CancelPackageInstallation"];
  };
  "/Repositories": {
    /** Gets all package repositories. */
    get: operations["GetRepositories"];
    /** Sets the enabled and existing package repositories. */
    post: operations["SetRepositories"];
  };
  "/Persons": {
    /** Gets all persons. */
    get: operations["GetPersons"];
  };
  "/Persons/{name}": {
    /** Get person by name. */
    get: operations["GetPerson"];
  };
  "/Playlists": {
    /**
     * Creates a new playlist.
     * @description For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
     * Query parameters are obsolete.
     */
    post: operations["CreatePlaylist"];
  };
  "/Playlists/{playlistId}": {
    /** Updates a playlist. */
    post: operations["UpdatePlaylist"];
  };
  "/Playlists/{playlistId}/Items": {
    /** Gets the original items of a playlist. */
    get: operations["GetPlaylistItems"];
    /** Adds items to a playlist. */
    post: operations["AddItemToPlaylist"];
    /** Removes items from a playlist. */
    delete: operations["RemoveItemFromPlaylist"];
  };
  "/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}": {
    /** Moves a playlist item. */
    post: operations["MoveItem"];
  };
  "/Playlists/{playlistId}/Users": {
    /** Get a playlist's users. */
    get: operations["GetPlaylistUsers"];
  };
  "/Playlists/{playlistId}/Users/{userId}": {
    /** Get a playlist user. */
    get: operations["GetPlaylistUser"];
    /** Modify a user of a playlist's users. */
    post: operations["UpdatePlaylistUser"];
    /** Remove a user from a playlist's users. */
    delete: operations["RemoveUserFromPlaylist"];
  };
  "/PlayingItems/{itemId}": {
    /** Reports that a session has begun playing an item. */
    post: operations["OnPlaybackStart"];
    /** Reports that a session has stopped playing an item. */
    delete: operations["OnPlaybackStopped"];
  };
  "/PlayingItems/{itemId}/Progress": {
    /** Reports a session's playback progress. */
    post: operations["OnPlaybackProgress"];
  };
  "/Sessions/Playing": {
    /** Reports playback has started within a session. */
    post: operations["ReportPlaybackStart"];
  };
  "/Sessions/Playing/Ping": {
    /** Pings a playback session. */
    post: operations["PingPlaybackSession"];
  };
  "/Sessions/Playing/Progress": {
    /** Reports playback progress within a session. */
    post: operations["ReportPlaybackProgress"];
  };
  "/Sessions/Playing/Stopped": {
    /** Reports playback has stopped within a session. */
    post: operations["ReportPlaybackStopped"];
  };
  "/UserPlayedItems/{itemId}": {
    /** Marks an item as played for user. */
    post: operations["MarkPlayedItem"];
    /** Marks an item as unplayed for user. */
    delete: operations["MarkUnplayedItem"];
  };
  "/Plugins": {
    /** Gets a list of currently installed plugins. */
    get: operations["GetPlugins"];
  };
  "/Plugins/{pluginId}": {
    /**
     * Uninstalls a plugin.
     * @deprecated
     */
    delete: operations["UninstallPlugin"];
  };
  "/Plugins/{pluginId}/{version}": {
    /** Uninstalls a plugin by version. */
    delete: operations["UninstallPluginByVersion"];
  };
  "/Plugins/{pluginId}/{version}/Disable": {
    /** Disable a plugin. */
    post: operations["DisablePlugin"];
  };
  "/Plugins/{pluginId}/{version}/Enable": {
    /** Enables a disabled plugin. */
    post: operations["EnablePlugin"];
  };
  "/Plugins/{pluginId}/{version}/Image": {
    /** Gets a plugin's image. */
    get: operations["GetPluginImage"];
  };
  "/Plugins/{pluginId}/Configuration": {
    /** Gets plugin configuration. */
    get: operations["GetPluginConfiguration"];
    /**
     * Updates plugin configuration.
     * @description Accepts plugin configuration as JSON body.
     */
    post: operations["UpdatePluginConfiguration"];
  };
  "/Plugins/{pluginId}/Manifest": {
    /** Gets a plugin's manifest. */
    post: operations["GetPluginManifest"];
  };
  "/QuickConnect/Authorize": {
    /** Authorizes a pending quick connect request. */
    post: operations["AuthorizeQuickConnect"];
  };
  "/QuickConnect/Connect": {
    /** Attempts to retrieve authentication information. */
    get: operations["GetQuickConnectState"];
  };
  "/QuickConnect/Enabled": {
    /** Gets the current quick connect state. */
    get: operations["GetQuickConnectEnabled"];
  };
  "/QuickConnect/Initiate": {
    /** Initiate a new quick connect request. */
    post: operations["InitiateQuickConnect"];
  };
  "/Items/{itemId}/RemoteImages": {
    /** Gets available remote images for an item. */
    get: operations["GetRemoteImages"];
  };
  "/Items/{itemId}/RemoteImages/Download": {
    /** Downloads a remote image for an item. */
    post: operations["DownloadRemoteImage"];
  };
  "/Items/{itemId}/RemoteImages/Providers": {
    /** Gets available remote image providers for an item. */
    get: operations["GetRemoteImageProviders"];
  };
  "/ScheduledTasks": {
    /** Get tasks. */
    get: operations["GetTasks"];
  };
  "/ScheduledTasks/{taskId}": {
    /** Get task by id. */
    get: operations["GetTask"];
  };
  "/ScheduledTasks/{taskId}/Triggers": {
    /** Update specified task triggers. */
    post: operations["UpdateTask"];
  };
  "/ScheduledTasks/Running/{taskId}": {
    /** Start specified task. */
    post: operations["StartTask"];
    /** Stop specified task. */
    delete: operations["StopTask"];
  };
  "/Search/Hints": {
    /** Gets the search hint result. */
    get: operations["GetSearchHints"];
  };
  "/Auth/PasswordResetProviders": {
    /** Get all password reset providers. */
    get: operations["GetPasswordResetProviders"];
  };
  "/Auth/Providers": {
    /** Get all auth providers. */
    get: operations["GetAuthProviders"];
  };
  "/Sessions": {
    /** Gets a list of sessions. */
    get: operations["GetSessions"];
  };
  "/Sessions/{sessionId}/Command": {
    /** Issues a full general command to a client. */
    post: operations["SendFullGeneralCommand"];
  };
  "/Sessions/{sessionId}/Command/{command}": {
    /** Issues a general command to a client. */
    post: operations["SendGeneralCommand"];
  };
  "/Sessions/{sessionId}/Message": {
    /** Issues a command to a client to display a message to the user. */
    post: operations["SendMessageCommand"];
  };
  "/Sessions/{sessionId}/Playing": {
    /** Instructs a session to play an item. */
    post: operations["Play"];
  };
  "/Sessions/{sessionId}/Playing/{command}": {
    /** Issues a playstate command to a client. */
    post: operations["SendPlaystateCommand"];
  };
  "/Sessions/{sessionId}/System/{command}": {
    /** Issues a system command to a client. */
    post: operations["SendSystemCommand"];
  };
  "/Sessions/{sessionId}/User/{userId}": {
    /** Adds an additional user to a session. */
    post: operations["AddUserToSession"];
    /** Removes an additional user from a session. */
    delete: operations["RemoveUserFromSession"];
  };
  "/Sessions/{sessionId}/Viewing": {
    /** Instructs a session to browse to an item or view. */
    post: operations["DisplayContent"];
  };
  "/Sessions/Capabilities": {
    /** Updates capabilities for a device. */
    post: operations["PostCapabilities"];
  };
  "/Sessions/Capabilities/Full": {
    /** Updates capabilities for a device. */
    post: operations["PostFullCapabilities"];
  };
  "/Sessions/Logout": {
    /** Reports that a session has ended. */
    post: operations["ReportSessionEnded"];
  };
  "/Sessions/Viewing": {
    /** Reports that a session is viewing an item. */
    post: operations["ReportViewing"];
  };
  "/Startup/Complete": {
    /** Completes the startup wizard. */
    post: operations["CompleteWizard"];
  };
  "/Startup/Configuration": {
    /** Gets the initial startup wizard configuration. */
    get: operations["GetStartupConfiguration"];
    /** Sets the initial startup wizard configuration. */
    post: operations["UpdateInitialConfiguration"];
  };
  "/Startup/FirstUser": {
    /** Gets the first user. */
    get: operations["GetFirstUser_2"];
  };
  "/Startup/RemoteAccess": {
    /** Sets remote access and UPnP. */
    post: operations["SetRemoteAccess"];
  };
  "/Startup/User": {
    /** Gets the first user. */
    get: operations["GetFirstUser"];
    /** Sets the user name and password. */
    post: operations["UpdateStartupUser"];
  };
  "/Studios": {
    /** Gets all studios from a given item, folder, or the entire library. */
    get: operations["GetStudios"];
  };
  "/Studios/{name}": {
    /** Gets a studio by name. */
    get: operations["GetStudio"];
  };
  "/FallbackFont/Fonts": {
    /** Gets a list of available fallback font files. */
    get: operations["GetFallbackFontList"];
  };
  "/FallbackFont/Fonts/{name}": {
    /** Gets a fallback font file. */
    get: operations["GetFallbackFont"];
  };
  "/Items/{itemId}/RemoteSearch/Subtitles/{language}": {
    /** Search remote subtitles. */
    get: operations["SearchRemoteSubtitles"];
  };
  "/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}": {
    /** Downloads a remote subtitle. */
    post: operations["DownloadRemoteSubtitles"];
  };
  "/Providers/Subtitles/Subtitles/{subtitleId}": {
    /** Gets the remote subtitles. */
    get: operations["GetRemoteSubtitles"];
  };
  "/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8": {
    /** Gets an HLS subtitle playlist. */
    get: operations["GetSubtitlePlaylist"];
  };
  "/Videos/{itemId}/Subtitles": {
    /** Upload an external subtitle file. */
    post: operations["UploadSubtitle"];
  };
  "/Videos/{itemId}/Subtitles/{index}": {
    /** Deletes an external subtitle file. */
    delete: operations["DeleteSubtitle"];
  };
  "/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/{routeStartPositionTicks}/Stream.{routeFormat}": {
    /** Gets subtitles in a specified format. */
    get: operations["GetSubtitleWithTicks"];
  };
  "/Videos/{routeItemId}/{routeMediaSourceId}/Subtitles/{routeIndex}/Stream.{routeFormat}": {
    /** Gets subtitles in a specified format. */
    get: operations["GetSubtitle"];
  };
  "/Items/Suggestions": {
    /** Gets suggestions. */
    get: operations["GetSuggestions"];
  };
  "/SyncPlay/Buffering": {
    /** Notify SyncPlay group that member is buffering. */
    post: operations["SyncPlayBuffering"];
  };
  "/SyncPlay/Join": {
    /** Join an existing SyncPlay group. */
    post: operations["SyncPlayJoinGroup"];
  };
  "/SyncPlay/Leave": {
    /** Leave the joined SyncPlay group. */
    post: operations["SyncPlayLeaveGroup"];
  };
  "/SyncPlay/List": {
    /** Gets all SyncPlay groups. */
    get: operations["SyncPlayGetGroups"];
  };
  "/SyncPlay/MovePlaylistItem": {
    /** Request to move an item in the playlist in SyncPlay group. */
    post: operations["SyncPlayMovePlaylistItem"];
  };
  "/SyncPlay/New": {
    /** Create a new SyncPlay group. */
    post: operations["SyncPlayCreateGroup"];
  };
  "/SyncPlay/NextItem": {
    /** Request next item in SyncPlay group. */
    post: operations["SyncPlayNextItem"];
  };
  "/SyncPlay/Pause": {
    /** Request pause in SyncPlay group. */
    post: operations["SyncPlayPause"];
  };
  "/SyncPlay/Ping": {
    /** Update session ping. */
    post: operations["SyncPlayPing"];
  };
  "/SyncPlay/PreviousItem": {
    /** Request previous item in SyncPlay group. */
    post: operations["SyncPlayPreviousItem"];
  };
  "/SyncPlay/Queue": {
    /** Request to queue items to the playlist of a SyncPlay group. */
    post: operations["SyncPlayQueue"];
  };
  "/SyncPlay/Ready": {
    /** Notify SyncPlay group that member is ready for playback. */
    post: operations["SyncPlayReady"];
  };
  "/SyncPlay/RemoveFromPlaylist": {
    /** Request to remove items from the playlist in SyncPlay group. */
    post: operations["SyncPlayRemoveFromPlaylist"];
  };
  "/SyncPlay/Seek": {
    /** Request seek in SyncPlay group. */
    post: operations["SyncPlaySeek"];
  };
  "/SyncPlay/SetIgnoreWait": {
    /** Request SyncPlay group to ignore member during group-wait. */
    post: operations["SyncPlaySetIgnoreWait"];
  };
  "/SyncPlay/SetNewQueue": {
    /** Request to set new playlist in SyncPlay group. */
    post: operations["SyncPlaySetNewQueue"];
  };
  "/SyncPlay/SetPlaylistItem": {
    /** Request to change playlist item in SyncPlay group. */
    post: operations["SyncPlaySetPlaylistItem"];
  };
  "/SyncPlay/SetRepeatMode": {
    /** Request to set repeat mode in SyncPlay group. */
    post: operations["SyncPlaySetRepeatMode"];
  };
  "/SyncPlay/SetShuffleMode": {
    /** Request to set shuffle mode in SyncPlay group. */
    post: operations["SyncPlaySetShuffleMode"];
  };
  "/SyncPlay/Stop": {
    /** Request stop in SyncPlay group. */
    post: operations["SyncPlayStop"];
  };
  "/SyncPlay/Unpause": {
    /** Request unpause in SyncPlay group. */
    post: operations["SyncPlayUnpause"];
  };
  "/System/Endpoint": {
    /** Gets information about the request endpoint. */
    get: operations["GetEndpointInfo"];
  };
  "/System/Info": {
    /** Gets information about the server. */
    get: operations["GetSystemInfo"];
  };
  "/System/Info/Public": {
    /** Gets public information about the server. */
    get: operations["GetPublicSystemInfo"];
  };
  "/System/Logs": {
    /** Gets a list of available server log files. */
    get: operations["GetServerLogs"];
  };
  "/System/Logs/Log": {
    /** Gets a log file. */
    get: operations["GetLogFile"];
  };
  "/System/Ping": {
    /** Pings the system. */
    get: operations["GetPingSystem"];
    /** Pings the system. */
    post: operations["PostPingSystem"];
  };
  "/System/Restart": {
    /** Restarts the application. */
    post: operations["RestartApplication"];
  };
  "/System/Shutdown": {
    /** Shuts down the application. */
    post: operations["ShutdownApplication"];
  };
  "/System/WakeOnLanInfo": {
    /**
     * Gets wake on lan information.
     * @deprecated
     */
    get: operations["GetWakeOnLanInfo"];
  };
  "/GetUtcTime": {
    /** Gets the current UTC time. */
    get: operations["GetUtcTime"];
  };
  "/Tmdb/ClientConfiguration": {
    /** Gets the TMDb image configuration options. */
    get: operations["TmdbClientConfiguration"];
  };
  "/Trailers": {
    /** Finds movies and trailers similar to a given trailer. */
    get: operations["GetTrailers"];
  };
  "/Videos/{itemId}/Trickplay/{width}/{index}.jpg": {
    /** Gets a trickplay tile image. */
    get: operations["GetTrickplayTileImage"];
  };
  "/Videos/{itemId}/Trickplay/{width}/tiles.m3u8": {
    /** Gets an image tiles playlist for trickplay. */
    get: operations["GetTrickplayHlsPlaylist"];
  };
  "/Shows/{seriesId}/Episodes": {
    /** Gets episodes for a tv season. */
    get: operations["GetEpisodes"];
  };
  "/Shows/{seriesId}/Seasons": {
    /** Gets seasons for a tv series. */
    get: operations["GetSeasons"];
  };
  "/Shows/NextUp": {
    /** Gets a list of next up episodes. */
    get: operations["GetNextUp"];
  };
  "/Shows/Upcoming": {
    /** Gets a list of upcoming episodes. */
    get: operations["GetUpcomingEpisodes"];
  };
  "/Audio/{itemId}/universal": {
    /** Gets an audio stream. */
    get: operations["GetUniversalAudioStream"];
    /** Gets an audio stream. */
    head: operations["HeadUniversalAudioStream"];
  };
  "/Users": {
    /** Gets a list of users. */
    get: operations["GetUsers"];
    /** Updates a user. */
    post: operations["UpdateUser"];
  };
  "/Users/{userId}": {
    /** Gets a user by Id. */
    get: operations["GetUserById"];
    /** Deletes a user. */
    delete: operations["DeleteUser"];
  };
  "/Users/{userId}/Policy": {
    /** Updates a user policy. */
    post: operations["UpdateUserPolicy"];
  };
  "/Users/AuthenticateByName": {
    /** Authenticates a user by name. */
    post: operations["AuthenticateUserByName"];
  };
  "/Users/AuthenticateWithQuickConnect": {
    /** Authenticates a user with quick connect. */
    post: operations["AuthenticateWithQuickConnect"];
  };
  "/Users/Configuration": {
    /** Updates a user configuration. */
    post: operations["UpdateUserConfiguration"];
  };
  "/Users/ForgotPassword": {
    /** Initiates the forgot password process for a local user. */
    post: operations["ForgotPassword"];
  };
  "/Users/ForgotPassword/Pin": {
    /** Redeems a forgot password pin. */
    post: operations["ForgotPasswordPin"];
  };
  "/Users/Me": {
    /** Gets the user based on auth token. */
    get: operations["GetCurrentUser"];
  };
  "/Users/New": {
    /** Creates a user. */
    post: operations["CreateUserByName"];
  };
  "/Users/Password": {
    /** Updates a user's password. */
    post: operations["UpdateUserPassword"];
  };
  "/Users/Public": {
    /** Gets a list of publicly visible users for display on a login screen. */
    get: operations["GetPublicUsers"];
  };
  "/Items/{itemId}/Intros": {
    /** Gets intros to play before the main media item plays. */
    get: operations["GetIntros"];
  };
  "/Items/{itemId}/LocalTrailers": {
    /** Gets local trailers for an item. */
    get: operations["GetLocalTrailers"];
  };
  "/Items/{itemId}/SpecialFeatures": {
    /** Gets special features for an item. */
    get: operations["GetSpecialFeatures"];
  };
  "/Items/Latest": {
    /** Gets latest media. */
    get: operations["GetLatestMedia"];
  };
  "/Items/Root": {
    /** Gets the root folder from a user's library. */
    get: operations["GetRootFolder"];
  };
  "/UserFavoriteItems/{itemId}": {
    /** Marks an item as a favorite. */
    post: operations["MarkFavoriteItem"];
    /** Unmarks item as a favorite. */
    delete: operations["UnmarkFavoriteItem"];
  };
  "/UserItems/{itemId}/Rating": {
    /** Updates a user's rating for an item. */
    post: operations["UpdateUserItemRating"];
    /** Deletes a user's saved personal rating for an item. */
    delete: operations["DeleteUserItemRating"];
  };
  "/UserViews": {
    /** Get user views. */
    get: operations["GetUserViews"];
  };
  "/UserViews/GroupingOptions": {
    /** Get user view grouping options. */
    get: operations["GetGroupingOptions"];
  };
  "/Videos/{videoId}/{mediaSourceId}/Attachments/{index}": {
    /** Get video attachment. */
    get: operations["GetAttachment"];
  };
  "/Videos/{itemId}/AdditionalParts": {
    /** Gets additional parts for a video. */
    get: operations["GetAdditionalPart"];
  };
  "/Videos/{itemId}/AlternateSources": {
    /** Removes alternate video sources. */
    delete: operations["DeleteAlternateSources"];
  };
  "/Videos/{itemId}/stream": {
    /** Gets a video stream. */
    get: operations["GetVideoStream"];
    /** Gets a video stream. */
    head: operations["HeadVideoStream"];
  };
  "/Videos/{itemId}/stream.{container}": {
    /** Gets a video stream. */
    get: operations["GetVideoStreamByContainer"];
    /** Gets a video stream. */
    head: operations["HeadVideoStreamByContainer"];
  };
  "/Videos/MergeVersions": {
    /** Merges videos into a single record. */
    post: operations["MergeVersions"];
  };
  "/Years": {
    /** Get years. */
    get: operations["GetYears"];
  };
  "/Years/{year}": {
    /** Gets a year. */
    get: operations["GetYear"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** @description An entity representing a user's access schedule. */
    AccessSchedule: {
      /**
       * Format: int32
       * @description Gets the id of this instance.
       */
      Id?: number;
      /**
       * Format: uuid
       * @description Gets the id of the associated user.
       */
      UserId?: string;
      /**
       * @description Gets or sets the day of week.
       * @enum {unknown}
       */
      DayOfWeek?: "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Everyday" | "Weekday" | "Weekend";
      /**
       * Format: double
       * @description Gets or sets the start hour.
       */
      StartHour?: number;
      /**
       * Format: double
       * @description Gets or sets the end hour.
       */
      EndHour?: number;
    };
    /** @description An activity log entry. */
    ActivityLogEntry: {
      /**
       * Format: int64
       * @description Gets or sets the identifier.
       */
      Id?: number;
      /** @description Gets or sets the name. */
      Name?: string;
      /** @description Gets or sets the overview. */
      Overview?: string | null;
      /** @description Gets or sets the short overview. */
      ShortOverview?: string | null;
      /** @description Gets or sets the type. */
      Type?: string;
      /** @description Gets or sets the item identifier. */
      ItemId?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the date.
       */
      Date?: string;
      /**
       * Format: uuid
       * @description Gets or sets the user identifier.
       */
      UserId?: string;
      /**
       * @deprecated
       * @description Gets or sets the user primary image tag.
       */
      UserPrimaryImageTag?: string | null;
      /**
       * @description Gets or sets the log severity.
       * @enum {unknown}
       */
      Severity?: "Trace" | "Debug" | "Information" | "Warning" | "Error" | "Critical" | "None";
    };
    /** @description Activity log created message. */
    ActivityLogEntryMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["ActivityLogEntry"][] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ActivityLogEntry
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    ActivityLogEntryQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["ActivityLogEntry"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    /**
     * @description Activity log entry start message.
     * Data is the timing data encoded as "$initialDelay,$interval" in ms.
     */
    ActivityLogEntryStartMessage: {
      /** @description Gets or sets the data. */
      Data?: string | null;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ActivityLogEntryStart
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Activity log entry stop message. */
    ActivityLogEntryStopMessage: {
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ActivityLogEntryStop
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Add virtual folder dto. */
    AddVirtualFolderDto: {
      /** @description Gets or sets library options. */
      LibraryOptions?: components["schemas"]["LibraryOptions"] | null;
    };
    AlbumInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
      /** @description Gets or sets the album artist. */
      AlbumArtists?: string[];
      /** @description Gets or sets the artist provider ids. */
      ArtistProviderIds?: {
        [key: string]: string | null;
      };
      SongInfos?: components["schemas"]["SongInfo"][];
    };
    AlbumInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["AlbumInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    AllThemeMediaResult: {
      /** @description Class ThemeMediaResult. */
      ThemeVideosResult?: components["schemas"]["ThemeMediaResult"] | null;
      /** @description Class ThemeMediaResult. */
      ThemeSongsResult?: components["schemas"]["ThemeMediaResult"] | null;
      /** @description Class ThemeMediaResult. */
      SoundtrackSongsResult?: components["schemas"]["ThemeMediaResult"] | null;
    };
    ArtistInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
      SongInfos?: components["schemas"]["SongInfo"][];
    };
    ArtistInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["ArtistInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    /**
     * @description An enum representing formats of spatial audio.
     * @enum {string}
     */
    AudioSpatialFormat: "None" | "DolbyAtmos" | "DTSX";
    /** @description The authenticate user by name request body. */
    AuthenticateUserByName: {
      /** @description Gets or sets the username. */
      Username?: string | null;
      /** @description Gets or sets the plain text password. */
      Pw?: string | null;
    };
    AuthenticationInfo: {
      /**
       * Format: int64
       * @description Gets or sets the identifier.
       */
      Id?: number;
      /** @description Gets or sets the access token. */
      AccessToken?: string | null;
      /** @description Gets or sets the device identifier. */
      DeviceId?: string | null;
      /** @description Gets or sets the name of the application. */
      AppName?: string | null;
      /** @description Gets or sets the application version. */
      AppVersion?: string | null;
      /** @description Gets or sets the name of the device. */
      DeviceName?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the user identifier.
       */
      UserId?: string;
      /** @description Gets or sets a value indicating whether this instance is active. */
      IsActive?: boolean;
      /**
       * Format: date-time
       * @description Gets or sets the date created.
       */
      DateCreated?: string;
      /**
       * Format: date-time
       * @description Gets or sets the date revoked.
       */
      DateRevoked?: string | null;
      /** Format: date-time */
      DateLastActivity?: string;
      UserName?: string | null;
    };
    AuthenticationInfoQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["AuthenticationInfo"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    AuthenticationResult: {
      /** @description Class UserDto. */
      User?: components["schemas"]["UserDto"] | null;
      /** @description Class SessionInfo. */
      SessionInfo?: components["schemas"]["SessionInfo"] | null;
      AccessToken?: string | null;
      ServerId?: string | null;
    };
    /**
     * @description This is strictly used as a data transfer object from the api layer.
     * This holds information about a BaseItem in a format that is convenient for the client.
     */
    BaseItemDto: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      OriginalTitle?: string | null;
      /** @description Gets or sets the server identifier. */
      ServerId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the id.
       */
      Id?: string;
      /** @description Gets or sets the etag. */
      Etag?: string | null;
      /** @description Gets or sets the type of the source. */
      SourceType?: string | null;
      /** @description Gets or sets the playlist item identifier. */
      PlaylistItemId?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the date created.
       */
      DateCreated?: string | null;
      /** Format: date-time */
      DateLastMediaAdded?: string | null;
      /** @enum {unknown|null} */
      ExtraType?: "Unknown" | "Clip" | "Trailer" | "BehindTheScenes" | "DeletedScene" | "Interview" | "Scene" | "Sample" | "ThemeSong" | "ThemeVideo" | "Featurette" | "Short" | null;
      /** Format: int32 */
      AirsBeforeSeasonNumber?: number | null;
      /** Format: int32 */
      AirsAfterSeasonNumber?: number | null;
      /** Format: int32 */
      AirsBeforeEpisodeNumber?: number | null;
      CanDelete?: boolean | null;
      CanDownload?: boolean | null;
      HasLyrics?: boolean | null;
      HasSubtitles?: boolean | null;
      PreferredMetadataLanguage?: string | null;
      PreferredMetadataCountryCode?: string | null;
      Container?: string | null;
      /** @description Gets or sets the name of the sort. */
      SortName?: string | null;
      ForcedSortName?: string | null;
      /**
       * @description Gets or sets the video3 D format.
       * @enum {unknown|null}
       */
      Video3DFormat?: "HalfSideBySide" | "FullSideBySide" | "FullTopAndBottom" | "HalfTopAndBottom" | "MVC" | null;
      /**
       * Format: date-time
       * @description Gets or sets the premiere date.
       */
      PremiereDate?: string | null;
      /** @description Gets or sets the external urls. */
      ExternalUrls?: components["schemas"]["ExternalUrl"][] | null;
      /** @description Gets or sets the media versions. */
      MediaSources?: components["schemas"]["MediaSourceInfo"][] | null;
      /**
       * Format: float
       * @description Gets or sets the critic rating.
       */
      CriticRating?: number | null;
      ProductionLocations?: string[] | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      EnableMediaSourceDisplay?: boolean | null;
      /** @description Gets or sets the official rating. */
      OfficialRating?: string | null;
      /** @description Gets or sets the custom rating. */
      CustomRating?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the channel identifier.
       */
      ChannelId?: string | null;
      ChannelName?: string | null;
      /** @description Gets or sets the overview. */
      Overview?: string | null;
      /** @description Gets or sets the taglines. */
      Taglines?: string[] | null;
      /** @description Gets or sets the genres. */
      Genres?: string[] | null;
      /**
       * Format: float
       * @description Gets or sets the community rating.
       */
      CommunityRating?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the cumulative run time ticks.
       */
      CumulativeRunTimeTicks?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the run time ticks.
       */
      RunTimeTicks?: number | null;
      /**
       * @description Gets or sets the play access.
       * @enum {unknown|null}
       */
      PlayAccess?: "Full" | "None" | null;
      /** @description Gets or sets the aspect ratio. */
      AspectRatio?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the production year.
       */
      ProductionYear?: number | null;
      /** @description Gets or sets a value indicating whether this instance is place holder. */
      IsPlaceHolder?: boolean | null;
      /** @description Gets or sets the number. */
      Number?: string | null;
      ChannelNumber?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the index number.
       */
      IndexNumber?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the index number end.
       */
      IndexNumberEnd?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the parent index number.
       */
      ParentIndexNumber?: number | null;
      /** @description Gets or sets the trailer urls. */
      RemoteTrailers?: components["schemas"]["MediaUrl"][] | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /** @description Gets or sets a value indicating whether this instance is HD. */
      IsHD?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is folder. */
      IsFolder?: boolean | null;
      /**
       * Format: uuid
       * @description Gets or sets the parent id.
       */
      ParentId?: string | null;
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "AggregateFolder" | "Audio" | "AudioBook" | "BasePluginFolder" | "Book" | "BoxSet" | "Channel" | "ChannelFolderItem" | "CollectionFolder" | "Episode" | "Folder" | "Genre" | "ManualPlaylistsFolder" | "Movie" | "LiveTvChannel" | "LiveTvProgram" | "MusicAlbum" | "MusicArtist" | "MusicGenre" | "MusicVideo" | "Person" | "Photo" | "PhotoAlbum" | "Playlist" | "PlaylistsFolder" | "Program" | "Recording" | "Season" | "Series" | "Studio" | "Trailer" | "TvChannel" | "TvProgram" | "UserRootFolder" | "UserView" | "Video" | "Year";
      /** @description Gets or sets the people. */
      People?: components["schemas"]["BaseItemPerson"][] | null;
      /** @description Gets or sets the studios. */
      Studios?: components["schemas"]["NameGuidPair"][] | null;
      GenreItems?: components["schemas"]["NameGuidPair"][] | null;
      /**
       * Format: uuid
       * @description Gets or sets whether the item has a logo, this will hold the Id of the Parent that has one.
       */
      ParentLogoItemId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets whether the item has any backdrops, this will hold the Id of the Parent that has one.
       */
      ParentBackdropItemId?: string | null;
      /** @description Gets or sets the parent backdrop image tags. */
      ParentBackdropImageTags?: string[] | null;
      /**
       * Format: int32
       * @description Gets or sets the local trailer count.
       */
      LocalTrailerCount?: number | null;
      /** @description Gets or sets the user data for this item based on the user it's being requested for. */
      UserData?: components["schemas"]["UserItemDataDto"] | null;
      /**
       * Format: int32
       * @description Gets or sets the recursive item count.
       */
      RecursiveItemCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the child count.
       */
      ChildCount?: number | null;
      /** @description Gets or sets the name of the series. */
      SeriesName?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the series id.
       */
      SeriesId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the season identifier.
       */
      SeasonId?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the special feature count.
       */
      SpecialFeatureCount?: number | null;
      /** @description Gets or sets the display preferences id. */
      DisplayPreferencesId?: string | null;
      /** @description Gets or sets the status. */
      Status?: string | null;
      /** @description Gets or sets the air time. */
      AirTime?: string | null;
      /** @description Gets or sets the air days. */
      AirDays?: components["schemas"]["DayOfWeek"][] | null;
      /** @description Gets or sets the tags. */
      Tags?: string[] | null;
      /**
       * Format: double
       * @description Gets or sets the primary image aspect ratio, after image enhancements.
       */
      PrimaryImageAspectRatio?: number | null;
      /** @description Gets or sets the artists. */
      Artists?: string[] | null;
      /** @description Gets or sets the artist items. */
      ArtistItems?: components["schemas"]["NameGuidPair"][] | null;
      /** @description Gets or sets the album. */
      Album?: string | null;
      /**
       * @description Gets or sets the type of the collection.
       * @enum {unknown|null}
       */
      CollectionType?: "unknown" | "movies" | "tvshows" | "music" | "musicvideos" | "trailers" | "homevideos" | "boxsets" | "books" | "photos" | "livetv" | "playlists" | "folders" | null;
      /** @description Gets or sets the display order. */
      DisplayOrder?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the album id.
       */
      AlbumId?: string | null;
      /** @description Gets or sets the album image tag. */
      AlbumPrimaryImageTag?: string | null;
      /** @description Gets or sets the series primary image tag. */
      SeriesPrimaryImageTag?: string | null;
      /** @description Gets or sets the album artist. */
      AlbumArtist?: string | null;
      /** @description Gets or sets the album artists. */
      AlbumArtists?: components["schemas"]["NameGuidPair"][] | null;
      /** @description Gets or sets the name of the season. */
      SeasonName?: string | null;
      /** @description Gets or sets the media streams. */
      MediaStreams?: components["schemas"]["MediaStream"][] | null;
      /**
       * @description Gets or sets the type of the video.
       * @enum {unknown|null}
       */
      VideoType?: "VideoFile" | "Iso" | "Dvd" | "BluRay" | null;
      /**
       * Format: int32
       * @description Gets or sets the part count.
       */
      PartCount?: number | null;
      /** Format: int32 */
      MediaSourceCount?: number | null;
      /** @description Gets or sets the image tags. */
      ImageTags?: {
        [key: string]: string;
      } | null;
      /** @description Gets or sets the backdrop image tags. */
      BackdropImageTags?: string[] | null;
      /** @description Gets or sets the screenshot image tags. */
      ScreenshotImageTags?: string[] | null;
      /** @description Gets or sets the parent logo image tag. */
      ParentLogoImageTag?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets whether the item has fan art, this will hold the Id of the Parent that has one.
       */
      ParentArtItemId?: string | null;
      /** @description Gets or sets the parent art image tag. */
      ParentArtImageTag?: string | null;
      /** @description Gets or sets the series thumb image tag. */
      SeriesThumbImageTag?: string | null;
      /**
       * @description Gets or sets the blurhashes for the image tags.
       * Maps image type to dictionary mapping image tag to blurhash value.
       */
      ImageBlurHashes?: {
        Primary?: {
          [key: string]: string;
        };
        Art?: {
          [key: string]: string;
        };
        Backdrop?: {
          [key: string]: string;
        };
        Banner?: {
          [key: string]: string;
        };
        Logo?: {
          [key: string]: string;
        };
        Thumb?: {
          [key: string]: string;
        };
        Disc?: {
          [key: string]: string;
        };
        Box?: {
          [key: string]: string;
        };
        Screenshot?: {
          [key: string]: string;
        };
        Menu?: {
          [key: string]: string;
        };
        Chapter?: {
          [key: string]: string;
        };
        BoxRear?: {
          [key: string]: string;
        };
        Profile?: {
          [key: string]: string;
        };
      } | null;
      /** @description Gets or sets the series studio. */
      SeriesStudio?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the parent thumb item id.
       */
      ParentThumbItemId?: string | null;
      /** @description Gets or sets the parent thumb image tag. */
      ParentThumbImageTag?: string | null;
      /** @description Gets or sets the parent primary image item identifier. */
      ParentPrimaryImageItemId?: string | null;
      /** @description Gets or sets the parent primary image tag. */
      ParentPrimaryImageTag?: string | null;
      /** @description Gets or sets the chapters. */
      Chapters?: components["schemas"]["ChapterInfo"][] | null;
      /** @description Gets or sets the trickplay manifest. */
      Trickplay?: {
        [key: string]: {
          [key: string]: components["schemas"]["TrickplayInfo"];
        };
      } | null;
      /**
       * @description Gets or sets the type of the location.
       * @enum {unknown|null}
       */
      LocationType?: "FileSystem" | "Remote" | "Virtual" | "Offline" | null;
      /**
       * @description Gets or sets the type of the iso.
       * @enum {unknown|null}
       */
      IsoType?: "Dvd" | "BluRay" | null;
      /**
       * @description Gets or sets the type of the media.
       * @enum {unknown}
       */
      MediaType?: "Unknown" | "Video" | "Audio" | "Photo" | "Book";
      /**
       * Format: date-time
       * @description Gets or sets the end date.
       */
      EndDate?: string | null;
      /** @description Gets or sets the locked fields. */
      LockedFields?: components["schemas"]["MetadataField"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the trailer count.
       */
      TrailerCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the movie count.
       */
      MovieCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the series count.
       */
      SeriesCount?: number | null;
      /** Format: int32 */
      ProgramCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the episode count.
       */
      EpisodeCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the song count.
       */
      SongCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the album count.
       */
      AlbumCount?: number | null;
      /** Format: int32 */
      ArtistCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the music video count.
       */
      MusicVideoCount?: number | null;
      /** @description Gets or sets a value indicating whether [enable internet providers]. */
      LockData?: boolean | null;
      /** Format: int32 */
      Width?: number | null;
      /** Format: int32 */
      Height?: number | null;
      CameraMake?: string | null;
      CameraModel?: string | null;
      Software?: string | null;
      /** Format: double */
      ExposureTime?: number | null;
      /** Format: double */
      FocalLength?: number | null;
      /** @enum {unknown|null} */
      ImageOrientation?: "TopLeft" | "TopRight" | "BottomRight" | "BottomLeft" | "LeftTop" | "RightTop" | "RightBottom" | "LeftBottom" | null;
      /** Format: double */
      Aperture?: number | null;
      /** Format: double */
      ShutterSpeed?: number | null;
      /** Format: double */
      Latitude?: number | null;
      /** Format: double */
      Longitude?: number | null;
      /** Format: double */
      Altitude?: number | null;
      /** Format: int32 */
      IsoSpeedRating?: number | null;
      /** @description Gets or sets the series timer identifier. */
      SeriesTimerId?: string | null;
      /** @description Gets or sets the program identifier. */
      ProgramId?: string | null;
      /** @description Gets or sets the channel primary image tag. */
      ChannelPrimaryImageTag?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the start date of the recording, in UTC.
       */
      StartDate?: string | null;
      /**
       * Format: double
       * @description Gets or sets the completion percentage.
       */
      CompletionPercentage?: number | null;
      /** @description Gets or sets a value indicating whether this instance is repeat. */
      IsRepeat?: boolean | null;
      /** @description Gets or sets the episode title. */
      EpisodeTitle?: string | null;
      /**
       * @description Gets or sets the type of the channel.
       * @enum {unknown|null}
       */
      ChannelType?: "TV" | "Radio" | null;
      /**
       * @description Gets or sets the audio.
       * @enum {unknown|null}
       */
      Audio?: "Mono" | "Stereo" | "Dolby" | "DolbyDigital" | "Thx" | "Atmos" | null;
      /** @description Gets or sets a value indicating whether this instance is movie. */
      IsMovie?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is sports. */
      IsSports?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is series. */
      IsSeries?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is live. */
      IsLive?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is news. */
      IsNews?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is kids. */
      IsKids?: boolean | null;
      /** @description Gets or sets a value indicating whether this instance is premiere. */
      IsPremiere?: boolean | null;
      /** @description Gets or sets the timer identifier. */
      TimerId?: string | null;
      /**
       * Format: float
       * @description Gets or sets the gain required for audio normalization.
       */
      NormalizationGain?: number | null;
      /** @description Gets or sets the current program. */
      CurrentProgram?: components["schemas"]["BaseItemDto"] | null;
    };
    BaseItemDtoQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["BaseItemDto"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    /**
     * @description The base item kind.
     * @enum {string}
     */
    BaseItemKind: "AggregateFolder" | "Audio" | "AudioBook" | "BasePluginFolder" | "Book" | "BoxSet" | "Channel" | "ChannelFolderItem" | "CollectionFolder" | "Episode" | "Folder" | "Genre" | "ManualPlaylistsFolder" | "Movie" | "LiveTvChannel" | "LiveTvProgram" | "MusicAlbum" | "MusicArtist" | "MusicGenre" | "MusicVideo" | "Person" | "Photo" | "PhotoAlbum" | "Playlist" | "PlaylistsFolder" | "Program" | "Recording" | "Season" | "Series" | "Studio" | "Trailer" | "TvChannel" | "TvProgram" | "UserRootFolder" | "UserView" | "Video" | "Year";
    /** @description This is used by the api to get information about a Person within a BaseItem. */
    BaseItemPerson: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the identifier.
       */
      Id?: string;
      /** @description Gets or sets the role. */
      Role?: string | null;
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "Unknown" | "Actor" | "Director" | "Composer" | "Writer" | "GuestStar" | "Producer" | "Conductor" | "Lyricist" | "Arranger" | "Engineer" | "Mixer" | "Remixer" | "Creator" | "Artist" | "AlbumArtist" | "Author" | "Illustrator" | "Penciller" | "Inker" | "Colorist" | "Letterer" | "CoverArtist" | "Editor" | "Translator";
      /** @description Gets or sets the primary image tag. */
      PrimaryImageTag?: string | null;
      /** @description Gets or sets the primary image blurhash. */
      ImageBlurHashes?: {
        Primary?: {
          [key: string]: string;
        };
        Art?: {
          [key: string]: string;
        };
        Backdrop?: {
          [key: string]: string;
        };
        Banner?: {
          [key: string]: string;
        };
        Logo?: {
          [key: string]: string;
        };
        Thumb?: {
          [key: string]: string;
        };
        Disc?: {
          [key: string]: string;
        };
        Box?: {
          [key: string]: string;
        };
        Screenshot?: {
          [key: string]: string;
        };
        Menu?: {
          [key: string]: string;
        };
        Chapter?: {
          [key: string]: string;
        };
        BoxRear?: {
          [key: string]: string;
        };
        Profile?: {
          [key: string]: string;
        };
      } | null;
    };
    /** @description Class BasePluginConfiguration. */
    BasePluginConfiguration: Record<string, never>;
    BookInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
      SeriesName?: string | null;
    };
    BookInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["BookInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    BoxSetInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
    };
    BoxSetInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["BoxSetInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    /** @description The branding options. */
    BrandingOptions: {
      /** @description Gets or sets the login disclaimer. */
      LoginDisclaimer?: string | null;
      /** @description Gets or sets the custom CSS. */
      CustomCss?: string | null;
      /** @description Gets or sets a value indicating whether to enable the splashscreen. */
      SplashscreenEnabled?: boolean;
    };
    /** @description Class BufferRequestDto. */
    BufferRequestDto: {
      /**
       * Format: date-time
       * @description Gets or sets when the request has been made by the client.
       */
      When?: string;
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number;
      /** @description Gets or sets a value indicating whether the client playback is unpaused. */
      IsPlaying?: boolean;
      /**
       * Format: uuid
       * @description Gets or sets the playlist item identifier of the playing item.
       */
      PlaylistItemId?: string;
    };
    /** @description The cast receiver application model. */
    CastReceiverApplication: {
      /** @description Gets or sets the cast receiver application id. */
      Id?: string;
      /** @description Gets or sets the cast receiver application name. */
      Name?: string;
    };
    ChannelFeatures: {
      /** @description Gets or sets the name. */
      Name?: string;
      /**
       * Format: uuid
       * @description Gets or sets the identifier.
       */
      Id?: string;
      /** @description Gets or sets a value indicating whether this instance can search. */
      CanSearch?: boolean;
      /** @description Gets or sets the media types. */
      MediaTypes?: components["schemas"]["ChannelMediaType"][];
      /** @description Gets or sets the content types. */
      ContentTypes?: components["schemas"]["ChannelMediaContentType"][];
      /**
       * Format: int32
       * @description Gets or sets the maximum number of records the channel allows retrieving at a time.
       */
      MaxPageSize?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the automatic refresh levels.
       */
      AutoRefreshLevels?: number | null;
      /** @description Gets or sets the default sort orders. */
      DefaultSortFields?: components["schemas"]["ChannelItemSortField"][];
      /** @description Gets or sets a value indicating whether a sort ascending/descending toggle is supported. */
      SupportsSortOrderToggle?: boolean;
      /** @description Gets or sets a value indicating whether [supports latest media]. */
      SupportsLatestMedia?: boolean;
      /** @description Gets or sets a value indicating whether this instance can filter. */
      CanFilter?: boolean;
      /** @description Gets or sets a value indicating whether [supports content downloading]. */
      SupportsContentDownloading?: boolean;
    };
    /** @enum {string} */
    ChannelItemSortField: "Name" | "CommunityRating" | "PremiereDate" | "DateCreated" | "Runtime" | "PlayCount" | "CommunityPlayCount";
    /** @description Channel mapping options dto. */
    ChannelMappingOptionsDto: {
      /** @description Gets or sets list of tuner channels. */
      TunerChannels?: components["schemas"]["TunerChannelMapping"][];
      /** @description Gets or sets list of provider channels. */
      ProviderChannels?: components["schemas"]["NameIdPair"][];
      /** @description Gets or sets list of mappings. */
      Mappings?: components["schemas"]["NameValuePair"][];
      /** @description Gets or sets provider name. */
      ProviderName?: string | null;
    };
    /** @enum {string} */
    ChannelMediaContentType: "Clip" | "Podcast" | "Trailer" | "Movie" | "Episode" | "Song" | "MovieExtra" | "TvExtra";
    /** @enum {string} */
    ChannelMediaType: "Audio" | "Video" | "Photo";
    /**
     * @description Enum ChannelType.
     * @enum {string}
     */
    ChannelType: "TV" | "Radio";
    /** @description Class ChapterInfo. */
    ChapterInfo: {
      /**
       * Format: int64
       * @description Gets or sets the start position ticks.
       */
      StartPositionTicks?: number;
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the image path. */
      ImagePath?: string | null;
      /** Format: date-time */
      ImageDateModified?: string;
      ImageTag?: string | null;
    };
    ClientCapabilities: {
      PlayableMediaTypes?: components["schemas"]["MediaType"][] | null;
      SupportedCommands?: components["schemas"]["GeneralCommandType"][] | null;
      SupportsMediaControl?: boolean;
      SupportsPersistentIdentifier?: boolean;
      /**
       * @description A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
       * <br />
       * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
       * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
       * the device is able to direct play (without transcoding or remuxing),
       * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
       */
      DeviceProfile?: components["schemas"]["DeviceProfile"] | null;
      AppStoreUrl?: string | null;
      IconUrl?: string | null;
      /**
       * @deprecated
       * @default false
       */
      SupportsContentUploading?: boolean | null;
      /**
       * @deprecated
       * @default false
       */
      SupportsSync?: boolean | null;
    };
    /** @description Client capabilities dto. */
    ClientCapabilitiesDto: {
      /** @description Gets or sets the list of playable media types. */
      PlayableMediaTypes?: components["schemas"]["MediaType"][];
      /** @description Gets or sets the list of supported commands. */
      SupportedCommands?: components["schemas"]["GeneralCommandType"][];
      /** @description Gets or sets a value indicating whether session supports media control. */
      SupportsMediaControl?: boolean;
      /** @description Gets or sets a value indicating whether session supports a persistent identifier. */
      SupportsPersistentIdentifier?: boolean;
      /**
       * @description A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
       * <br />
       * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
       * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
       * the device is able to direct play (without transcoding or remuxing),
       * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
       */
      DeviceProfile?: components["schemas"]["DeviceProfile"] | null;
      /** @description Gets or sets the app store url. */
      AppStoreUrl?: string | null;
      /** @description Gets or sets the icon url. */
      IconUrl?: string | null;
      /**
       * @deprecated
       * @default false
       */
      SupportsContentUploading?: boolean | null;
      /**
       * @deprecated
       * @default false
       */
      SupportsSync?: boolean | null;
    };
    /** @description Client log document response dto. */
    ClientLogDocumentResponseDto: {
      /** @description Gets the resulting filename. */
      FileName?: string;
    };
    CodecProfile: {
      /** @enum {unknown} */
      Type?: "Video" | "VideoAudio" | "Audio";
      Conditions?: components["schemas"]["ProfileCondition"][] | null;
      ApplyConditions?: components["schemas"]["ProfileCondition"][] | null;
      Codec?: string | null;
      Container?: string | null;
    };
    /** @enum {string} */
    CodecType: "Video" | "VideoAudio" | "Audio";
    CollectionCreationResult: {
      /** Format: uuid */
      Id?: string;
    };
    /**
     * @description Collection type.
     * @enum {string}
     */
    CollectionType: "unknown" | "movies" | "tvshows" | "music" | "musicvideos" | "trailers" | "homevideos" | "boxsets" | "books" | "photos" | "livetv" | "playlists" | "folders";
    /**
     * @description The collection type options.
     * @enum {string}
     */
    CollectionTypeOptions: "movies" | "tvshows" | "music" | "musicvideos" | "homevideos" | "boxsets" | "books" | "mixed";
    ConfigImageTypes: {
      BackdropSizes?: string[] | null;
      BaseUrl?: string | null;
      LogoSizes?: string[] | null;
      PosterSizes?: string[] | null;
      ProfileSizes?: string[] | null;
      SecureBaseUrl?: string | null;
      StillSizes?: string[] | null;
    };
    /** @description The configuration page info. */
    ConfigurationPageInfo: {
      /** @description Gets or sets the name. */
      Name?: string;
      /** @description Gets or sets a value indicating whether the configurations page is enabled in the main menu. */
      EnableInMainMenu?: boolean;
      /** @description Gets or sets the menu section. */
      MenuSection?: string | null;
      /** @description Gets or sets the menu icon. */
      MenuIcon?: string | null;
      /** @description Gets or sets the display name. */
      DisplayName?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the plugin id.
       */
      PluginId?: string | null;
    };
    ContainerProfile: {
      /** @enum {unknown} */
      Type?: "Audio" | "Video" | "Photo" | "Subtitle" | "Lyric";
      Conditions?: components["schemas"]["ProfileCondition"][];
      Container?: string;
    };
    /** @description Class CountryInfo. */
    CountryInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the display name. */
      DisplayName?: string | null;
      /** @description Gets or sets the name of the two letter ISO region. */
      TwoLetterISORegionName?: string | null;
      /** @description Gets or sets the name of the three letter ISO region. */
      ThreeLetterISORegionName?: string | null;
    };
    /** @description Create new playlist dto. */
    CreatePlaylistDto: {
      /** @description Gets or sets the name of the new playlist. */
      Name?: string;
      /** @description Gets or sets item ids to add to the playlist. */
      Ids?: string[];
      /**
       * Format: uuid
       * @description Gets or sets the user id.
       */
      UserId?: string | null;
      /**
       * @description Gets or sets the media type.
       * @enum {unknown|null}
       */
      MediaType?: "Unknown" | "Video" | "Audio" | "Photo" | "Book" | null;
      /** @description Gets or sets the playlist users. */
      Users?: components["schemas"]["PlaylistUserPermissions"][];
      /** @description Gets or sets a value indicating whether the playlist is public. */
      IsPublic?: boolean;
    };
    /** @description The create user by name request body. */
    CreateUserByName: {
      /** @description Gets or sets the username. */
      Name: string;
      /** @description Gets or sets the password. */
      Password?: string | null;
    };
    /** @description Class CultureDto. */
    CultureDto: {
      /** @description Gets the name. */
      Name?: string;
      /** @description Gets the display name. */
      DisplayName?: string;
      /** @description Gets the name of the two letter ISO language. */
      TwoLetterISOLanguageName?: string;
      /** @description Gets the name of the three letter ISO language. */
      ThreeLetterISOLanguageName?: string | null;
      ThreeLetterISOLanguageNames?: string[];
    };
    /** @enum {string} */
    DayOfWeek: "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday";
    /** @enum {string} */
    DayPattern: "Daily" | "Weekdays" | "Weekends";
    /** @description Default directory browser info. */
    DefaultDirectoryBrowserInfoDto: {
      /** @description Gets or sets the path. */
      Path?: string | null;
    };
    DeviceInfo: {
      Name?: string | null;
      CustomName?: string | null;
      /** @description Gets or sets the access token. */
      AccessToken?: string | null;
      /** @description Gets or sets the identifier. */
      Id?: string | null;
      /** @description Gets or sets the last name of the user. */
      LastUserName?: string | null;
      /** @description Gets or sets the name of the application. */
      AppName?: string | null;
      /** @description Gets or sets the application version. */
      AppVersion?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the last user identifier.
       */
      LastUserId?: string;
      /**
       * Format: date-time
       * @description Gets or sets the date last modified.
       */
      DateLastActivity?: string;
      /** @description Gets or sets the capabilities. */
      Capabilities?: components["schemas"]["ClientCapabilities"] | null;
      IconUrl?: string | null;
    };
    DeviceInfoQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["DeviceInfo"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    /** @description An entity representing custom options for a device. */
    DeviceOptions: {
      /**
       * Format: int32
       * @description Gets the id.
       */
      Id?: number;
      /** @description Gets the device id. */
      DeviceId?: string;
      /** @description Gets or sets the custom name. */
      CustomName?: string | null;
    };
    /** @description A dto representing custom options for a device. */
    DeviceOptionsDto: {
      /**
       * Format: int32
       * @description Gets or sets the id.
       */
      Id?: number;
      /** @description Gets or sets the device id. */
      DeviceId?: string | null;
      /** @description Gets or sets the custom name. */
      CustomName?: string | null;
    };
    /**
     * @description A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
     * <br />
     * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
     * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
     * the device is able to direct play (without transcoding or remuxing),
     * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
     */
    DeviceProfile: {
      /** @description Gets or sets the name of this device profile. */
      Name?: string | null;
      /** @description Gets or sets the Id. */
      Id?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the maximum allowed bitrate for all streamed content.
       */
      MaxStreamingBitrate?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the maximum allowed bitrate for statically streamed content (= direct played files).
       */
      MaxStaticBitrate?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the maximum allowed bitrate for transcoded music streams.
       */
      MusicStreamingTranscodingBitrate?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the maximum allowed bitrate for statically streamed (= direct played) music files.
       */
      MaxStaticMusicBitrate?: number | null;
      /** @description Gets or sets the direct play profiles. */
      DirectPlayProfiles?: components["schemas"]["DirectPlayProfile"][];
      /** @description Gets or sets the transcoding profiles. */
      TranscodingProfiles?: components["schemas"]["TranscodingProfile"][];
      /** @description Gets or sets the container profiles. */
      ContainerProfiles?: components["schemas"]["ContainerProfile"][];
      /** @description Gets or sets the codec profiles. */
      CodecProfiles?: components["schemas"]["CodecProfile"][];
      /** @description Gets or sets the subtitle profiles. */
      SubtitleProfiles?: components["schemas"]["SubtitleProfile"][];
    };
    DirectPlayProfile: {
      Container?: string | null;
      AudioCodec?: string | null;
      VideoCodec?: string | null;
      /** @enum {unknown} */
      Type?: "Audio" | "Video" | "Photo" | "Subtitle" | "Lyric";
    };
    /** @description Defines the display preferences for any item that supports them (usually Folders). */
    DisplayPreferencesDto: {
      /** @description Gets or sets the user id. */
      Id?: string | null;
      /** @description Gets or sets the type of the view. */
      ViewType?: string | null;
      /** @description Gets or sets the sort by. */
      SortBy?: string | null;
      /** @description Gets or sets the index by. */
      IndexBy?: string | null;
      /** @description Gets or sets a value indicating whether [remember indexing]. */
      RememberIndexing?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the height of the primary image.
       */
      PrimaryImageHeight?: number;
      /**
       * Format: int32
       * @description Gets or sets the width of the primary image.
       */
      PrimaryImageWidth?: number;
      /** @description Gets or sets the custom prefs. */
      CustomPrefs?: {
        [key: string]: string | null;
      };
      /**
       * @description Gets or sets the scroll direction.
       * @enum {unknown}
       */
      ScrollDirection?: "Horizontal" | "Vertical";
      /** @description Gets or sets a value indicating whether to show backdrops on this item. */
      ShowBackdrop?: boolean;
      /** @description Gets or sets a value indicating whether [remember sorting]. */
      RememberSorting?: boolean;
      /**
       * @description Gets or sets the sort order.
       * @enum {unknown}
       */
      SortOrder?: "Ascending" | "Descending";
      /** @description Gets or sets a value indicating whether [show sidebar]. */
      ShowSidebar?: boolean;
      /** @description Gets or sets the client. */
      Client?: string | null;
    };
    /** @enum {string} */
    DlnaProfileType: "Audio" | "Video" | "Photo" | "Subtitle" | "Lyric";
    /**
     * @description An enum representing an algorithm to downmix 6ch+ to stereo.
     * Algorithms sourced from https://superuser.com/questions/852400/properly-downmix-5-1-to-stereo-using-ffmpeg/1410620#1410620.
     * @enum {string}
     */
    DownMixStereoAlgorithms: "None" | "Dave750" | "NightmodeDialogue";
    /**
     * @description An enum that represents a day of the week, weekdays, weekends, or all days.
     * @enum {string}
     */
    DynamicDayOfWeek: "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Everyday" | "Weekday" | "Weekend";
    /**
     * @description An enum representing the options to disable embedded subs.
     * @enum {string}
     */
    EmbeddedSubtitleOptions: "AllowAll" | "AllowText" | "AllowImage" | "AllowNone";
    /** @enum {string} */
    EncodingContext: "Streaming" | "Static";
    /** @description Class EncodingOptions. */
    EncodingOptions: {
      /**
       * Format: int32
       * @description Gets or sets the thread count used for encoding.
       */
      EncodingThreadCount?: number;
      /** @description Gets or sets the temporary transcoding path. */
      TranscodingTempPath?: string | null;
      /** @description Gets or sets the path to the fallback font. */
      FallbackFontPath?: string | null;
      /** @description Gets or sets a value indicating whether to use the fallback font. */
      EnableFallbackFont?: boolean;
      /** @description Gets or sets a value indicating whether audio VBR is enabled. */
      EnableAudioVbr?: boolean;
      /**
       * Format: double
       * @description Gets or sets the audio boost applied when downmixing audio.
       */
      DownMixAudioBoost?: number;
      /**
       * @description Gets or sets the algorithm used for downmixing audio to stereo.
       * @enum {unknown}
       */
      DownMixStereoAlgorithm?: "None" | "Dave750" | "NightmodeDialogue";
      /**
       * Format: int32
       * @description Gets or sets the maximum size of the muxing queue.
       */
      MaxMuxingQueueSize?: number;
      /** @description Gets or sets a value indicating whether throttling is enabled. */
      EnableThrottling?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the delay after which throttling happens.
       */
      ThrottleDelaySeconds?: number;
      /** @description Gets or sets a value indicating whether segment deletion is enabled. */
      EnableSegmentDeletion?: boolean;
      /**
       * Format: int32
       * @description Gets or sets seconds for which segments should be kept before being deleted.
       */
      SegmentKeepSeconds?: number;
      /** @description Gets or sets the hardware acceleration type. */
      HardwareAccelerationType?: string | null;
      /** @description Gets or sets the FFmpeg path as set by the user via the UI. */
      EncoderAppPath?: string | null;
      /** @description Gets or sets the current FFmpeg path being used by the system and displayed on the transcode page. */
      EncoderAppPathDisplay?: string | null;
      /** @description Gets or sets the VA-API device. */
      VaapiDevice?: string | null;
      /** @description Gets or sets a value indicating whether tonemapping is enabled. */
      EnableTonemapping?: boolean;
      /** @description Gets or sets a value indicating whether VPP tonemapping is enabled. */
      EnableVppTonemapping?: boolean;
      /** @description Gets or sets a value indicating whether videotoolbox tonemapping is enabled. */
      EnableVideoToolboxTonemapping?: boolean;
      /** @description Gets or sets the tone-mapping algorithm. */
      TonemappingAlgorithm?: string | null;
      /** @description Gets or sets the tone-mapping mode. */
      TonemappingMode?: string | null;
      /** @description Gets or sets the tone-mapping range. */
      TonemappingRange?: string | null;
      /**
       * Format: double
       * @description Gets or sets the tone-mapping desaturation.
       */
      TonemappingDesat?: number;
      /**
       * Format: double
       * @description Gets or sets the tone-mapping peak.
       */
      TonemappingPeak?: number;
      /**
       * Format: double
       * @description Gets or sets the tone-mapping parameters.
       */
      TonemappingParam?: number;
      /**
       * Format: double
       * @description Gets or sets the VPP tone-mapping brightness.
       */
      VppTonemappingBrightness?: number;
      /**
       * Format: double
       * @description Gets or sets the VPP tone-mapping contrast.
       */
      VppTonemappingContrast?: number;
      /**
       * Format: int32
       * @description Gets or sets the H264 CRF.
       */
      H264Crf?: number;
      /**
       * Format: int32
       * @description Gets or sets the H265 CRF.
       */
      H265Crf?: number;
      /** @description Gets or sets the encoder preset. */
      EncoderPreset?: string | null;
      /** @description Gets or sets a value indicating whether the framerate is doubled when deinterlacing. */
      DeinterlaceDoubleRate?: boolean;
      /** @description Gets or sets the deinterlace method. */
      DeinterlaceMethod?: string | null;
      /** @description Gets or sets a value indicating whether 10bit HEVC decoding is enabled. */
      EnableDecodingColorDepth10Hevc?: boolean;
      /** @description Gets or sets a value indicating whether 10bit VP9 decoding is enabled. */
      EnableDecodingColorDepth10Vp9?: boolean;
      /** @description Gets or sets a value indicating whether the enhanced NVDEC is enabled. */
      EnableEnhancedNvdecDecoder?: boolean;
      /** @description Gets or sets a value indicating whether the system native hardware decoder should be used. */
      PreferSystemNativeHwDecoder?: boolean;
      /** @description Gets or sets a value indicating whether the Intel H264 low-power hardware encoder should be used. */
      EnableIntelLowPowerH264HwEncoder?: boolean;
      /** @description Gets or sets a value indicating whether the Intel HEVC low-power hardware encoder should be used. */
      EnableIntelLowPowerHevcHwEncoder?: boolean;
      /** @description Gets or sets a value indicating whether hardware encoding is enabled. */
      EnableHardwareEncoding?: boolean;
      /** @description Gets or sets a value indicating whether HEVC encoding is enabled. */
      AllowHevcEncoding?: boolean;
      /** @description Gets or sets a value indicating whether AV1 encoding is enabled. */
      AllowAv1Encoding?: boolean;
      /** @description Gets or sets a value indicating whether subtitle extraction is enabled. */
      EnableSubtitleExtraction?: boolean;
      /** @description Gets or sets the codecs hardware encoding is used for. */
      HardwareDecodingCodecs?: string[] | null;
      /** @description Gets or sets the file extensions on-demand metadata based keyframe extraction is enabled for. */
      AllowOnDemandMetadataBasedKeyframeExtractionForExtensions?: string[] | null;
    };
    EndPointInfo: {
      IsLocal?: boolean;
      IsInNetwork?: boolean;
    };
    /** @description Represents the external id information for serialization to the client. */
    ExternalIdInfo: {
      /** @description Gets or sets the display name of the external id provider (IE: IMDB, MusicBrainz, etc). */
      Name?: string;
      /** @description Gets or sets the unique key for this id. This key should be unique across all providers. */
      Key?: string;
      /**
       * @description Gets or sets the specific media type for this id. This is used to distinguish between the different
       * external id types for providers with multiple ids.
       * A null value indicates there is no specific media type associated with the external id, or this is the
       * default id for the external provider so there is no need to specify a type.
       * @enum {unknown|null}
       */
      Type?: "Album" | "AlbumArtist" | "Artist" | "BoxSet" | "Episode" | "Movie" | "OtherArtist" | "Person" | "ReleaseGroup" | "Season" | "Series" | "Track" | "Book" | null;
      /** @description Gets or sets the URL format string. */
      UrlFormatString?: string | null;
    };
    /**
     * @description The specific media type of an MediaBrowser.Model.Providers.ExternalIdInfo.
     * @enum {string}
     */
    ExternalIdMediaType: "Album" | "AlbumArtist" | "Artist" | "BoxSet" | "Episode" | "Movie" | "OtherArtist" | "Person" | "ReleaseGroup" | "Season" | "Series" | "Track" | "Book";
    ExternalUrl: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the type of the item. */
      Url?: string | null;
    };
    /** @enum {string} */
    ExtraType: "Unknown" | "Clip" | "Trailer" | "BehindTheScenes" | "DeletedScene" | "Interview" | "Scene" | "Sample" | "ThemeSong" | "ThemeVideo" | "Featurette" | "Short";
    /** @description Class FileSystemEntryInfo. */
    FileSystemEntryInfo: {
      /** @description Gets the name. */
      Name?: string;
      /** @description Gets the path. */
      Path?: string;
      /**
       * @description Gets the type.
       * @enum {unknown}
       */
      Type?: "File" | "Directory" | "NetworkComputer" | "NetworkShare";
    };
    /**
     * @description Enum FileSystemEntryType.
     * @enum {string}
     */
    FileSystemEntryType: "File" | "Directory" | "NetworkComputer" | "NetworkShare";
    /** @description Class FontFile. */
    FontFile: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the size.
       */
      Size?: number;
      /**
       * Format: date-time
       * @description Gets or sets the date created.
       */
      DateCreated?: string;
      /**
       * Format: date-time
       * @description Gets or sets the date modified.
       */
      DateModified?: string;
    };
    /** @description Force keep alive websocket messages. */
    ForceKeepAliveMessage: {
      /**
       * Format: int32
       * @description Gets or sets the data.
       */
      Data?: number;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ForceKeepAlive
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @enum {string} */
    ForgotPasswordAction: "ContactAdmin" | "PinCode" | "InNetworkRequired";
    /** @description Forgot Password request body DTO. */
    ForgotPasswordDto: {
      /** @description Gets or sets the entered username to have its password reset. */
      EnteredUsername: string;
    };
    /** @description Forgot Password Pin enter request body DTO. */
    ForgotPasswordPinDto: {
      /** @description Gets or sets the entered pin to have the password reset. */
      Pin: string;
    };
    ForgotPasswordResult: {
      /**
       * @description Gets or sets the action.
       * @enum {unknown}
       */
      Action?: "ContactAdmin" | "PinCode" | "InNetworkRequired";
      /** @description Gets or sets the pin file. */
      PinFile?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the pin expiration date.
       */
      PinExpirationDate?: string | null;
    };
    GeneralCommand: {
      /**
       * @description This exists simply to identify a set of known commands.
       * @enum {unknown}
       */
      Name?: "MoveUp" | "MoveDown" | "MoveLeft" | "MoveRight" | "PageUp" | "PageDown" | "PreviousLetter" | "NextLetter" | "ToggleOsd" | "ToggleContextMenu" | "Select" | "Back" | "TakeScreenshot" | "SendKey" | "SendString" | "GoHome" | "GoToSettings" | "VolumeUp" | "VolumeDown" | "Mute" | "Unmute" | "ToggleMute" | "SetVolume" | "SetAudioStreamIndex" | "SetSubtitleStreamIndex" | "ToggleFullscreen" | "DisplayContent" | "GoToSearch" | "DisplayMessage" | "SetRepeatMode" | "ChannelUp" | "ChannelDown" | "Guide" | "ToggleStats" | "PlayMediaSource" | "PlayTrailers" | "SetShuffleQueue" | "PlayState" | "PlayNext" | "ToggleOsdMenu" | "Play" | "SetMaxStreamingBitrate" | "SetPlaybackOrder";
      /** Format: uuid */
      ControllingUserId?: string;
      Arguments?: {
        [key: string]: string | null;
      };
    };
    /** @description General command websocket message. */
    GeneralCommandMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["GeneralCommand"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default GeneralCommand
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /**
     * @description This exists simply to identify a set of known commands.
     * @enum {string}
     */
    GeneralCommandType: "MoveUp" | "MoveDown" | "MoveLeft" | "MoveRight" | "PageUp" | "PageDown" | "PreviousLetter" | "NextLetter" | "ToggleOsd" | "ToggleContextMenu" | "Select" | "Back" | "TakeScreenshot" | "SendKey" | "SendString" | "GoHome" | "GoToSettings" | "VolumeUp" | "VolumeDown" | "Mute" | "Unmute" | "ToggleMute" | "SetVolume" | "SetAudioStreamIndex" | "SetSubtitleStreamIndex" | "ToggleFullscreen" | "DisplayContent" | "GoToSearch" | "DisplayMessage" | "SetRepeatMode" | "ChannelUp" | "ChannelDown" | "Guide" | "ToggleStats" | "PlayMediaSource" | "PlayTrailers" | "SetShuffleQueue" | "PlayState" | "PlayNext" | "ToggleOsdMenu" | "Play" | "SetMaxStreamingBitrate" | "SetPlaybackOrder";
    /** @description Get programs dto. */
    GetProgramsDto: {
      /** @description Gets or sets the channels to return guide information for. */
      ChannelIds?: string[];
      /**
       * Format: uuid
       * @description Gets or sets optional. Filter by user id.
       */
      UserId?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the minimum premiere start date.
       * Optional.
       */
      MinStartDate?: string | null;
      /**
       * @description Gets or sets filter by programs that have completed airing, or not.
       * Optional.
       */
      HasAired?: boolean | null;
      /**
       * @description Gets or sets filter by programs that are currently airing, or not.
       * Optional.
       */
      IsAiring?: boolean | null;
      /**
       * Format: date-time
       * @description Gets or sets the maximum premiere start date.
       * Optional.
       */
      MaxStartDate?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the minimum premiere end date.
       * Optional.
       */
      MinEndDate?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the maximum premiere end date.
       * Optional.
       */
      MaxEndDate?: string | null;
      /**
       * @description Gets or sets filter for movies.
       * Optional.
       */
      IsMovie?: boolean | null;
      /**
       * @description Gets or sets filter for series.
       * Optional.
       */
      IsSeries?: boolean | null;
      /**
       * @description Gets or sets filter for news.
       * Optional.
       */
      IsNews?: boolean | null;
      /**
       * @description Gets or sets filter for kids.
       * Optional.
       */
      IsKids?: boolean | null;
      /**
       * @description Gets or sets filter for sports.
       * Optional.
       */
      IsSports?: boolean | null;
      /**
       * Format: int32
       * @description Gets or sets the record index to start at. All items with a lower index will be dropped from the results.
       * Optional.
       */
      StartIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the maximum number of records to return.
       * Optional.
       */
      Limit?: number | null;
      /**
       * @description Gets or sets specify one or more sort orders, comma delimited. Options: Name, StartDate.
       * Optional.
       */
      SortBy?: components["schemas"]["ItemSortBy"][];
      /** @description Gets or sets sort Order - Ascending,Descending. */
      SortOrder?: components["schemas"]["SortOrder"][];
      /** @description Gets or sets the genres to return guide information for. */
      Genres?: string[];
      /** @description Gets or sets the genre ids to return guide information for. */
      GenreIds?: string[];
      /**
       * @description Gets or sets include image information in output.
       * Optional.
       */
      EnableImages?: boolean | null;
      /** @description Gets or sets a value indicating whether retrieve total record count. */
      EnableTotalRecordCount?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the max number of images to return, per image type.
       * Optional.
       */
      ImageTypeLimit?: number | null;
      /**
       * @description Gets or sets the image types to include in the output.
       * Optional.
       */
      EnableImageTypes?: components["schemas"]["ImageType"][];
      /**
       * @description Gets or sets include user data.
       * Optional.
       */
      EnableUserData?: boolean | null;
      /**
       * @description Gets or sets filter by series timer id.
       * Optional.
       */
      SeriesTimerId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets filter by library series id.
       * Optional.
       */
      LibrarySeriesId?: string;
      /**
       * @description Gets or sets specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
       * Optional.
       */
      Fields?: components["schemas"]["ItemFields"][];
    };
    /** @description Class GroupInfoDto. */
    GroupInfoDto: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /** @description Gets the group name. */
      GroupName?: string;
      /**
       * @description Gets the group state.
       * @enum {unknown}
       */
      State?: "Idle" | "Waiting" | "Paused" | "Playing";
      /** @description Gets the participants. */
      Participants?: string[];
      /**
       * Format: date-time
       * @description Gets the date when this DTO has been created.
       */
      LastUpdatedAt?: string;
    };
    /** @description Class GroupUpdate. */
    GroupInfoDtoGroupUpdate: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * @description Gets the update type.
       * @enum {unknown}
       */
      Type?: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
      /** @description Gets the update data. */
      Data?: components["schemas"]["GroupInfoDto"];
    };
    /**
     * @description Enum GroupQueueMode.
     * @enum {string}
     */
    GroupQueueMode: "Queue" | "QueueNext";
    /**
     * @description Enum GroupRepeatMode.
     * @enum {string}
     */
    GroupRepeatMode: "RepeatOne" | "RepeatAll" | "RepeatNone";
    /**
     * @description Enum GroupShuffleMode.
     * @enum {string}
     */
    GroupShuffleMode: "Sorted" | "Shuffle";
    /**
     * @description Enum GroupState.
     * @enum {string}
     */
    GroupStateType: "Idle" | "Waiting" | "Paused" | "Playing";
    /** @description Class GroupStateUpdate. */
    GroupStateUpdate: {
      /**
       * @description Gets the state of the group.
       * @enum {unknown}
       */
      State?: "Idle" | "Waiting" | "Paused" | "Playing";
      /**
       * @description Gets the reason of the state change.
       * @enum {unknown}
       */
      Reason?: "Play" | "SetPlaylistItem" | "RemoveFromPlaylist" | "MovePlaylistItem" | "Queue" | "Unpause" | "Pause" | "Stop" | "Seek" | "Buffer" | "Ready" | "NextItem" | "PreviousItem" | "SetRepeatMode" | "SetShuffleMode" | "Ping" | "IgnoreWait";
    };
    /** @description Class GroupUpdate. */
    GroupStateUpdateGroupUpdate: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * @description Gets the update type.
       * @enum {unknown}
       */
      Type?: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
      /** @description Gets the update data. */
      Data?: components["schemas"]["GroupStateUpdate"];
    };
    /** @description Group update without data. */
    GroupUpdate: ({
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * @description Gets the update type.
       * @enum {unknown}
       */
      Type?: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
    }) & (components["schemas"]["GroupInfoDtoGroupUpdate"] | components["schemas"]["GroupStateUpdateGroupUpdate"] | components["schemas"]["StringGroupUpdate"] | components["schemas"]["PlayQueueUpdateGroupUpdate"]);
    /**
     * @description Enum GroupUpdateType.
     * @enum {string}
     */
    GroupUpdateType: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
    GuideInfo: {
      /**
       * Format: date-time
       * @description Gets or sets the start date.
       */
      StartDate?: string;
      /**
       * Format: date-time
       * @description Gets or sets the end date.
       */
      EndDate?: string;
    };
    /**
     * @description Enum HardwareEncodingType.
     * @enum {string}
     */
    HardwareEncodingType: "AMF" | "QSV" | "NVENC" | "V4L2M2M" | "VAAPI" | "VideoToolBox" | "RKMPP";
    /** @description Class IgnoreWaitRequestDto. */
    IgnoreWaitRequestDto: {
      /** @description Gets or sets a value indicating whether the client should be ignored. */
      IgnoreWait?: boolean;
    };
    /**
     * @description Enum ImageOutputFormat.
     * @enum {string}
     */
    ImageFormat: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
    /** @description Class ImageInfo. */
    ImageInfo: {
      /**
       * @description Gets or sets the type of the image.
       * @enum {unknown}
       */
      ImageType?: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      /**
       * Format: int32
       * @description Gets or sets the index of the image.
       */
      ImageIndex?: number | null;
      /** @description Gets or sets the image tag. */
      ImageTag?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the blurhash. */
      BlurHash?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the height.
       */
      Height?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the width.
       */
      Width?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the size.
       */
      Size?: number;
    };
    ImageOption: {
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      /**
       * Format: int32
       * @description Gets or sets the limit.
       */
      Limit?: number;
      /**
       * Format: int32
       * @description Gets or sets the minimum width.
       */
      MinWidth?: number;
    };
    /** @enum {string} */
    ImageOrientation: "TopLeft" | "TopRight" | "BottomRight" | "BottomLeft" | "LeftTop" | "RightTop" | "RightBottom" | "LeftBottom";
    /** @description Class ImageProviderInfo. */
    ImageProviderInfo: {
      /** @description Gets the name. */
      Name?: string;
      /** @description Gets the supported image types. */
      SupportedImages?: components["schemas"]["ImageType"][];
    };
    /**
     * @description Enum ImageResolution.
     * @enum {string}
     */
    ImageResolution: "MatchSource" | "P144" | "P240" | "P360" | "P480" | "P720" | "P1080" | "P1440" | "P2160";
    /** @enum {string} */
    ImageSavingConvention: "Legacy" | "Compatible";
    /**
     * @description Enum ImageType.
     * @enum {string}
     */
    ImageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
    /** @description Keep alive websocket messages. */
    InboundKeepAliveMessage: {
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default KeepAlive
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Represents the list of possible inbound websocket types */
    InboundWebSocketMessage: components["schemas"]["ActivityLogEntryStartMessage"] | components["schemas"]["ActivityLogEntryStopMessage"] | components["schemas"]["InboundKeepAliveMessage"] | components["schemas"]["ScheduledTasksInfoStartMessage"] | components["schemas"]["ScheduledTasksInfoStopMessage"] | components["schemas"]["SessionsStartMessage"] | components["schemas"]["SessionsStopMessage"];
    /** @description Class InstallationInfo. */
    InstallationInfo: {
      /**
       * Format: uuid
       * @description Gets or sets the Id.
       */
      Guid?: string;
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the version. */
      Version?: string | null;
      /** @description Gets or sets the changelog for this version. */
      Changelog?: string | null;
      /** @description Gets or sets the source URL. */
      SourceUrl?: string | null;
      /** @description Gets or sets a checksum for the binary. */
      Checksum?: string | null;
      /** @description Gets or sets package information for the installation. */
      PackageInfo?: components["schemas"]["PackageInfo"] | null;
    };
    /** @description Defines the MediaBrowser.Common.Plugins.IPlugin. */
    IPlugin: {
      /** @description Gets the name of the plugin. */
      Name?: string | null;
      /** @description Gets the Description. */
      Description?: string | null;
      /**
       * Format: uuid
       * @description Gets the unique id.
       */
      Id?: string;
      /** @description Gets the plugin version. */
      Version?: string | null;
      /** @description Gets the path to the assembly file. */
      AssemblyFilePath?: string | null;
      /** @description Gets a value indicating whether the plugin can be uninstalled. */
      CanUninstall?: boolean;
      /** @description Gets the full path to the data folder, where the plugin can store any miscellaneous files needed. */
      DataFolderPath?: string | null;
    };
    /**
     * @description Enum IsoType.
     * @enum {string}
     */
    IsoType: "Dvd" | "BluRay";
    /** @description Class LibrarySummary. */
    ItemCounts: {
      /**
       * Format: int32
       * @description Gets or sets the movie count.
       */
      MovieCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the series count.
       */
      SeriesCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the episode count.
       */
      EpisodeCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the artist count.
       */
      ArtistCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the program count.
       */
      ProgramCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the trailer count.
       */
      TrailerCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the song count.
       */
      SongCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the album count.
       */
      AlbumCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the music video count.
       */
      MusicVideoCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the box set count.
       */
      BoxSetCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the book count.
       */
      BookCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the item count.
       */
      ItemCount?: number;
    };
    /**
     * @description Used to control the data that gets attached to DtoBaseItems.
     * @enum {string}
     */
    ItemFields: "AirTime" | "CanDelete" | "CanDownload" | "ChannelInfo" | "Chapters" | "Trickplay" | "ChildCount" | "CumulativeRunTimeTicks" | "CustomRating" | "DateCreated" | "DateLastMediaAdded" | "DisplayPreferencesId" | "Etag" | "ExternalUrls" | "Genres" | "HomePageUrl" | "ItemCounts" | "MediaSourceCount" | "MediaSources" | "OriginalTitle" | "Overview" | "ParentId" | "Path" | "People" | "PlayAccess" | "ProductionLocations" | "ProviderIds" | "PrimaryImageAspectRatio" | "RecursiveItemCount" | "Settings" | "ScreenshotImageTags" | "SeriesPrimaryImage" | "SeriesStudio" | "SortName" | "SpecialEpisodeNumbers" | "Studios" | "Taglines" | "Tags" | "RemoteTrailers" | "MediaStreams" | "SeasonUserData" | "ServiceName" | "ThemeSongIds" | "ThemeVideoIds" | "ExternalEtag" | "PresentationUniqueKey" | "InheritedParentalRatingValue" | "ExternalSeriesId" | "SeriesPresentationUniqueKey" | "DateLastRefreshed" | "DateLastSaved" | "RefreshState" | "ChannelImage" | "EnableMediaSourceDisplay" | "Width" | "Height" | "ExtraIds" | "LocalTrailerCount" | "IsHD" | "SpecialFeatureCount";
    /**
     * @description Enum ItemFilter.
     * @enum {string}
     */
    ItemFilter: "IsFolder" | "IsNotFolder" | "IsUnplayed" | "IsPlayed" | "IsFavorite" | "IsResumable" | "Likes" | "Dislikes" | "IsFavoriteOrLikes";
    /**
     * @description These represent sort orders.
     * @enum {string}
     */
    ItemSortBy: "Default" | "AiredEpisodeOrder" | "Album" | "AlbumArtist" | "Artist" | "DateCreated" | "OfficialRating" | "DatePlayed" | "PremiereDate" | "StartDate" | "SortName" | "Name" | "Random" | "Runtime" | "CommunityRating" | "ProductionYear" | "PlayCount" | "CriticRating" | "IsFolder" | "IsUnplayed" | "IsPlayed" | "SeriesSortName" | "VideoBitRate" | "AirTime" | "Studio" | "IsFavoriteOrLiked" | "DateLastContentAdded" | "SeriesDatePlayed" | "ParentIndexNumber" | "IndexNumber" | "SimilarityScore" | "SearchScore";
    /** @description Class JoinGroupRequestDto. */
    JoinGroupRequestDto: {
      /**
       * Format: uuid
       * @description Gets or sets the group identifier.
       */
      GroupId?: string;
    };
    /** @enum {string} */
    KeepUntil: "UntilDeleted" | "UntilSpaceNeeded" | "UntilWatched" | "UntilDate";
    /** @description Library changed message. */
    LibraryChangedMessage: {
      /** @description Class LibraryUpdateInfo. */
      Data?: components["schemas"]["LibraryUpdateInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default LibraryChanged
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Library option info dto. */
    LibraryOptionInfoDto: {
      /** @description Gets or sets name. */
      Name?: string | null;
      /** @description Gets or sets a value indicating whether default enabled. */
      DefaultEnabled?: boolean;
    };
    LibraryOptions: {
      Enabled?: boolean;
      EnablePhotos?: boolean;
      EnableRealtimeMonitor?: boolean;
      EnableLUFSScan?: boolean;
      EnableChapterImageExtraction?: boolean;
      ExtractChapterImagesDuringLibraryScan?: boolean;
      EnableTrickplayImageExtraction?: boolean;
      ExtractTrickplayImagesDuringLibraryScan?: boolean;
      PathInfos?: components["schemas"]["MediaPathInfo"][];
      SaveLocalMetadata?: boolean;
      /** @deprecated */
      EnableInternetProviders?: boolean;
      EnableAutomaticSeriesGrouping?: boolean;
      EnableEmbeddedTitles?: boolean;
      EnableEmbeddedExtrasTitles?: boolean;
      EnableEmbeddedEpisodeInfos?: boolean;
      /** Format: int32 */
      AutomaticRefreshIntervalDays?: number;
      /** @description Gets or sets the preferred metadata language. */
      PreferredMetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      SeasonZeroDisplayName?: string;
      MetadataSavers?: string[] | null;
      DisabledLocalMetadataReaders?: string[];
      LocalMetadataReaderOrder?: string[] | null;
      DisabledSubtitleFetchers?: string[];
      SubtitleFetcherOrder?: string[];
      SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
      SkipSubtitlesIfAudioTrackMatches?: boolean;
      SubtitleDownloadLanguages?: string[] | null;
      RequirePerfectSubtitleMatch?: boolean;
      SaveSubtitlesWithMedia?: boolean;
      /** @default false */
      SaveLyricsWithMedia?: boolean;
      AutomaticallyAddToCollection?: boolean;
      /**
       * @description An enum representing the options to disable embedded subs.
       * @enum {unknown}
       */
      AllowEmbeddedSubtitles?: "AllowAll" | "AllowText" | "AllowImage" | "AllowNone";
      TypeOptions?: components["schemas"]["TypeOptions"][];
    };
    /** @description Library options result dto. */
    LibraryOptionsResultDto: {
      /** @description Gets or sets the metadata savers. */
      MetadataSavers?: components["schemas"]["LibraryOptionInfoDto"][];
      /** @description Gets or sets the metadata readers. */
      MetadataReaders?: components["schemas"]["LibraryOptionInfoDto"][];
      /** @description Gets or sets the subtitle fetchers. */
      SubtitleFetchers?: components["schemas"]["LibraryOptionInfoDto"][];
      /** @description Gets or sets the type options. */
      TypeOptions?: components["schemas"]["LibraryTypeOptionsDto"][];
    };
    /** @description Library type options dto. */
    LibraryTypeOptionsDto: {
      /** @description Gets or sets the type. */
      Type?: string | null;
      /** @description Gets or sets the metadata fetchers. */
      MetadataFetchers?: components["schemas"]["LibraryOptionInfoDto"][];
      /** @description Gets or sets the image fetchers. */
      ImageFetchers?: components["schemas"]["LibraryOptionInfoDto"][];
      /** @description Gets or sets the supported image types. */
      SupportedImageTypes?: components["schemas"]["ImageType"][];
      /** @description Gets or sets the default image options. */
      DefaultImageOptions?: components["schemas"]["ImageOption"][];
    };
    /** @description Class LibraryUpdateInfo. */
    LibraryUpdateInfo: {
      /** @description Gets or sets the folders added to. */
      FoldersAddedTo?: string[];
      /** @description Gets or sets the folders removed from. */
      FoldersRemovedFrom?: string[];
      /** @description Gets or sets the items added. */
      ItemsAdded?: string[];
      /** @description Gets or sets the items removed. */
      ItemsRemoved?: string[];
      /** @description Gets or sets the items updated. */
      ItemsUpdated?: string[];
      CollectionFolders?: string[];
      IsEmpty?: boolean;
    };
    ListingsProviderInfo: {
      Id?: string | null;
      Type?: string | null;
      Username?: string | null;
      Password?: string | null;
      ListingsId?: string | null;
      ZipCode?: string | null;
      Country?: string | null;
      Path?: string | null;
      EnabledTuners?: string[] | null;
      EnableAllTuners?: boolean;
      NewsCategories?: string[] | null;
      SportsCategories?: string[] | null;
      KidsCategories?: string[] | null;
      MovieCategories?: string[] | null;
      ChannelMappings?: components["schemas"]["NameValuePair"][] | null;
      MoviePrefix?: string | null;
      PreferredLanguage?: string | null;
      UserAgent?: string | null;
    };
    LiveStreamResponse: {
      MediaSource?: components["schemas"]["MediaSourceInfo"];
    };
    LiveTvInfo: {
      /** @description Gets or sets the services. */
      Services?: components["schemas"]["LiveTvServiceInfo"][];
      /** @description Gets or sets a value indicating whether this instance is enabled. */
      IsEnabled?: boolean;
      /** @description Gets or sets the enabled users. */
      EnabledUsers?: string[];
    };
    LiveTvOptions: {
      /** Format: int32 */
      GuideDays?: number | null;
      RecordingPath?: string | null;
      MovieRecordingPath?: string | null;
      SeriesRecordingPath?: string | null;
      EnableRecordingSubfolders?: boolean;
      EnableOriginalAudioWithEncodedRecordings?: boolean;
      TunerHosts?: components["schemas"]["TunerHostInfo"][] | null;
      ListingProviders?: components["schemas"]["ListingsProviderInfo"][] | null;
      /** Format: int32 */
      PrePaddingSeconds?: number;
      /** Format: int32 */
      PostPaddingSeconds?: number;
      MediaLocationsCreated?: string[] | null;
      RecordingPostProcessor?: string | null;
      RecordingPostProcessorArguments?: string | null;
      SaveRecordingNFO?: boolean;
      SaveRecordingImages?: boolean;
    };
    /** @description Class ServiceInfo. */
    LiveTvServiceInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the home page URL. */
      HomePageUrl?: string | null;
      /**
       * @description Gets or sets the status.
       * @enum {unknown}
       */
      Status?: "Ok" | "Unavailable";
      /** @description Gets or sets the status message. */
      StatusMessage?: string | null;
      /** @description Gets or sets the version. */
      Version?: string | null;
      /** @description Gets or sets a value indicating whether this instance has update available. */
      HasUpdateAvailable?: boolean;
      /** @description Gets or sets a value indicating whether this instance is visible. */
      IsVisible?: boolean;
      Tuners?: string[] | null;
    };
    /** @enum {string} */
    LiveTvServiceStatus: "Ok" | "Unavailable";
    LocalizationOption: {
      Name?: string | null;
      Value?: string | null;
    };
    /**
     * @description Enum LocationType.
     * @enum {string}
     */
    LocationType: "FileSystem" | "Remote" | "Virtual" | "Offline";
    LogFile: {
      /**
       * Format: date-time
       * @description Gets or sets the date created.
       */
      DateCreated?: string;
      /**
       * Format: date-time
       * @description Gets or sets the date modified.
       */
      DateModified?: string;
      /**
       * Format: int64
       * @description Gets or sets the size.
       */
      Size?: number;
      /** @description Gets or sets the name. */
      Name?: string;
    };
    /** @enum {string} */
    LogLevel: "Trace" | "Debug" | "Information" | "Warning" | "Error" | "Critical" | "None";
    /** @description LyricResponse model. */
    LyricDto: {
      /** @description Gets or sets Metadata for the lyrics. */
      Metadata?: components["schemas"]["LyricMetadata"];
      /** @description Gets or sets a collection of individual lyric lines. */
      Lyrics?: components["schemas"]["LyricLine"][];
    };
    /** @description Lyric model. */
    LyricLine: {
      /** @description Gets the text of this lyric line. */
      Text?: string;
      /**
       * Format: int64
       * @description Gets the start time in ticks.
       */
      Start?: number | null;
    };
    /** @description LyricMetadata model. */
    LyricMetadata: {
      /** @description Gets or sets the song artist. */
      Artist?: string | null;
      /** @description Gets or sets the album this song is on. */
      Album?: string | null;
      /** @description Gets or sets the title of the song. */
      Title?: string | null;
      /** @description Gets or sets the author of the lyric data. */
      Author?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the length of the song in ticks.
       */
      Length?: number | null;
      /** @description Gets or sets who the LRC file was created by. */
      By?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the lyric offset compared to audio in ticks.
       */
      Offset?: number | null;
      /** @description Gets or sets the software used to create the LRC file. */
      Creator?: string | null;
      /** @description Gets or sets the version of the creator used. */
      Version?: string | null;
      /** @description Gets or sets a value indicating whether this lyric is synced. */
      IsSynced?: boolean | null;
    };
    /** @description Class MediaAttachment. */
    MediaAttachment: {
      /** @description Gets or sets the codec. */
      Codec?: string | null;
      /** @description Gets or sets the codec tag. */
      CodecTag?: string | null;
      /** @description Gets or sets the comment. */
      Comment?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the index.
       */
      Index?: number;
      /** @description Gets or sets the filename. */
      FileName?: string | null;
      /** @description Gets or sets the MIME type. */
      MimeType?: string | null;
      /** @description Gets or sets the delivery URL. */
      DeliveryUrl?: string | null;
    };
    /** @description Media Path dto. */
    MediaPathDto: {
      /** @description Gets or sets the name of the library. */
      Name: string;
      /** @description Gets or sets the path to add. */
      Path?: string | null;
      /** @description Gets or sets the path info. */
      PathInfo?: components["schemas"]["MediaPathInfo"] | null;
    };
    MediaPathInfo: {
      Path?: string;
      NetworkPath?: string | null;
    };
    /** @enum {string} */
    MediaProtocol: "File" | "Http" | "Rtmp" | "Rtsp" | "Udp" | "Rtp" | "Ftp";
    MediaSourceInfo: {
      /** @enum {unknown} */
      Protocol?: "File" | "Http" | "Rtmp" | "Rtsp" | "Udp" | "Rtp" | "Ftp";
      Id?: string | null;
      Path?: string | null;
      EncoderPath?: string | null;
      /** @enum {unknown|null} */
      EncoderProtocol?: "File" | "Http" | "Rtmp" | "Rtsp" | "Udp" | "Rtp" | "Ftp" | null;
      /** @enum {unknown} */
      Type?: "Default" | "Grouping" | "Placeholder";
      Container?: string | null;
      /** Format: int64 */
      Size?: number | null;
      Name?: string | null;
      /**
       * @description Gets or sets a value indicating whether the media is remote.
       * Differentiate internet url vs local network.
       */
      IsRemote?: boolean;
      ETag?: string | null;
      /** Format: int64 */
      RunTimeTicks?: number | null;
      ReadAtNativeFramerate?: boolean;
      IgnoreDts?: boolean;
      IgnoreIndex?: boolean;
      GenPtsInput?: boolean;
      SupportsTranscoding?: boolean;
      SupportsDirectStream?: boolean;
      SupportsDirectPlay?: boolean;
      IsInfiniteStream?: boolean;
      RequiresOpening?: boolean;
      OpenToken?: string | null;
      RequiresClosing?: boolean;
      LiveStreamId?: string | null;
      /** Format: int32 */
      BufferMs?: number | null;
      RequiresLooping?: boolean;
      SupportsProbing?: boolean;
      /** @enum {unknown|null} */
      VideoType?: "VideoFile" | "Iso" | "Dvd" | "BluRay" | null;
      /** @enum {unknown|null} */
      IsoType?: "Dvd" | "BluRay" | null;
      /** @enum {unknown|null} */
      Video3DFormat?: "HalfSideBySide" | "FullSideBySide" | "FullTopAndBottom" | "HalfTopAndBottom" | "MVC" | null;
      MediaStreams?: components["schemas"]["MediaStream"][] | null;
      MediaAttachments?: components["schemas"]["MediaAttachment"][] | null;
      Formats?: string[] | null;
      /** Format: int32 */
      Bitrate?: number | null;
      /** @enum {unknown|null} */
      Timestamp?: "None" | "Zero" | "Valid" | null;
      RequiredHttpHeaders?: ({
        [key: string]: string | null;
      }) | null;
      TranscodingUrl?: string | null;
      /**
       * @description Media streaming protocol.
       * Lowercase for backwards compatibility.
       * @enum {unknown}
       */
      TranscodingSubProtocol?: "http" | "hls";
      TranscodingContainer?: string | null;
      /** Format: int32 */
      AnalyzeDurationMs?: number | null;
      /** Format: int32 */
      DefaultAudioStreamIndex?: number | null;
      /** Format: int32 */
      DefaultSubtitleStreamIndex?: number | null;
    };
    /** @enum {string} */
    MediaSourceType: "Default" | "Grouping" | "Placeholder";
    /** @description Class MediaStream. */
    MediaStream: {
      /** @description Gets or sets the codec. */
      Codec?: string | null;
      /** @description Gets or sets the codec tag. */
      CodecTag?: string | null;
      /** @description Gets or sets the language. */
      Language?: string | null;
      /** @description Gets or sets the color range. */
      ColorRange?: string | null;
      /** @description Gets or sets the color space. */
      ColorSpace?: string | null;
      /** @description Gets or sets the color transfer. */
      ColorTransfer?: string | null;
      /** @description Gets or sets the color primaries. */
      ColorPrimaries?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision version major.
       */
      DvVersionMajor?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision version minor.
       */
      DvVersionMinor?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision profile.
       */
      DvProfile?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision level.
       */
      DvLevel?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision rpu present flag.
       */
      RpuPresentFlag?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision el present flag.
       */
      ElPresentFlag?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision bl present flag.
       */
      BlPresentFlag?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the Dolby Vision bl signal compatibility id.
       */
      DvBlSignalCompatibilityId?: number | null;
      /** @description Gets or sets the comment. */
      Comment?: string | null;
      /** @description Gets or sets the time base. */
      TimeBase?: string | null;
      /** @description Gets or sets the codec time base. */
      CodecTimeBase?: string | null;
      /** @description Gets or sets the title. */
      Title?: string | null;
      /**
       * @description Gets the video range.
       * @enum {unknown}
       */
      VideoRange?: "Unknown" | "SDR" | "HDR";
      /**
       * @description Gets the video range type.
       * @enum {unknown}
       */
      VideoRangeType?: "Unknown" | "SDR" | "HDR10" | "HLG" | "DOVI" | "DOVIWithHDR10" | "DOVIWithHLG" | "DOVIWithSDR" | "HDR10Plus";
      /** @description Gets the video dovi title. */
      VideoDoViTitle?: string | null;
      /**
       * @description Gets the audio spatial format.
       * @default None
       * @enum {unknown}
       */
      AudioSpatialFormat?: "None" | "DolbyAtmos" | "DTSX";
      LocalizedUndefined?: string | null;
      LocalizedDefault?: string | null;
      LocalizedForced?: string | null;
      LocalizedExternal?: string | null;
      LocalizedHearingImpaired?: string | null;
      DisplayTitle?: string | null;
      NalLengthSize?: string | null;
      /** @description Gets or sets a value indicating whether this instance is interlaced. */
      IsInterlaced?: boolean;
      IsAVC?: boolean | null;
      /** @description Gets or sets the channel layout. */
      ChannelLayout?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the bit rate.
       */
      BitRate?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the bit depth.
       */
      BitDepth?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the reference frames.
       */
      RefFrames?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the length of the packet.
       */
      PacketLength?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the channels.
       */
      Channels?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the sample rate.
       */
      SampleRate?: number | null;
      /** @description Gets or sets a value indicating whether this instance is default. */
      IsDefault?: boolean;
      /** @description Gets or sets a value indicating whether this instance is forced. */
      IsForced?: boolean;
      /** @description Gets or sets a value indicating whether this instance is for the hearing impaired. */
      IsHearingImpaired?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the height.
       */
      Height?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the width.
       */
      Width?: number | null;
      /**
       * Format: float
       * @description Gets or sets the average frame rate.
       */
      AverageFrameRate?: number | null;
      /**
       * Format: float
       * @description Gets or sets the real frame rate.
       */
      RealFrameRate?: number | null;
      /** @description Gets or sets the profile. */
      Profile?: string | null;
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "Audio" | "Video" | "Subtitle" | "EmbeddedImage" | "Data" | "Lyric";
      /** @description Gets or sets the aspect ratio. */
      AspectRatio?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the index.
       */
      Index?: number;
      /**
       * Format: int32
       * @description Gets or sets the score.
       */
      Score?: number | null;
      /** @description Gets or sets a value indicating whether this instance is external. */
      IsExternal?: boolean;
      /**
       * @description Gets or sets the method.
       * @enum {unknown|null}
       */
      DeliveryMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop" | null;
      /** @description Gets or sets the delivery URL. */
      DeliveryUrl?: string | null;
      /** @description Gets or sets a value indicating whether this instance is external URL. */
      IsExternalUrl?: boolean | null;
      IsTextSubtitleStream?: boolean;
      /** @description Gets or sets a value indicating whether [supports external stream]. */
      SupportsExternalStream?: boolean;
      /** @description Gets or sets the filename. */
      Path?: string | null;
      /** @description Gets or sets the pixel format. */
      PixelFormat?: string | null;
      /**
       * Format: double
       * @description Gets or sets the level.
       */
      Level?: number | null;
      /** @description Gets or sets whether this instance is anamorphic. */
      IsAnamorphic?: boolean | null;
    };
    /**
     * @description Media streaming protocol.
     * Lowercase for backwards compatibility.
     * @enum {string}
     */
    MediaStreamProtocol: "http" | "hls";
    /**
     * @description Enum MediaStreamType.
     * @enum {string}
     */
    MediaStreamType: "Audio" | "Video" | "Subtitle" | "EmbeddedImage" | "Data" | "Lyric";
    /**
     * @description Media types.
     * @enum {string}
     */
    MediaType: "Unknown" | "Video" | "Audio" | "Photo" | "Book";
    /** @description Media Update Info Dto. */
    MediaUpdateInfoDto: {
      /** @description Gets or sets the list of updates. */
      Updates?: components["schemas"]["MediaUpdateInfoPathDto"][];
    };
    /** @description The media update info path. */
    MediaUpdateInfoPathDto: {
      /** @description Gets or sets media path. */
      Path?: string | null;
      /**
       * @description Gets or sets media update type.
       * Created, Modified, Deleted.
       */
      UpdateType?: string | null;
    };
    MediaUrl: {
      Url?: string | null;
      Name?: string | null;
    };
    MessageCommand: {
      Header?: string | null;
      Text: string;
      /** Format: int64 */
      TimeoutMs?: number | null;
    };
    MetadataConfiguration: {
      UseFileCreationTimeForDateAdded?: boolean;
    };
    MetadataEditorInfo: {
      ParentalRatingOptions?: components["schemas"]["ParentalRating"][];
      Countries?: components["schemas"]["CountryInfo"][];
      Cultures?: components["schemas"]["CultureDto"][];
      ExternalIdInfos?: components["schemas"]["ExternalIdInfo"][];
      /** @enum {unknown|null} */
      ContentType?: "unknown" | "movies" | "tvshows" | "music" | "musicvideos" | "trailers" | "homevideos" | "boxsets" | "books" | "photos" | "livetv" | "playlists" | "folders" | null;
      ContentTypeOptions?: components["schemas"]["NameValuePair"][];
    };
    /**
     * @description Enum MetadataFields.
     * @enum {string}
     */
    MetadataField: "Cast" | "Genres" | "ProductionLocations" | "Studios" | "Tags" | "Name" | "Overview" | "Runtime" | "OfficialRating";
    /** @description Class MetadataOptions. */
    MetadataOptions: {
      ItemType?: string | null;
      DisabledMetadataSavers?: string[] | null;
      LocalMetadataReaderOrder?: string[] | null;
      DisabledMetadataFetchers?: string[] | null;
      MetadataFetcherOrder?: string[] | null;
      DisabledImageFetchers?: string[] | null;
      ImageFetcherOrder?: string[] | null;
    };
    /** @enum {string} */
    MetadataRefreshMode: "None" | "ValidationOnly" | "Default" | "FullRefresh";
    /** @description Class MovePlaylistItemRequestDto. */
    MovePlaylistItemRequestDto: {
      /**
       * Format: uuid
       * @description Gets or sets the playlist identifier of the item.
       */
      PlaylistItemId?: string;
      /**
       * Format: int32
       * @description Gets or sets the new position.
       */
      NewIndex?: number;
    };
    MovieInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
    };
    MovieInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["MovieInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    MusicVideoInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
      Artists?: string[] | null;
    };
    MusicVideoInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["MusicVideoInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    NameGuidPair: {
      Name?: string | null;
      /** Format: uuid */
      Id?: string;
    };
    NameIdPair: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the identifier. */
      Id?: string | null;
    };
    NameValuePair: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the value. */
      Value?: string | null;
    };
    /** @description Defines the MediaBrowser.Common.Net.NetworkConfiguration. */
    NetworkConfiguration: {
      /** @description Gets or sets a value used to specify the URL prefix that your Jellyfin instance can be accessed at. */
      BaseUrl?: string;
      /** @description Gets or sets a value indicating whether to use HTTPS. */
      EnableHttps?: boolean;
      /** @description Gets or sets a value indicating whether the server should force connections over HTTPS. */
      RequireHttps?: boolean;
      /** @description Gets or sets the filesystem path of an X.509 certificate to use for SSL. */
      CertificatePath?: string;
      /** @description Gets or sets the password required to access the X.509 certificate data in the file specified by MediaBrowser.Common.Net.NetworkConfiguration.CertificatePath. */
      CertificatePassword?: string;
      /**
       * Format: int32
       * @description Gets or sets the internal HTTP server port.
       */
      InternalHttpPort?: number;
      /**
       * Format: int32
       * @description Gets or sets the internal HTTPS server port.
       */
      InternalHttpsPort?: number;
      /**
       * Format: int32
       * @description Gets or sets the public HTTP port.
       */
      PublicHttpPort?: number;
      /**
       * Format: int32
       * @description Gets or sets the public HTTPS port.
       */
      PublicHttpsPort?: number;
      /** @description Gets or sets a value indicating whether Autodiscovery is enabled. */
      AutoDiscovery?: boolean;
      /** @description Gets or sets a value indicating whether to enable automatic port forwarding. */
      EnableUPnP?: boolean;
      /** @description Gets or sets a value indicating whether IPv6 is enabled. */
      EnableIPv4?: boolean;
      /** @description Gets or sets a value indicating whether IPv6 is enabled. */
      EnableIPv6?: boolean;
      /** @description Gets or sets a value indicating whether access from outside of the LAN is permitted. */
      EnableRemoteAccess?: boolean;
      /** @description Gets or sets the subnets that are deemed to make up the LAN. */
      LocalNetworkSubnets?: string[];
      /** @description Gets or sets the interface addresses which Jellyfin will bind to. If empty, all interfaces will be used. */
      LocalNetworkAddresses?: string[];
      /** @description Gets or sets the known proxies. */
      KnownProxies?: string[];
      /** @description Gets or sets a value indicating whether address names that match MediaBrowser.Common.Net.NetworkConfiguration.VirtualInterfaceNames should be ignored for the purposes of binding. */
      IgnoreVirtualInterfaces?: boolean;
      /** @description Gets or sets a value indicating the interface name prefixes that should be ignored. The list can be comma separated and values are case-insensitive. <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.IgnoreVirtualInterfaces" />. */
      VirtualInterfaceNames?: string[];
      /** @description Gets or sets a value indicating whether the published server uri is based on information in HTTP requests. */
      EnablePublishedServerUriByRequest?: boolean;
      /**
       * @description Gets or sets the PublishedServerUriBySubnet
       * Gets or sets PublishedServerUri to advertise for specific subnets.
       */
      PublishedServerUriBySubnet?: string[];
      /** @description Gets or sets the filter for remote IP connectivity. Used in conjunction with <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.IsRemoteIPFilterBlacklist" />. */
      RemoteIPFilter?: string[];
      /** @description Gets or sets a value indicating whether <seealso cref="P:MediaBrowser.Common.Net.NetworkConfiguration.RemoteIPFilter" /> contains a blacklist or a whitelist. Default is a whitelist. */
      IsRemoteIPFilterBlacklist?: boolean;
    };
    /** @description Class NewGroupRequestDto. */
    NewGroupRequestDto: {
      /** @description Gets or sets the group name. */
      GroupName?: string;
    };
    /** @description Class NextItemRequestDto. */
    NextItemRequestDto: {
      /**
       * Format: uuid
       * @description Gets or sets the playing item identifier.
       */
      PlaylistItemId?: string;
    };
    /** @description Open live stream dto. */
    OpenLiveStreamDto: {
      /** @description Gets or sets the open token. */
      OpenToken?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the user id.
       */
      UserId?: string | null;
      /** @description Gets or sets the play session id. */
      PlaySessionId?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the max streaming bitrate.
       */
      MaxStreamingBitrate?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the start time in ticks.
       */
      StartTimeTicks?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the audio stream index.
       */
      AudioStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the subtitle stream index.
       */
      SubtitleStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the max audio channels.
       */
      MaxAudioChannels?: number | null;
      /**
       * Format: uuid
       * @description Gets or sets the item id.
       */
      ItemId?: string | null;
      /** @description Gets or sets a value indicating whether to enable direct play. */
      EnableDirectPlay?: boolean | null;
      /** @description Gets or sets a value indicating whether to enale direct stream. */
      EnableDirectStream?: boolean | null;
      /**
       * @description A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
       * <br />
       * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
       * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
       * the device is able to direct play (without transcoding or remuxing),
       * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
       */
      DeviceProfile?: components["schemas"]["DeviceProfile"] | null;
      /** @description Gets or sets the device play protocols. */
      DirectPlayProtocols?: components["schemas"]["MediaProtocol"][];
    };
    /** @description Keep alive websocket messages. */
    OutboundKeepAliveMessage: {
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default KeepAlive
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Represents the list of possible outbound websocket types */
    OutboundWebSocketMessage: components["schemas"]["ActivityLogEntryMessage"] | components["schemas"]["ForceKeepAliveMessage"] | components["schemas"]["GeneralCommandMessage"] | components["schemas"]["LibraryChangedMessage"] | components["schemas"]["OutboundKeepAliveMessage"] | components["schemas"]["PlayMessage"] | components["schemas"]["PlaystateMessage"] | components["schemas"]["PluginInstallationCancelledMessage"] | components["schemas"]["PluginInstallationCompletedMessage"] | components["schemas"]["PluginInstallationFailedMessage"] | components["schemas"]["PluginInstallingMessage"] | components["schemas"]["PluginUninstalledMessage"] | components["schemas"]["RefreshProgressMessage"] | components["schemas"]["RestartRequiredMessage"] | components["schemas"]["ScheduledTaskEndedMessage"] | components["schemas"]["ScheduledTasksInfoMessage"] | components["schemas"]["SeriesTimerCancelledMessage"] | components["schemas"]["SeriesTimerCreatedMessage"] | components["schemas"]["ServerRestartingMessage"] | components["schemas"]["ServerShuttingDownMessage"] | components["schemas"]["SessionsMessage"] | components["schemas"]["SyncPlayCommandMessage"] | components["schemas"]["SyncPlayGroupUpdateCommandMessage"] | components["schemas"]["TimerCancelledMessage"] | components["schemas"]["TimerCreatedMessage"] | components["schemas"]["UserDataChangedMessage"] | components["schemas"]["UserDeletedMessage"] | components["schemas"]["UserUpdatedMessage"];
    /** @description Class PackageInfo. */
    PackageInfo: {
      /** @description Gets or sets the name. */
      name?: string;
      /** @description Gets or sets a long description of the plugin containing features or helpful explanations. */
      description?: string;
      /** @description Gets or sets a short overview of what the plugin does. */
      overview?: string;
      /** @description Gets or sets the owner. */
      owner?: string;
      /** @description Gets or sets the category. */
      category?: string;
      /**
       * Format: uuid
       * @description Gets or sets the guid of the assembly associated with this plugin.
       * This is used to identify the proper item for automatic updates.
       */
      guid?: string;
      /** @description Gets or sets the versions. */
      versions?: components["schemas"]["VersionInfo"][];
      /** @description Gets or sets the image url for the package. */
      imageUrl?: string | null;
    };
    /** @description Class ParentalRating. */
    ParentalRating: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the value.
       */
      Value?: number | null;
    };
    /** @description Defines the MediaBrowser.Model.Configuration.PathSubstitution. */
    PathSubstitution: {
      /** @description Gets or sets the value to substitute. */
      From?: string;
      /** @description Gets or sets the value to substitution with. */
      To?: string;
    };
    /**
     * @description The person kind.
     * @enum {string}
     */
    PersonKind: "Unknown" | "Actor" | "Director" | "Composer" | "Writer" | "GuestStar" | "Producer" | "Conductor" | "Lyricist" | "Arranger" | "Engineer" | "Mixer" | "Remixer" | "Creator" | "Artist" | "AlbumArtist" | "Author" | "Illustrator" | "Penciller" | "Inker" | "Colorist" | "Letterer" | "CoverArtist" | "Editor" | "Translator";
    PersonLookupInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
    };
    PersonLookupInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["PersonLookupInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    /** @description Class PingRequestDto. */
    PingRequestDto: {
      /**
       * Format: int64
       * @description Gets or sets the ping time.
       */
      Ping?: number;
    };
    PinRedeemResult: {
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Users.PinRedeemResult is success. */
      Success?: boolean;
      /** @description Gets or sets the users reset. */
      UsersReset?: string[];
    };
    /** @enum {string} */
    PlayAccess: "Full" | "None";
    /** @enum {string} */
    PlaybackErrorCode: "NotAllowed" | "NoCompatibleStream" | "RateLimitExceeded";
    /** @description Plabyback info dto. */
    PlaybackInfoDto: {
      /**
       * Format: uuid
       * @description Gets or sets the playback userId.
       */
      UserId?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the max streaming bitrate.
       */
      MaxStreamingBitrate?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the start time in ticks.
       */
      StartTimeTicks?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the audio stream index.
       */
      AudioStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the subtitle stream index.
       */
      SubtitleStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the max audio channels.
       */
      MaxAudioChannels?: number | null;
      /** @description Gets or sets the media source id. */
      MediaSourceId?: string | null;
      /** @description Gets or sets the live stream id. */
      LiveStreamId?: string | null;
      /**
       * @description A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
       * <br />
       * Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
       * <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
       * the device is able to direct play (without transcoding or remuxing),
       * as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
       */
      DeviceProfile?: components["schemas"]["DeviceProfile"] | null;
      /** @description Gets or sets a value indicating whether to enable direct play. */
      EnableDirectPlay?: boolean | null;
      /** @description Gets or sets a value indicating whether to enable direct stream. */
      EnableDirectStream?: boolean | null;
      /** @description Gets or sets a value indicating whether to enable transcoding. */
      EnableTranscoding?: boolean | null;
      /** @description Gets or sets a value indicating whether to enable video stream copy. */
      AllowVideoStreamCopy?: boolean | null;
      /** @description Gets or sets a value indicating whether to allow audio stream copy. */
      AllowAudioStreamCopy?: boolean | null;
      /** @description Gets or sets a value indicating whether to auto open the live stream. */
      AutoOpenLiveStream?: boolean | null;
    };
    /** @description Class PlaybackInfoResponse. */
    PlaybackInfoResponse: {
      /** @description Gets or sets the media sources. */
      MediaSources?: components["schemas"]["MediaSourceInfo"][];
      /** @description Gets or sets the play session identifier. */
      PlaySessionId?: string | null;
      /**
       * @description Gets or sets the error code.
       * @enum {unknown|null}
       */
      ErrorCode?: "NotAllowed" | "NoCompatibleStream" | "RateLimitExceeded" | null;
    };
    /**
     * @description Enum PlaybackOrder.
     * @enum {string}
     */
    PlaybackOrder: "Default" | "Shuffle";
    /** @description Class PlaybackProgressInfo. */
    PlaybackProgressInfo: {
      /** @description Gets or sets a value indicating whether this instance can seek. */
      CanSeek?: boolean;
      /** @description Gets or sets the item. */
      Item?: components["schemas"]["BaseItemDto"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the item identifier.
       */
      ItemId?: string;
      /** @description Gets or sets the session id. */
      SessionId?: string | null;
      /** @description Gets or sets the media version identifier. */
      MediaSourceId?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the audio stream.
       */
      AudioStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the subtitle stream.
       */
      SubtitleStreamIndex?: number | null;
      /** @description Gets or sets a value indicating whether this instance is paused. */
      IsPaused?: boolean;
      /** @description Gets or sets a value indicating whether this instance is muted. */
      IsMuted?: boolean;
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number | null;
      /** Format: int64 */
      PlaybackStartTimeTicks?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the volume level.
       */
      VolumeLevel?: number | null;
      /** Format: int32 */
      Brightness?: number | null;
      AspectRatio?: string | null;
      /**
       * @description Gets or sets the play method.
       * @enum {unknown}
       */
      PlayMethod?: "Transcode" | "DirectStream" | "DirectPlay";
      /** @description Gets or sets the live stream identifier. */
      LiveStreamId?: string | null;
      /** @description Gets or sets the play session identifier. */
      PlaySessionId?: string | null;
      /**
       * @description Gets or sets the repeat mode.
       * @enum {unknown}
       */
      RepeatMode?: "RepeatNone" | "RepeatAll" | "RepeatOne";
      /**
       * @description Gets or sets the playback order.
       * @enum {unknown}
       */
      PlaybackOrder?: "Default" | "Shuffle";
      NowPlayingQueue?: components["schemas"]["QueueItem"][] | null;
      PlaylistItemId?: string | null;
    };
    /**
     * @description Enum PlaybackRequestType.
     * @enum {string}
     */
    PlaybackRequestType: "Play" | "SetPlaylistItem" | "RemoveFromPlaylist" | "MovePlaylistItem" | "Queue" | "Unpause" | "Pause" | "Stop" | "Seek" | "Buffer" | "Ready" | "NextItem" | "PreviousItem" | "SetRepeatMode" | "SetShuffleMode" | "Ping" | "IgnoreWait";
    /** @description Class PlaybackStartInfo. */
    PlaybackStartInfo: {
      /** @description Gets or sets a value indicating whether this instance can seek. */
      CanSeek?: boolean;
      /** @description Gets or sets the item. */
      Item?: components["schemas"]["BaseItemDto"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the item identifier.
       */
      ItemId?: string;
      /** @description Gets or sets the session id. */
      SessionId?: string | null;
      /** @description Gets or sets the media version identifier. */
      MediaSourceId?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the audio stream.
       */
      AudioStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the subtitle stream.
       */
      SubtitleStreamIndex?: number | null;
      /** @description Gets or sets a value indicating whether this instance is paused. */
      IsPaused?: boolean;
      /** @description Gets or sets a value indicating whether this instance is muted. */
      IsMuted?: boolean;
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number | null;
      /** Format: int64 */
      PlaybackStartTimeTicks?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the volume level.
       */
      VolumeLevel?: number | null;
      /** Format: int32 */
      Brightness?: number | null;
      AspectRatio?: string | null;
      /**
       * @description Gets or sets the play method.
       * @enum {unknown}
       */
      PlayMethod?: "Transcode" | "DirectStream" | "DirectPlay";
      /** @description Gets or sets the live stream identifier. */
      LiveStreamId?: string | null;
      /** @description Gets or sets the play session identifier. */
      PlaySessionId?: string | null;
      /**
       * @description Gets or sets the repeat mode.
       * @enum {unknown}
       */
      RepeatMode?: "RepeatNone" | "RepeatAll" | "RepeatOne";
      /**
       * @description Gets or sets the playback order.
       * @enum {unknown}
       */
      PlaybackOrder?: "Default" | "Shuffle";
      NowPlayingQueue?: components["schemas"]["QueueItem"][] | null;
      PlaylistItemId?: string | null;
    };
    /** @description Class PlaybackStopInfo. */
    PlaybackStopInfo: {
      /** @description Gets or sets the item. */
      Item?: components["schemas"]["BaseItemDto"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the item identifier.
       */
      ItemId?: string;
      /** @description Gets or sets the session id. */
      SessionId?: string | null;
      /** @description Gets or sets the media version identifier. */
      MediaSourceId?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number | null;
      /** @description Gets or sets the live stream identifier. */
      LiveStreamId?: string | null;
      /** @description Gets or sets the play session identifier. */
      PlaySessionId?: string | null;
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Session.PlaybackStopInfo is failed. */
      Failed?: boolean;
      NextMediaType?: string | null;
      PlaylistItemId?: string | null;
      NowPlayingQueue?: components["schemas"]["QueueItem"][] | null;
    };
    /**
     * @description Enum PlayCommand.
     * @enum {string}
     */
    PlayCommand: "PlayNow" | "PlayNext" | "PlayLast" | "PlayInstantMix" | "PlayShuffle";
    PlayerStateInfo: {
      /**
       * Format: int64
       * @description Gets or sets the now playing position ticks.
       */
      PositionTicks?: number | null;
      /** @description Gets or sets a value indicating whether this instance can seek. */
      CanSeek?: boolean;
      /** @description Gets or sets a value indicating whether this instance is paused. */
      IsPaused?: boolean;
      /** @description Gets or sets a value indicating whether this instance is muted. */
      IsMuted?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the volume level.
       */
      VolumeLevel?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the now playing audio stream.
       */
      AudioStreamIndex?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the index of the now playing subtitle stream.
       */
      SubtitleStreamIndex?: number | null;
      /** @description Gets or sets the now playing media version identifier. */
      MediaSourceId?: string | null;
      /**
       * @description Gets or sets the play method.
       * @enum {unknown|null}
       */
      PlayMethod?: "Transcode" | "DirectStream" | "DirectPlay" | null;
      /**
       * @description Gets or sets the repeat mode.
       * @enum {unknown}
       */
      RepeatMode?: "RepeatNone" | "RepeatAll" | "RepeatOne";
      /**
       * @description Gets or sets the playback order.
       * @enum {unknown}
       */
      PlaybackOrder?: "Default" | "Shuffle";
      /** @description Gets or sets the now playing live stream identifier. */
      LiveStreamId?: string | null;
    };
    PlaylistCreationResult: {
      Id?: string;
    };
    /** @description Class to hold data on user permissions for playlists. */
    PlaylistUserPermissions: {
      /**
       * Format: uuid
       * @description Gets or sets the user id.
       */
      UserId?: string;
      /** @description Gets or sets a value indicating whether the user has edit permissions. */
      CanEdit?: boolean;
    };
    /** @description Play command websocket message. */
    PlayMessage: {
      /** @description Class PlayRequest. */
      Data?: components["schemas"]["PlayRequest"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default Play
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @enum {string} */
    PlayMethod: "Transcode" | "DirectStream" | "DirectPlay";
    /** @description Class PlayQueueUpdate. */
    PlayQueueUpdate: {
      /**
       * @description Gets the request type that originated this update.
       * @enum {unknown}
       */
      Reason?: "NewPlaylist" | "SetCurrentItem" | "RemoveItems" | "MoveItem" | "Queue" | "QueueNext" | "NextItem" | "PreviousItem" | "RepeatMode" | "ShuffleMode";
      /**
       * Format: date-time
       * @description Gets the UTC time of the last change to the playing queue.
       */
      LastUpdate?: string;
      /** @description Gets the playlist. */
      Playlist?: components["schemas"]["SyncPlayQueueItem"][];
      /**
       * Format: int32
       * @description Gets the playing item index in the playlist.
       */
      PlayingItemIndex?: number;
      /**
       * Format: int64
       * @description Gets the start position ticks.
       */
      StartPositionTicks?: number;
      /** @description Gets a value indicating whether the current item is playing. */
      IsPlaying?: boolean;
      /**
       * @description Gets the shuffle mode.
       * @enum {unknown}
       */
      ShuffleMode?: "Sorted" | "Shuffle";
      /**
       * @description Gets the repeat mode.
       * @enum {unknown}
       */
      RepeatMode?: "RepeatOne" | "RepeatAll" | "RepeatNone";
    };
    /** @description Class GroupUpdate. */
    PlayQueueUpdateGroupUpdate: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * @description Gets the update type.
       * @enum {unknown}
       */
      Type?: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
      /** @description Gets the update data. */
      Data?: components["schemas"]["PlayQueueUpdate"];
    };
    /**
     * @description Enum PlayQueueUpdateReason.
     * @enum {string}
     */
    PlayQueueUpdateReason: "NewPlaylist" | "SetCurrentItem" | "RemoveItems" | "MoveItem" | "Queue" | "QueueNext" | "NextItem" | "PreviousItem" | "RepeatMode" | "ShuffleMode";
    /** @description Class PlayRequest. */
    PlayRequest: {
      /** @description Gets or sets the item ids. */
      ItemIds?: string[] | null;
      /**
       * Format: int64
       * @description Gets or sets the start position ticks that the first item should be played at.
       */
      StartPositionTicks?: number | null;
      /**
       * @description Gets or sets the play command.
       * @enum {unknown}
       */
      PlayCommand?: "PlayNow" | "PlayNext" | "PlayLast" | "PlayInstantMix" | "PlayShuffle";
      /**
       * Format: uuid
       * @description Gets or sets the controlling user identifier.
       */
      ControllingUserId?: string;
      /** Format: int32 */
      SubtitleStreamIndex?: number | null;
      /** Format: int32 */
      AudioStreamIndex?: number | null;
      MediaSourceId?: string | null;
      /** Format: int32 */
      StartIndex?: number | null;
    };
    /** @description Class PlayRequestDto. */
    PlayRequestDto: {
      /** @description Gets or sets the playing queue. */
      PlayingQueue?: string[];
      /**
       * Format: int32
       * @description Gets or sets the position of the playing item in the queue.
       */
      PlayingItemPosition?: number;
      /**
       * Format: int64
       * @description Gets or sets the start position ticks.
       */
      StartPositionTicks?: number;
    };
    /**
     * @description Enum PlaystateCommand.
     * @enum {string}
     */
    PlaystateCommand: "Stop" | "Pause" | "Unpause" | "NextTrack" | "PreviousTrack" | "Seek" | "Rewind" | "FastForward" | "PlayPause";
    /** @description Playstate message. */
    PlaystateMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["PlaystateRequest"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default Playstate
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    PlaystateRequest: {
      /**
       * @description Enum PlaystateCommand.
       * @enum {unknown}
       */
      Command?: "Stop" | "Pause" | "Unpause" | "NextTrack" | "PreviousTrack" | "Seek" | "Rewind" | "FastForward" | "PlayPause";
      /** Format: int64 */
      SeekPositionTicks?: number | null;
      /** @description Gets or sets the controlling user identifier. */
      ControllingUserId?: string | null;
    };
    /** @description This is a serializable stub class that is used by the api to provide information about installed plugins. */
    PluginInfo: {
      /** @description Gets or sets the name. */
      Name?: string;
      /** @description Gets or sets the version. */
      Version?: string;
      /** @description Gets or sets the name of the configuration file. */
      ConfigurationFileName?: string | null;
      /** @description Gets or sets the description. */
      Description?: string;
      /**
       * Format: uuid
       * @description Gets or sets the unique id.
       */
      Id?: string;
      /** @description Gets or sets a value indicating whether the plugin can be uninstalled. */
      CanUninstall?: boolean;
      /** @description Gets or sets a value indicating whether this plugin has a valid image. */
      HasImage?: boolean;
      /**
       * @description Gets or sets a value indicating the status of the plugin.
       * @enum {unknown}
       */
      Status?: "Active" | "Restart" | "Deleted" | "Superceded" | "Malfunctioned" | "NotSupported" | "Disabled";
    };
    /** @description Plugin installation cancelled message. */
    PluginInstallationCancelledMessage: {
      /** @description Class InstallationInfo. */
      Data?: components["schemas"]["InstallationInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default PackageInstallationCancelled
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Plugin installation completed message. */
    PluginInstallationCompletedMessage: {
      /** @description Class InstallationInfo. */
      Data?: components["schemas"]["InstallationInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default PackageInstallationCompleted
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Plugin installation failed message. */
    PluginInstallationFailedMessage: {
      /** @description Class InstallationInfo. */
      Data?: components["schemas"]["InstallationInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default PackageInstallationFailed
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Package installing message. */
    PluginInstallingMessage: {
      /** @description Class InstallationInfo. */
      Data?: components["schemas"]["InstallationInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default PackageInstalling
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /**
     * @description Plugin load status.
     * @enum {string}
     */
    PluginStatus: "Active" | "Restart" | "Deleted" | "Superceded" | "Malfunctioned" | "NotSupported" | "Disabled";
    /** @description Plugin uninstalled message. */
    PluginUninstalledMessage: {
      /** @description This is a serializable stub class that is used by the api to provide information about installed plugins. */
      Data?: components["schemas"]["PluginInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default PackageUninstalled
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class PreviousItemRequestDto. */
    PreviousItemRequestDto: {
      /**
       * Format: uuid
       * @description Gets or sets the playing item identifier.
       */
      PlaylistItemId?: string;
    };
    ProblemDetails: {
      type?: string | null;
      title?: string | null;
      /** Format: int32 */
      status?: number | null;
      detail?: string | null;
      instance?: string | null;
      [key: string]: unknown;
    };
    /** @enum {string} */
    ProcessPriorityClass: "Normal" | "Idle" | "High" | "RealTime" | "BelowNormal" | "AboveNormal";
    ProfileCondition: {
      /** @enum {unknown} */
      Condition?: "Equals" | "NotEquals" | "LessThanEqual" | "GreaterThanEqual" | "EqualsAny";
      /** @enum {unknown} */
      Property?: "AudioChannels" | "AudioBitrate" | "AudioProfile" | "Width" | "Height" | "Has64BitOffsets" | "PacketLength" | "VideoBitDepth" | "VideoBitrate" | "VideoFramerate" | "VideoLevel" | "VideoProfile" | "VideoTimestamp" | "IsAnamorphic" | "RefFrames" | "NumAudioStreams" | "NumVideoStreams" | "IsSecondaryAudio" | "VideoCodecTag" | "IsAvc" | "IsInterlaced" | "AudioSampleRate" | "AudioBitDepth" | "VideoRangeType";
      Value?: string | null;
      IsRequired?: boolean;
    };
    /** @enum {string} */
    ProfileConditionType: "Equals" | "NotEquals" | "LessThanEqual" | "GreaterThanEqual" | "EqualsAny";
    /** @enum {string} */
    ProfileConditionValue: "AudioChannels" | "AudioBitrate" | "AudioProfile" | "Width" | "Height" | "Has64BitOffsets" | "PacketLength" | "VideoBitDepth" | "VideoBitrate" | "VideoFramerate" | "VideoLevel" | "VideoProfile" | "VideoTimestamp" | "IsAnamorphic" | "RefFrames" | "NumAudioStreams" | "NumVideoStreams" | "IsSecondaryAudio" | "VideoCodecTag" | "IsAvc" | "IsInterlaced" | "AudioSampleRate" | "AudioBitDepth" | "VideoRangeType";
    /** @enum {string} */
    ProgramAudio: "Mono" | "Stereo" | "Dolby" | "DolbyDigital" | "Thx" | "Atmos";
    PublicSystemInfo: {
      /** @description Gets or sets the local address. */
      LocalAddress?: string | null;
      /** @description Gets or sets the name of the server. */
      ServerName?: string | null;
      /** @description Gets or sets the server version. */
      Version?: string | null;
      /** @description Gets or sets the product name. This is the AssemblyProduct name. */
      ProductName?: string | null;
      /**
       * @deprecated
       * @description Gets or sets the operating system.
       */
      OperatingSystem?: string | null;
      /** @description Gets or sets the id. */
      Id?: string | null;
      /** @description Gets or sets a value indicating whether the startup wizard is completed. */
      StartupWizardCompleted?: boolean | null;
    };
    QueryFilters: {
      Genres?: components["schemas"]["NameGuidPair"][] | null;
      Tags?: string[] | null;
    };
    QueryFiltersLegacy: {
      Genres?: string[] | null;
      Tags?: string[] | null;
      OfficialRatings?: string[] | null;
      Years?: number[] | null;
    };
    QueueItem: {
      /** Format: uuid */
      Id?: string;
      PlaylistItemId?: string | null;
    };
    /** @description Class QueueRequestDto. */
    QueueRequestDto: {
      /** @description Gets or sets the items to enqueue. */
      ItemIds?: string[];
      /**
       * @description Enum GroupQueueMode.
       * @enum {unknown}
       */
      Mode?: "Queue" | "QueueNext";
    };
    /** @description The quick connect request body. */
    QuickConnectDto: {
      /** @description Gets or sets the quick connect secret. */
      Secret: string;
    };
    /** @description Stores the state of an quick connect request. */
    QuickConnectResult: {
      /** @description Gets or sets a value indicating whether this request is authorized. */
      Authenticated?: boolean;
      /** @description Gets the secret value used to uniquely identify this request. Can be used to retrieve authentication information. */
      Secret?: string;
      /** @description Gets the user facing code used so the user can quickly differentiate this request from others. */
      Code?: string;
      /** @description Gets the requesting device id. */
      DeviceId?: string;
      /** @description Gets the requesting device name. */
      DeviceName?: string;
      /** @description Gets the requesting app name. */
      AppName?: string;
      /** @description Gets the requesting app version. */
      AppVersion?: string;
      /**
       * Format: date-time
       * @description Gets or sets the DateTime that this request was created.
       */
      DateAdded?: string;
    };
    /** @enum {string} */
    RatingType: "Score" | "Likes";
    /** @description Class ReadyRequest. */
    ReadyRequestDto: {
      /**
       * Format: date-time
       * @description Gets or sets when the request has been made by the client.
       */
      When?: string;
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number;
      /** @description Gets or sets a value indicating whether the client playback is unpaused. */
      IsPlaying?: boolean;
      /**
       * Format: uuid
       * @description Gets or sets the playlist item identifier of the playing item.
       */
      PlaylistItemId?: string;
    };
    RecommendationDto: {
      Items?: components["schemas"]["BaseItemDto"][] | null;
      /** @enum {unknown} */
      RecommendationType?: "SimilarToRecentlyPlayed" | "SimilarToLikedItem" | "HasDirectorFromRecentlyPlayed" | "HasActorFromRecentlyPlayed" | "HasLikedDirector" | "HasLikedActor";
      BaselineItemName?: string | null;
      /** Format: uuid */
      CategoryId?: string;
    };
    /** @enum {string} */
    RecommendationType: "SimilarToRecentlyPlayed" | "SimilarToLikedItem" | "HasDirectorFromRecentlyPlayed" | "HasActorFromRecentlyPlayed" | "HasLikedDirector" | "HasLikedActor";
    /** @enum {string} */
    RecordingStatus: "New" | "InProgress" | "Completed" | "Cancelled" | "ConflictedOk" | "ConflictedNotOk" | "Error";
    /** @description Refresh progress message. */
    RefreshProgressMessage: {
      /** @description Gets or sets the data. */
      Data?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default RefreshProgress
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class RemoteImageInfo. */
    RemoteImageInfo: {
      /** @description Gets or sets the name of the provider. */
      ProviderName?: string | null;
      /** @description Gets or sets the URL. */
      Url?: string | null;
      /** @description Gets or sets a url used for previewing a smaller version. */
      ThumbnailUrl?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the height.
       */
      Height?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the width.
       */
      Width?: number | null;
      /**
       * Format: double
       * @description Gets or sets the community rating.
       */
      CommunityRating?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the vote count.
       */
      VoteCount?: number | null;
      /** @description Gets or sets the language. */
      Language?: string | null;
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      /**
       * @description Gets or sets the type of the rating.
       * @enum {unknown}
       */
      RatingType?: "Score" | "Likes";
    };
    /** @description Class RemoteImageResult. */
    RemoteImageResult: {
      /** @description Gets or sets the images. */
      Images?: components["schemas"]["RemoteImageInfo"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total record count.
       */
      TotalRecordCount?: number;
      /** @description Gets or sets the providers. */
      Providers?: string[] | null;
    };
    /** @description The remote lyric info dto. */
    RemoteLyricInfoDto: {
      /** @description Gets or sets the id for the lyric. */
      Id?: string;
      /** @description Gets the provider name. */
      ProviderName?: string;
      /** @description Gets the lyrics. */
      Lyrics?: components["schemas"]["LyricDto"];
    };
    RemoteSearchResult: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      ProductionYear?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      IndexNumberEnd?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      ImageUrl?: string | null;
      SearchProviderName?: string | null;
      Overview?: string | null;
      AlbumArtist?: components["schemas"]["RemoteSearchResult"] | null;
      Artists?: components["schemas"]["RemoteSearchResult"][] | null;
    };
    RemoteSubtitleInfo: {
      ThreeLetterISOLanguageName?: string | null;
      Id?: string | null;
      ProviderName?: string | null;
      Name?: string | null;
      Format?: string | null;
      Author?: string | null;
      Comment?: string | null;
      /** Format: date-time */
      DateCreated?: string | null;
      /** Format: float */
      CommunityRating?: number | null;
      /** Format: float */
      FrameRate?: number | null;
      /** Format: int32 */
      DownloadCount?: number | null;
      IsHashMatch?: boolean | null;
      AiTranslated?: boolean | null;
      MachineTranslated?: boolean | null;
      Forced?: boolean | null;
      HearingImpaired?: boolean | null;
    };
    /** @description Class RemoveFromPlaylistRequestDto. */
    RemoveFromPlaylistRequestDto: {
      /** @description Gets or sets the playlist identifiers of the items. Ignored when clearing the playlist. */
      PlaylistItemIds?: string[];
      /** @description Gets or sets a value indicating whether the entire playlist should be cleared. */
      ClearPlaylist?: boolean;
      /** @description Gets or sets a value indicating whether the playing item should be removed as well. Used only when clearing the playlist. */
      ClearPlayingItem?: boolean;
    };
    /** @enum {string} */
    RepeatMode: "RepeatNone" | "RepeatAll" | "RepeatOne";
    /** @description Class RepositoryInfo. */
    RepositoryInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the URL. */
      Url?: string | null;
      /** @description Gets or sets a value indicating whether the repository is enabled. */
      Enabled?: boolean;
    };
    /** @description Restart required. */
    RestartRequiredMessage: {
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default RestartRequired
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Scheduled task ended message. */
    ScheduledTaskEndedMessage: {
      /** @description Class TaskExecutionInfo. */
      Data?: components["schemas"]["TaskResult"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ScheduledTaskEnded
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Scheduled tasks info message. */
    ScheduledTasksInfoMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["TaskInfo"][] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ScheduledTasksInfo
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /**
     * @description Scheduled tasks info start message.
     * Data is the timing data encoded as "$initialDelay,$interval" in ms.
     */
    ScheduledTasksInfoStartMessage: {
      /** @description Gets or sets the data. */
      Data?: string | null;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ScheduledTasksInfoStart
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Scheduled tasks info stop message. */
    ScheduledTasksInfoStopMessage: {
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ScheduledTasksInfoStop
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /**
     * @description An enum representing the axis that should be scrolled.
     * @enum {string}
     */
    ScrollDirection: "Horizontal" | "Vertical";
    /** @description Class SearchHintResult. */
    SearchHint: {
      /**
       * Format: uuid
       * @deprecated
       * @description Gets or sets the item id.
       */
      ItemId?: string;
      /**
       * Format: uuid
       * @description Gets or sets the item id.
       */
      Id?: string;
      /** @description Gets or sets the name. */
      Name?: string;
      /** @description Gets or sets the matched term. */
      MatchedTerm?: string;
      /**
       * Format: int32
       * @description Gets or sets the index number.
       */
      IndexNumber?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the production year.
       */
      ProductionYear?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the parent index number.
       */
      ParentIndexNumber?: number | null;
      /** @description Gets or sets the image tag. */
      PrimaryImageTag?: string | null;
      /** @description Gets or sets the thumb image tag. */
      ThumbImageTag?: string | null;
      /** @description Gets or sets the thumb image item identifier. */
      ThumbImageItemId?: string | null;
      /** @description Gets or sets the backdrop image tag. */
      BackdropImageTag?: string | null;
      /** @description Gets or sets the backdrop image item identifier. */
      BackdropImageItemId?: string | null;
      /**
       * @description Gets or sets the type.
       * @enum {unknown}
       */
      Type?: "AggregateFolder" | "Audio" | "AudioBook" | "BasePluginFolder" | "Book" | "BoxSet" | "Channel" | "ChannelFolderItem" | "CollectionFolder" | "Episode" | "Folder" | "Genre" | "ManualPlaylistsFolder" | "Movie" | "LiveTvChannel" | "LiveTvProgram" | "MusicAlbum" | "MusicArtist" | "MusicGenre" | "MusicVideo" | "Person" | "Photo" | "PhotoAlbum" | "Playlist" | "PlaylistsFolder" | "Program" | "Recording" | "Season" | "Series" | "Studio" | "Trailer" | "TvChannel" | "TvProgram" | "UserRootFolder" | "UserView" | "Video" | "Year";
      /** @description Gets or sets a value indicating whether this instance is folder. */
      IsFolder?: boolean | null;
      /**
       * Format: int64
       * @description Gets or sets the run time ticks.
       */
      RunTimeTicks?: number | null;
      /**
       * @description Gets or sets the type of the media.
       * @enum {unknown}
       */
      MediaType?: "Unknown" | "Video" | "Audio" | "Photo" | "Book";
      /**
       * Format: date-time
       * @description Gets or sets the start date.
       */
      StartDate?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the end date.
       */
      EndDate?: string | null;
      /** @description Gets or sets the series. */
      Series?: string | null;
      /** @description Gets or sets the status. */
      Status?: string | null;
      /** @description Gets or sets the album. */
      Album?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the album id.
       */
      AlbumId?: string | null;
      /** @description Gets or sets the album artist. */
      AlbumArtist?: string | null;
      /** @description Gets or sets the artists. */
      Artists?: string[];
      /**
       * Format: int32
       * @description Gets or sets the song count.
       */
      SongCount?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the episode count.
       */
      EpisodeCount?: number | null;
      /**
       * Format: uuid
       * @description Gets or sets the channel identifier.
       */
      ChannelId?: string | null;
      /** @description Gets or sets the name of the channel. */
      ChannelName?: string | null;
      /**
       * Format: double
       * @description Gets or sets the primary image aspect ratio.
       */
      PrimaryImageAspectRatio?: number | null;
    };
    /** @description Class SearchHintResult. */
    SearchHintResult: {
      /** @description Gets the search hints. */
      SearchHints?: components["schemas"]["SearchHint"][];
      /**
       * Format: int32
       * @description Gets the total record count.
       */
      TotalRecordCount?: number;
    };
    /** @description Class SeekRequestDto. */
    SeekRequestDto: {
      /**
       * Format: int64
       * @description Gets or sets the position ticks.
       */
      PositionTicks?: number;
    };
    /** @description Class SendCommand. */
    SendCommand: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * Format: uuid
       * @description Gets the playlist identifier of the playing item.
       */
      PlaylistItemId?: string;
      /**
       * Format: date-time
       * @description Gets or sets the UTC time when to execute the command.
       */
      When?: string;
      /**
       * Format: int64
       * @description Gets the position ticks.
       */
      PositionTicks?: number | null;
      /**
       * @description Gets the command.
       * @enum {unknown}
       */
      Command?: "Unpause" | "Pause" | "Stop" | "Seek";
      /**
       * Format: date-time
       * @description Gets the UTC time when this command has been emitted.
       */
      EmittedAt?: string;
    };
    /**
     * @description Enum SendCommandType.
     * @enum {string}
     */
    SendCommandType: "Unpause" | "Pause" | "Stop" | "Seek";
    SeriesInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
    };
    SeriesInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["SeriesInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    /**
     * @description The status of a series.
     * @enum {string}
     */
    SeriesStatus: "Continuing" | "Ended" | "Unreleased";
    /** @description Series timer cancelled message. */
    SeriesTimerCancelledMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["TimerEventInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SeriesTimerCancelled
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Series timer created message. */
    SeriesTimerCreatedMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["TimerEventInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SeriesTimerCreated
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class SeriesTimerInfoDto. */
    SeriesTimerInfoDto: {
      /** @description Gets or sets the Id of the recording. */
      Id?: string | null;
      Type?: string | null;
      /** @description Gets or sets the server identifier. */
      ServerId?: string | null;
      /** @description Gets or sets the external identifier. */
      ExternalId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the channel id of the recording.
       */
      ChannelId?: string;
      /** @description Gets or sets the external channel identifier. */
      ExternalChannelId?: string | null;
      /** @description Gets or sets the channel name of the recording. */
      ChannelName?: string | null;
      ChannelPrimaryImageTag?: string | null;
      /** @description Gets or sets the program identifier. */
      ProgramId?: string | null;
      /** @description Gets or sets the external program identifier. */
      ExternalProgramId?: string | null;
      /** @description Gets or sets the name of the recording. */
      Name?: string | null;
      /** @description Gets or sets the description of the recording. */
      Overview?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the start date of the recording, in UTC.
       */
      StartDate?: string;
      /**
       * Format: date-time
       * @description Gets or sets the end date of the recording, in UTC.
       */
      EndDate?: string;
      /** @description Gets or sets the name of the service. */
      ServiceName?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the priority.
       */
      Priority?: number;
      /**
       * Format: int32
       * @description Gets or sets the pre padding seconds.
       */
      PrePaddingSeconds?: number;
      /**
       * Format: int32
       * @description Gets or sets the post padding seconds.
       */
      PostPaddingSeconds?: number;
      /** @description Gets or sets a value indicating whether this instance is pre padding required. */
      IsPrePaddingRequired?: boolean;
      /** @description Gets or sets the Id of the Parent that has a backdrop if the item does not have one. */
      ParentBackdropItemId?: string | null;
      /** @description Gets or sets the parent backdrop image tags. */
      ParentBackdropImageTags?: string[] | null;
      /** @description Gets or sets a value indicating whether this instance is post padding required. */
      IsPostPaddingRequired?: boolean;
      /** @enum {unknown} */
      KeepUntil?: "UntilDeleted" | "UntilSpaceNeeded" | "UntilWatched" | "UntilDate";
      /** @description Gets or sets a value indicating whether [record any time]. */
      RecordAnyTime?: boolean;
      SkipEpisodesInLibrary?: boolean;
      /** @description Gets or sets a value indicating whether [record any channel]. */
      RecordAnyChannel?: boolean;
      /** Format: int32 */
      KeepUpTo?: number;
      /** @description Gets or sets a value indicating whether [record new only]. */
      RecordNewOnly?: boolean;
      /** @description Gets or sets the days. */
      Days?: components["schemas"]["DayOfWeek"][] | null;
      /**
       * @description Gets or sets the day pattern.
       * @enum {unknown|null}
       */
      DayPattern?: "Daily" | "Weekdays" | "Weekends" | null;
      /** @description Gets or sets the image tags. */
      ImageTags?: {
        [key: string]: string;
      } | null;
      /** @description Gets or sets the parent thumb item id. */
      ParentThumbItemId?: string | null;
      /** @description Gets or sets the parent thumb image tag. */
      ParentThumbImageTag?: string | null;
      /** @description Gets or sets the parent primary image item identifier. */
      ParentPrimaryImageItemId?: string | null;
      /** @description Gets or sets the parent primary image tag. */
      ParentPrimaryImageTag?: string | null;
    };
    SeriesTimerInfoDtoQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["SeriesTimerInfoDto"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    /** @description Represents the server configuration. */
    ServerConfiguration: {
      /**
       * Format: int32
       * @description Gets or sets the number of days we should retain log files.
       */
      LogFileRetentionDays?: number;
      /** @description Gets or sets a value indicating whether this instance is first run. */
      IsStartupWizardCompleted?: boolean;
      /** @description Gets or sets the cache path. */
      CachePath?: string | null;
      /** @description Gets or sets the last known version that was ran using the configuration. */
      PreviousVersion?: string | null;
      /**
       * @description Gets or sets the stringified PreviousVersion to be stored/loaded,
       * because System.Version itself isn't xml-serializable.
       */
      PreviousVersionStr?: string | null;
      /** @description Gets or sets a value indicating whether to enable prometheus metrics exporting. */
      EnableMetrics?: boolean;
      EnableNormalizedItemByNameIds?: boolean;
      /** @description Gets or sets a value indicating whether this instance is port authorized. */
      IsPortAuthorized?: boolean;
      /** @description Gets or sets a value indicating whether quick connect is available for use on this server. */
      QuickConnectAvailable?: boolean;
      /** @description Gets or sets a value indicating whether [enable case sensitive item ids]. */
      EnableCaseSensitiveItemIds?: boolean;
      DisableLiveTvChannelUserDataName?: boolean;
      /** @description Gets or sets the metadata path. */
      MetadataPath?: string;
      MetadataNetworkPath?: string;
      /** @description Gets or sets the preferred metadata language. */
      PreferredMetadataLanguage?: string;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string;
      /** @description Gets or sets characters to be replaced with a ' ' in strings to create a sort name. */
      SortReplaceCharacters?: string[];
      /** @description Gets or sets characters to be removed from strings to create a sort name. */
      SortRemoveCharacters?: string[];
      /** @description Gets or sets words to be removed from strings to create a sort name. */
      SortRemoveWords?: string[];
      /**
       * Format: int32
       * @description Gets or sets the minimum percentage of an item that must be played in order for playstate to be updated.
       */
      MinResumePct?: number;
      /**
       * Format: int32
       * @description Gets or sets the maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
       */
      MaxResumePct?: number;
      /**
       * Format: int32
       * @description Gets or sets the minimum duration that an item must have in order to be eligible for playstate updates..
       */
      MinResumeDurationSeconds?: number;
      /**
       * Format: int32
       * @description Gets or sets the minimum minutes of a book that must be played in order for playstate to be updated.
       */
      MinAudiobookResume?: number;
      /**
       * Format: int32
       * @description Gets or sets the remaining minutes of a book that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
       */
      MaxAudiobookResume?: number;
      /**
       * Format: int32
       * @description Gets or sets the threshold in minutes after a inactive session gets closed automatically.
       * If set to 0 the check for inactive sessions gets disabled.
       */
      InactiveSessionThreshold?: number;
      /**
       * Format: int32
       * @description Gets or sets the delay in seconds that we will wait after a file system change to try and discover what has been added/removed
       * Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several
       * different directories and files.
       */
      LibraryMonitorDelay?: number;
      /**
       * Format: int32
       * @description Gets or sets the duration in seconds that we will wait after a library updated event before executing the library changed notification.
       */
      LibraryUpdateDuration?: number;
      /**
       * @description Gets or sets the image saving convention.
       * @enum {unknown}
       */
      ImageSavingConvention?: "Legacy" | "Compatible";
      MetadataOptions?: components["schemas"]["MetadataOptions"][];
      SkipDeserializationForBasicTypes?: boolean;
      ServerName?: string;
      UICulture?: string;
      SaveMetadataHidden?: boolean;
      ContentTypes?: components["schemas"]["NameValuePair"][];
      /** Format: int32 */
      RemoteClientBitrateLimit?: number;
      EnableFolderView?: boolean;
      EnableGroupingIntoCollections?: boolean;
      DisplaySpecialsWithinSeasons?: boolean;
      CodecsUsed?: string[];
      PluginRepositories?: components["schemas"]["RepositoryInfo"][];
      EnableExternalContentInSuggestions?: boolean;
      /** Format: int32 */
      ImageExtractionTimeoutMs?: number;
      PathSubstitutions?: components["schemas"]["PathSubstitution"][];
      /** @description Gets or sets a value indicating whether slow server responses should be logged as a warning. */
      EnableSlowResponseWarning?: boolean;
      /**
       * Format: int64
       * @description Gets or sets the threshold for the slow response time warning in ms.
       */
      SlowResponseThresholdMs?: number;
      /** @description Gets or sets the cors hosts. */
      CorsHosts?: string[];
      /**
       * Format: int32
       * @description Gets or sets the number of days we should retain activity logs.
       */
      ActivityLogRetentionDays?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the how the library scan fans out.
       */
      LibraryScanFanoutConcurrency?: number;
      /**
       * Format: int32
       * @description Gets or sets the how many metadata refreshes can run concurrently.
       */
      LibraryMetadataRefreshConcurrency?: number;
      /** @description Gets or sets a value indicating whether older plugins should automatically be deleted from the plugin folder. */
      RemoveOldPlugins?: boolean;
      /** @description Gets or sets a value indicating whether clients should be allowed to upload logs. */
      AllowClientLogUpload?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the dummy chapter duration in seconds, use 0 (zero) or less to disable generation alltogether.
       */
      DummyChapterDuration?: number;
      /**
       * @description Gets or sets the chapter image resolution.
       * @enum {unknown}
       */
      ChapterImageResolution?: "MatchSource" | "P144" | "P240" | "P360" | "P480" | "P720" | "P1080" | "P1440" | "P2160";
      /**
       * Format: int32
       * @description Gets or sets the limit for parallel image encoding.
       */
      ParallelImageEncodingLimit?: number;
      /** @description Gets or sets the list of cast receiver applications. */
      CastReceiverApplications?: components["schemas"]["CastReceiverApplication"][];
      /** @description Gets or sets the trickplay options. */
      TrickplayOptions?: components["schemas"]["TrickplayOptions"];
    };
    /** @description The server discovery info model. */
    ServerDiscoveryInfo: {
      /** @description Gets the address. */
      Address?: string;
      /** @description Gets the server identifier. */
      Id?: string;
      /** @description Gets the name. */
      Name?: string;
      /** @description Gets the endpoint address. */
      EndpointAddress?: string | null;
    };
    /** @description Server restarting down message. */
    ServerRestartingMessage: {
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ServerRestarting
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Server shutting down message. */
    ServerShuttingDownMessage: {
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default ServerShuttingDown
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class SessionInfo. */
    SessionInfo: {
      PlayState?: components["schemas"]["PlayerStateInfo"] | null;
      AdditionalUsers?: components["schemas"]["SessionUserInfo"][] | null;
      Capabilities?: components["schemas"]["ClientCapabilities"] | null;
      /** @description Gets or sets the remote end point. */
      RemoteEndPoint?: string | null;
      /** @description Gets the playable media types. */
      PlayableMediaTypes?: (readonly components["schemas"]["MediaType"][]) | null;
      /** @description Gets or sets the id. */
      Id?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the user id.
       */
      UserId?: string;
      /** @description Gets or sets the username. */
      UserName?: string | null;
      /** @description Gets or sets the type of the client. */
      Client?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the last activity date.
       */
      LastActivityDate?: string;
      /**
       * Format: date-time
       * @description Gets or sets the last playback check in.
       */
      LastPlaybackCheckIn?: string;
      /**
       * Format: date-time
       * @description Gets or sets the last paused date.
       */
      LastPausedDate?: string | null;
      /** @description Gets or sets the name of the device. */
      DeviceName?: string | null;
      /** @description Gets or sets the type of the device. */
      DeviceType?: string | null;
      /**
       * @description This is strictly used as a data transfer object from the api layer.
       * This holds information about a BaseItem in a format that is convenient for the client.
       */
      NowPlayingItem?: components["schemas"]["BaseItemDto"] | null;
      /**
       * @description This is strictly used as a data transfer object from the api layer.
       * This holds information about a BaseItem in a format that is convenient for the client.
       */
      NowViewingItem?: components["schemas"]["BaseItemDto"] | null;
      /** @description Gets or sets the device id. */
      DeviceId?: string | null;
      /** @description Gets or sets the application version. */
      ApplicationVersion?: string | null;
      TranscodingInfo?: components["schemas"]["TranscodingInfo"] | null;
      /** @description Gets a value indicating whether this instance is active. */
      IsActive?: boolean;
      SupportsMediaControl?: boolean;
      SupportsRemoteControl?: boolean;
      NowPlayingQueue?: components["schemas"]["QueueItem"][] | null;
      NowPlayingQueueFullItems?: components["schemas"]["BaseItemDto"][] | null;
      HasCustomDeviceName?: boolean;
      PlaylistItemId?: string | null;
      ServerId?: string | null;
      UserPrimaryImageTag?: string | null;
      /** @description Gets the supported commands. */
      SupportedCommands?: (readonly components["schemas"]["GeneralCommandType"][]) | null;
    };
    /**
     * @description The different kinds of messages that are used in the WebSocket api.
     * @enum {string}
     */
    SessionMessageType: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    /** @description Sessions message. */
    SessionsMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["SessionInfo"][] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default Sessions
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /**
     * @description Sessions start message.
     * Data is the timing data encoded as "$initialDelay,$interval" in ms.
     */
    SessionsStartMessage: {
      /** @description Gets or sets the data. */
      Data?: string | null;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SessionsStart
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Sessions stop message. */
    SessionsStopMessage: {
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SessionsStop
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class SessionUserInfo. */
    SessionUserInfo: {
      /**
       * Format: uuid
       * @description Gets or sets the user identifier.
       */
      UserId?: string;
      /** @description Gets or sets the name of the user. */
      UserName?: string | null;
    };
    /** @description Set channel mapping dto. */
    SetChannelMappingDto: {
      /** @description Gets or sets the provider id. */
      ProviderId: string;
      /** @description Gets or sets the tuner channel id. */
      TunerChannelId: string;
      /** @description Gets or sets the provider channel id. */
      ProviderChannelId: string;
    };
    /** @description Class SetPlaylistItemRequestDto. */
    SetPlaylistItemRequestDto: {
      /**
       * Format: uuid
       * @description Gets or sets the playlist identifier of the playing item.
       */
      PlaylistItemId?: string;
    };
    /** @description Class SetRepeatModeRequestDto. */
    SetRepeatModeRequestDto: {
      /**
       * @description Enum GroupRepeatMode.
       * @enum {unknown}
       */
      Mode?: "RepeatOne" | "RepeatAll" | "RepeatNone";
    };
    /** @description Class SetShuffleModeRequestDto. */
    SetShuffleModeRequestDto: {
      /**
       * @description Enum GroupShuffleMode.
       * @enum {unknown}
       */
      Mode?: "Sorted" | "Shuffle";
    };
    SongInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
      AlbumArtists?: string[] | null;
      Album?: string | null;
      Artists?: string[] | null;
    };
    /**
     * @description An enum representing the sorting order.
     * @enum {string}
     */
    SortOrder: "Ascending" | "Descending";
    /** @description Special view option dto. */
    SpecialViewOptionDto: {
      /** @description Gets or sets view option name. */
      Name?: string | null;
      /** @description Gets or sets view option id. */
      Id?: string | null;
    };
    /** @description The startup configuration DTO. */
    StartupConfigurationDto: {
      /** @description Gets or sets UI language culture. */
      UICulture?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the preferred language for the metadata. */
      PreferredMetadataLanguage?: string | null;
    };
    /** @description Startup remote access dto. */
    StartupRemoteAccessDto: {
      /** @description Gets or sets a value indicating whether enable remote access. */
      EnableRemoteAccess: boolean;
      /** @description Gets or sets a value indicating whether enable automatic port mapping. */
      EnableAutomaticPortMapping: boolean;
    };
    /** @description The startup user DTO. */
    StartupUserDto: {
      /** @description Gets or sets the username. */
      Name?: string | null;
      /** @description Gets or sets the user's password. */
      Password?: string | null;
    };
    /** @description Class GroupUpdate. */
    StringGroupUpdate: {
      /**
       * Format: uuid
       * @description Gets the group identifier.
       */
      GroupId?: string;
      /**
       * @description Gets the update type.
       * @enum {unknown}
       */
      Type?: "UserJoined" | "UserLeft" | "GroupJoined" | "GroupLeft" | "StateUpdate" | "PlayQueue" | "NotInGroup" | "GroupDoesNotExist" | "CreateGroupDenied" | "JoinGroupDenied" | "LibraryAccessDenied";
      /** @description Gets the update data. */
      Data?: string;
    };
    /**
     * @description Delivery method to use during playback of a specific subtitle format.
     * @enum {string}
     */
    SubtitleDeliveryMethod: "Encode" | "Embed" | "External" | "Hls" | "Drop";
    SubtitleOptions: {
      SkipIfEmbeddedSubtitlesPresent?: boolean;
      SkipIfAudioTrackMatches?: boolean;
      DownloadLanguages?: string[] | null;
      DownloadMovieSubtitles?: boolean;
      DownloadEpisodeSubtitles?: boolean;
      OpenSubtitlesUsername?: string | null;
      OpenSubtitlesPasswordHash?: string | null;
      IsOpenSubtitleVipAccount?: boolean;
      RequirePerfectMatch?: boolean;
    };
    /**
     * @description An enum representing a subtitle playback mode.
     * @enum {string}
     */
    SubtitlePlaybackMode: "Default" | "Always" | "OnlyForced" | "None" | "Smart";
    SubtitleProfile: {
      Format?: string | null;
      /**
       * @description Delivery method to use during playback of a specific subtitle format.
       * @enum {unknown}
       */
      Method?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
      DidlMode?: string | null;
      Language?: string | null;
      Container?: string | null;
    };
    /** @description Sync play command. */
    SyncPlayCommandMessage: {
      /** @description Class SendCommand. */
      Data?: components["schemas"]["SendCommand"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SyncPlayCommand
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Untyped sync play command. */
    SyncPlayGroupUpdateCommandMessage: {
      /** @description Group update without data. */
      Data?: ({
        Type: "SyncPlayGroupUpdateCommandMessage";
      } & Omit<components["schemas"]["GroupUpdate"], "Type">) | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default SyncPlayGroupUpdate
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class QueueItem. */
    SyncPlayQueueItem: {
      /**
       * Format: uuid
       * @description Gets the item identifier.
       */
      ItemId?: string;
      /**
       * Format: uuid
       * @description Gets the playlist identifier of the item.
       */
      PlaylistItemId?: string;
    };
    /**
     * @description Enum SyncPlayUserAccessType.
     * @enum {string}
     */
    SyncPlayUserAccessType: "CreateAndJoinGroups" | "JoinGroups" | "None";
    /** @description Class SystemInfo. */
    SystemInfo: {
      /** @description Gets or sets the local address. */
      LocalAddress?: string | null;
      /** @description Gets or sets the name of the server. */
      ServerName?: string | null;
      /** @description Gets or sets the server version. */
      Version?: string | null;
      /** @description Gets or sets the product name. This is the AssemblyProduct name. */
      ProductName?: string | null;
      /**
       * @deprecated
       * @description Gets or sets the operating system.
       */
      OperatingSystem?: string | null;
      /** @description Gets or sets the id. */
      Id?: string | null;
      /** @description Gets or sets a value indicating whether the startup wizard is completed. */
      StartupWizardCompleted?: boolean | null;
      /**
       * @deprecated
       * @description Gets or sets the display name of the operating system.
       */
      OperatingSystemDisplayName?: string | null;
      /** @description Gets or sets the package name. */
      PackageName?: string | null;
      /** @description Gets or sets a value indicating whether this instance has pending restart. */
      HasPendingRestart?: boolean;
      IsShuttingDown?: boolean;
      /** @description Gets or sets a value indicating whether [supports library monitor]. */
      SupportsLibraryMonitor?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the web socket port number.
       */
      WebSocketPortNumber?: number;
      /** @description Gets or sets the completed installations. */
      CompletedInstallations?: components["schemas"]["InstallationInfo"][] | null;
      /**
       * @deprecated
       * @description Gets or sets a value indicating whether this instance can self restart.
       * @default true
       */
      CanSelfRestart?: boolean;
      /**
       * @deprecated
       * @default false
       */
      CanLaunchWebBrowser?: boolean;
      /** @description Gets or sets the program data path. */
      ProgramDataPath?: string | null;
      /** @description Gets or sets the web UI resources path. */
      WebPath?: string | null;
      /** @description Gets or sets the items by name path. */
      ItemsByNamePath?: string | null;
      /** @description Gets or sets the cache path. */
      CachePath?: string | null;
      /** @description Gets or sets the log path. */
      LogPath?: string | null;
      /** @description Gets or sets the internal metadata path. */
      InternalMetadataPath?: string | null;
      /** @description Gets or sets the transcode path. */
      TranscodingTempPath?: string | null;
      /** @description Gets or sets the list of cast receiver applications. */
      CastReceiverApplications?: components["schemas"]["CastReceiverApplication"][] | null;
      /**
       * @deprecated
       * @description Gets or sets a value indicating whether this instance has update available.
       * @default false
       */
      HasUpdateAvailable?: boolean;
      /**
       * @deprecated
       * @default System
       */
      EncoderLocation?: string | null;
      /**
       * @deprecated
       * @default X64
       */
      SystemArchitecture?: string | null;
    };
    /**
     * @description Enum TaskCompletionStatus.
     * @enum {string}
     */
    TaskCompletionStatus: "Completed" | "Failed" | "Cancelled" | "Aborted";
    /** @description Class TaskInfo. */
    TaskInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /**
       * @description Gets or sets the state of the task.
       * @enum {unknown}
       */
      State?: "Idle" | "Cancelling" | "Running";
      /**
       * Format: double
       * @description Gets or sets the progress.
       */
      CurrentProgressPercentage?: number | null;
      /** @description Gets or sets the id. */
      Id?: string | null;
      /** @description Gets or sets the last execution result. */
      LastExecutionResult?: components["schemas"]["TaskResult"] | null;
      /** @description Gets or sets the triggers. */
      Triggers?: components["schemas"]["TaskTriggerInfo"][] | null;
      /** @description Gets or sets the description. */
      Description?: string | null;
      /** @description Gets or sets the category. */
      Category?: string | null;
      /** @description Gets or sets a value indicating whether this instance is hidden. */
      IsHidden?: boolean;
      /** @description Gets or sets the key. */
      Key?: string | null;
    };
    /** @description Class TaskExecutionInfo. */
    TaskResult: {
      /**
       * Format: date-time
       * @description Gets or sets the start time UTC.
       */
      StartTimeUtc?: string;
      /**
       * Format: date-time
       * @description Gets or sets the end time UTC.
       */
      EndTimeUtc?: string;
      /**
       * @description Gets or sets the status.
       * @enum {unknown}
       */
      Status?: "Completed" | "Failed" | "Cancelled" | "Aborted";
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the key. */
      Key?: string | null;
      /** @description Gets or sets the id. */
      Id?: string | null;
      /** @description Gets or sets the error message. */
      ErrorMessage?: string | null;
      /** @description Gets or sets the long error message. */
      LongErrorMessage?: string | null;
    };
    /**
     * @description Enum TaskState.
     * @enum {string}
     */
    TaskState: "Idle" | "Cancelling" | "Running";
    /** @description Class TaskTriggerInfo. */
    TaskTriggerInfo: {
      /** @description Gets or sets the type. */
      Type?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the time of day.
       */
      TimeOfDayTicks?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the interval.
       */
      IntervalTicks?: number | null;
      /**
       * @description Gets or sets the day of week.
       * @enum {unknown|null}
       */
      DayOfWeek?: "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | null;
      /**
       * Format: int64
       * @description Gets or sets the maximum runtime ticks.
       */
      MaxRuntimeTicks?: number | null;
    };
    /** @description Class ThemeMediaResult. */
    ThemeMediaResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["BaseItemDto"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
      /**
       * Format: uuid
       * @description Gets or sets the owner id.
       */
      OwnerId?: string;
    };
    /** @description Timer cancelled message. */
    TimerCancelledMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["TimerEventInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default TimerCancelled
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Timer created message. */
    TimerCreatedMessage: {
      /** @description Gets or sets the data. */
      Data?: components["schemas"]["TimerEventInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default TimerCreated
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    TimerEventInfo: {
      Id?: string;
      /** Format: uuid */
      ProgramId?: string | null;
    };
    TimerInfoDto: {
      /** @description Gets or sets the Id of the recording. */
      Id?: string | null;
      Type?: string | null;
      /** @description Gets or sets the server identifier. */
      ServerId?: string | null;
      /** @description Gets or sets the external identifier. */
      ExternalId?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the channel id of the recording.
       */
      ChannelId?: string;
      /** @description Gets or sets the external channel identifier. */
      ExternalChannelId?: string | null;
      /** @description Gets or sets the channel name of the recording. */
      ChannelName?: string | null;
      ChannelPrimaryImageTag?: string | null;
      /** @description Gets or sets the program identifier. */
      ProgramId?: string | null;
      /** @description Gets or sets the external program identifier. */
      ExternalProgramId?: string | null;
      /** @description Gets or sets the name of the recording. */
      Name?: string | null;
      /** @description Gets or sets the description of the recording. */
      Overview?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the start date of the recording, in UTC.
       */
      StartDate?: string;
      /**
       * Format: date-time
       * @description Gets or sets the end date of the recording, in UTC.
       */
      EndDate?: string;
      /** @description Gets or sets the name of the service. */
      ServiceName?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the priority.
       */
      Priority?: number;
      /**
       * Format: int32
       * @description Gets or sets the pre padding seconds.
       */
      PrePaddingSeconds?: number;
      /**
       * Format: int32
       * @description Gets or sets the post padding seconds.
       */
      PostPaddingSeconds?: number;
      /** @description Gets or sets a value indicating whether this instance is pre padding required. */
      IsPrePaddingRequired?: boolean;
      /** @description Gets or sets the Id of the Parent that has a backdrop if the item does not have one. */
      ParentBackdropItemId?: string | null;
      /** @description Gets or sets the parent backdrop image tags. */
      ParentBackdropImageTags?: string[] | null;
      /** @description Gets or sets a value indicating whether this instance is post padding required. */
      IsPostPaddingRequired?: boolean;
      /** @enum {unknown} */
      KeepUntil?: "UntilDeleted" | "UntilSpaceNeeded" | "UntilWatched" | "UntilDate";
      /**
       * @description Gets or sets the status.
       * @enum {unknown}
       */
      Status?: "New" | "InProgress" | "Completed" | "Cancelled" | "ConflictedOk" | "ConflictedNotOk" | "Error";
      /** @description Gets or sets the series timer identifier. */
      SeriesTimerId?: string | null;
      /** @description Gets or sets the external series timer identifier. */
      ExternalSeriesTimerId?: string | null;
      /**
       * Format: int64
       * @description Gets or sets the run time ticks.
       */
      RunTimeTicks?: number | null;
      /** @description Gets or sets the program information. */
      ProgramInfo?: components["schemas"]["BaseItemDto"] | null;
    };
    TimerInfoDtoQueryResult: {
      /** @description Gets or sets the items. */
      Items?: components["schemas"]["TimerInfoDto"][] | null;
      /**
       * Format: int32
       * @description Gets or sets the total number of records available.
       */
      TotalRecordCount?: number;
      /**
       * Format: int32
       * @description Gets or sets the index of the first record in Items.
       */
      StartIndex?: number;
    };
    TrailerInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the original title. */
      OriginalTitle?: string | null;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets the metadata language. */
      MetadataLanguage?: string | null;
      /** @description Gets or sets the metadata country code. */
      MetadataCountryCode?: string | null;
      /** @description Gets or sets the provider ids. */
      ProviderIds?: ({
        [key: string]: string | null;
      }) | null;
      /**
       * Format: int32
       * @description Gets or sets the year.
       */
      Year?: number | null;
      /** Format: int32 */
      IndexNumber?: number | null;
      /** Format: int32 */
      ParentIndexNumber?: number | null;
      /** Format: date-time */
      PremiereDate?: string | null;
      IsAutomated?: boolean;
    };
    TrailerInfoRemoteSearchQuery: {
      SearchInfo?: components["schemas"]["TrailerInfo"] | null;
      /** Format: uuid */
      ItemId?: string;
      /** @description Gets or sets the provider name to search within if set. */
      SearchProviderName?: string | null;
      /** @description Gets or sets a value indicating whether disabled providers should be included. */
      IncludeDisabledProviders?: boolean;
    };
    /** @enum {string} */
    TranscodeReason: "ContainerNotSupported" | "VideoCodecNotSupported" | "AudioCodecNotSupported" | "SubtitleCodecNotSupported" | "AudioIsExternal" | "SecondaryAudioNotSupported" | "VideoProfileNotSupported" | "VideoLevelNotSupported" | "VideoResolutionNotSupported" | "VideoBitDepthNotSupported" | "VideoFramerateNotSupported" | "RefFramesNotSupported" | "AnamorphicVideoNotSupported" | "InterlacedVideoNotSupported" | "AudioChannelsNotSupported" | "AudioProfileNotSupported" | "AudioSampleRateNotSupported" | "AudioBitDepthNotSupported" | "ContainerBitrateExceedsLimit" | "VideoBitrateNotSupported" | "AudioBitrateNotSupported" | "UnknownVideoStreamInfo" | "UnknownAudioStreamInfo" | "DirectPlayError" | "VideoRangeTypeNotSupported";
    /** @enum {string} */
    TranscodeSeekInfo: "Auto" | "Bytes";
    TranscodingInfo: {
      AudioCodec?: string | null;
      VideoCodec?: string | null;
      Container?: string | null;
      IsVideoDirect?: boolean;
      IsAudioDirect?: boolean;
      /** Format: int32 */
      Bitrate?: number | null;
      /** Format: float */
      Framerate?: number | null;
      /** Format: double */
      CompletionPercentage?: number | null;
      /** Format: int32 */
      Width?: number | null;
      /** Format: int32 */
      Height?: number | null;
      /** Format: int32 */
      AudioChannels?: number | null;
      /** @enum {unknown|null} */
      HardwareAccelerationType?: "AMF" | "QSV" | "NVENC" | "V4L2M2M" | "VAAPI" | "VideoToolBox" | "RKMPP" | null;
      /** @enum {array} */
      TranscodeReasons?: ContainerNotSupported | VideoCodecNotSupported | AudioCodecNotSupported | SubtitleCodecNotSupported | AudioIsExternal | SecondaryAudioNotSupported | VideoProfileNotSupported | VideoLevelNotSupported | VideoResolutionNotSupported | VideoBitDepthNotSupported | VideoFramerateNotSupported | RefFramesNotSupported | AnamorphicVideoNotSupported | InterlacedVideoNotSupported | AudioChannelsNotSupported | AudioProfileNotSupported | AudioSampleRateNotSupported | AudioBitDepthNotSupported | ContainerBitrateExceedsLimit | VideoBitrateNotSupported | AudioBitrateNotSupported | UnknownVideoStreamInfo | UnknownAudioStreamInfo | DirectPlayError | VideoRangeTypeNotSupported;
    };
    TranscodingProfile: {
      Container?: string;
      /** @enum {unknown} */
      Type?: "Audio" | "Video" | "Photo" | "Subtitle" | "Lyric";
      VideoCodec?: string;
      AudioCodec?: string;
      /**
       * @description Media streaming protocol.
       * Lowercase for backwards compatibility.
       * @enum {unknown}
       */
      Protocol?: "http" | "hls";
      /** @default false */
      EstimateContentLength?: boolean;
      /** @default false */
      EnableMpegtsM2TsMode?: boolean;
      /**
       * @default Auto
       * @enum {unknown}
       */
      TranscodeSeekInfo?: "Auto" | "Bytes";
      /** @default false */
      CopyTimestamps?: boolean;
      /**
       * @default Streaming
       * @enum {unknown}
       */
      Context?: "Streaming" | "Static";
      /** @default false */
      EnableSubtitlesInManifest?: boolean;
      MaxAudioChannels?: string | null;
      /**
       * Format: int32
       * @default 0
       */
      MinSegments?: number;
      /**
       * Format: int32
       * @default 0
       */
      SegmentLength?: number;
      /** @default false */
      BreakOnNonKeyFrames?: boolean;
      Conditions?: components["schemas"]["ProfileCondition"][];
    };
    /** @enum {string} */
    TransportStreamTimestamp: "None" | "Zero" | "Valid";
    /** @description An entity representing the metadata for a group of trickplay tiles. */
    TrickplayInfo: {
      /**
       * Format: int32
       * @description Gets or sets width of an individual thumbnail.
       */
      Width?: number;
      /**
       * Format: int32
       * @description Gets or sets height of an individual thumbnail.
       */
      Height?: number;
      /**
       * Format: int32
       * @description Gets or sets amount of thumbnails per row.
       */
      TileWidth?: number;
      /**
       * Format: int32
       * @description Gets or sets amount of thumbnails per column.
       */
      TileHeight?: number;
      /**
       * Format: int32
       * @description Gets or sets total amount of non-black thumbnails.
       */
      ThumbnailCount?: number;
      /**
       * Format: int32
       * @description Gets or sets interval in milliseconds between each trickplay thumbnail.
       */
      Interval?: number;
      /**
       * Format: int32
       * @description Gets or sets peak bandwith usage in bits per second.
       */
      Bandwidth?: number;
    };
    /** @description Class TrickplayOptions. */
    TrickplayOptions: {
      /** @description Gets or sets a value indicating whether or not to use HW acceleration. */
      EnableHwAcceleration?: boolean;
      /** @description Gets or sets a value indicating whether or not to use HW accelerated MJPEG encoding. */
      EnableHwEncoding?: boolean;
      /**
       * @description Gets or sets the behavior used by trickplay provider on library scan/update.
       * @enum {unknown}
       */
      ScanBehavior?: "Blocking" | "NonBlocking";
      /**
       * @description Gets or sets the process priority for the ffmpeg process.
       * @enum {unknown}
       */
      ProcessPriority?: "Normal" | "Idle" | "High" | "RealTime" | "BelowNormal" | "AboveNormal";
      /**
       * Format: int32
       * @description Gets or sets the interval, in ms, between each new trickplay image.
       */
      Interval?: number;
      /** @description Gets or sets the target width resolutions, in px, to generates preview images for. */
      WidthResolutions?: number[];
      /**
       * Format: int32
       * @description Gets or sets number of tile images to allow in X dimension.
       */
      TileWidth?: number;
      /**
       * Format: int32
       * @description Gets or sets number of tile images to allow in Y dimension.
       */
      TileHeight?: number;
      /**
       * Format: int32
       * @description Gets or sets the ffmpeg output quality level.
       */
      Qscale?: number;
      /**
       * Format: int32
       * @description Gets or sets the jpeg quality to use for image tiles.
       */
      JpegQuality?: number;
      /**
       * Format: int32
       * @description Gets or sets the number of threads to be used by ffmpeg.
       */
      ProcessThreads?: number;
    };
    /**
     * @description Enum TrickplayScanBehavior.
     * @enum {string}
     */
    TrickplayScanBehavior: "Blocking" | "NonBlocking";
    TunerChannelMapping: {
      Name?: string | null;
      ProviderChannelName?: string | null;
      ProviderChannelId?: string | null;
      Id?: string | null;
    };
    TunerHostInfo: {
      Id?: string | null;
      Url?: string | null;
      Type?: string | null;
      DeviceId?: string | null;
      FriendlyName?: string | null;
      ImportFavoritesOnly?: boolean;
      AllowHWTranscoding?: boolean;
      EnableStreamLooping?: boolean;
      Source?: string | null;
      /** Format: int32 */
      TunerCount?: number;
      UserAgent?: string | null;
      IgnoreDts?: boolean;
    };
    TypeOptions: {
      Type?: string | null;
      MetadataFetchers?: string[] | null;
      MetadataFetcherOrder?: string[] | null;
      ImageFetchers?: string[] | null;
      ImageFetcherOrder?: string[] | null;
      ImageOptions?: components["schemas"]["ImageOption"][] | null;
    };
    /**
     * @description An enum representing an unrated item.
     * @enum {string}
     */
    UnratedItem: "Movie" | "Trailer" | "Series" | "Music" | "Book" | "LiveTvChannel" | "LiveTvProgram" | "ChannelContent" | "Other";
    /** @description Update library options dto. */
    UpdateLibraryOptionsDto: {
      /**
       * Format: uuid
       * @description Gets or sets the library item id.
       */
      Id?: string;
      /** @description Gets or sets library options. */
      LibraryOptions?: components["schemas"]["LibraryOptions"] | null;
    };
    /** @description Update library options dto. */
    UpdateMediaPathRequestDto: {
      /** @description Gets or sets the library name. */
      Name: string;
      /** @description Gets or sets library folder path information. */
      PathInfo: components["schemas"]["MediaPathInfo"];
    };
    /** @description Update existing playlist dto. Fields set to `null` will not be updated and keep their current values. */
    UpdatePlaylistDto: {
      /** @description Gets or sets the name of the new playlist. */
      Name?: string | null;
      /** @description Gets or sets item ids of the playlist. */
      Ids?: string[] | null;
      /** @description Gets or sets the playlist users. */
      Users?: components["schemas"]["PlaylistUserPermissions"][] | null;
      /** @description Gets or sets a value indicating whether the playlist is public. */
      IsPublic?: boolean | null;
    };
    /** @description Update existing playlist user dto. Fields set to `null` will not be updated and keep their current values. */
    UpdatePlaylistUserDto: {
      /** @description Gets or sets a value indicating whether the user can edit the playlist. */
      CanEdit?: boolean | null;
    };
    /** @description This is used by the api to get information about a item user data. */
    UpdateUserItemDataDto: {
      /**
       * Format: double
       * @description Gets or sets the rating.
       */
      Rating?: number | null;
      /**
       * Format: double
       * @description Gets or sets the played percentage.
       */
      PlayedPercentage?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the unplayed item count.
       */
      UnplayedItemCount?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the playback position ticks.
       */
      PlaybackPositionTicks?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the play count.
       */
      PlayCount?: number | null;
      /** @description Gets or sets a value indicating whether this instance is favorite. */
      IsFavorite?: boolean | null;
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UpdateUserItemDataDto is likes. */
      Likes?: boolean | null;
      /**
       * Format: date-time
       * @description Gets or sets the last played date.
       */
      LastPlayedDate?: string | null;
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played. */
      Played?: boolean | null;
      /** @description Gets or sets the key. */
      Key?: string | null;
      /** @description Gets or sets the item identifier. */
      ItemId?: string | null;
    };
    /** @description The update user password request body. */
    UpdateUserPassword: {
      /** @description Gets or sets the current sha1-hashed password. */
      CurrentPassword?: string | null;
      /** @description Gets or sets the current plain text password. */
      CurrentPw?: string | null;
      /** @description Gets or sets the new plain text password. */
      NewPw?: string | null;
      /** @description Gets or sets a value indicating whether to reset the password. */
      ResetPassword?: boolean;
    };
    /** @description Upload subtitles dto. */
    UploadSubtitleDto: {
      /** @description Gets or sets the subtitle language. */
      Language: string;
      /** @description Gets or sets the subtitle format. */
      Format: string;
      /** @description Gets or sets a value indicating whether the subtitle is forced. */
      IsForced: boolean;
      /** @description Gets or sets a value indicating whether the subtitle is for hearing impaired. */
      IsHearingImpaired: boolean;
      /** @description Gets or sets the subtitle data. */
      Data: string;
    };
    /** @description Class UserConfiguration. */
    UserConfiguration: {
      /** @description Gets or sets the audio language preference. */
      AudioLanguagePreference?: string | null;
      /** @description Gets or sets a value indicating whether [play default audio track]. */
      PlayDefaultAudioTrack?: boolean;
      /** @description Gets or sets the subtitle language preference. */
      SubtitleLanguagePreference?: string | null;
      DisplayMissingEpisodes?: boolean;
      GroupedFolders?: string[];
      /**
       * @description An enum representing a subtitle playback mode.
       * @enum {unknown}
       */
      SubtitleMode?: "Default" | "Always" | "OnlyForced" | "None" | "Smart";
      DisplayCollectionsView?: boolean;
      EnableLocalPassword?: boolean;
      OrderedViews?: string[];
      LatestItemsExcludes?: string[];
      MyMediaExcludes?: string[];
      HidePlayedInLatest?: boolean;
      RememberAudioSelections?: boolean;
      RememberSubtitleSelections?: boolean;
      EnableNextEpisodeAutoPlay?: boolean;
      /** @description Gets or sets the id of the selected cast receiver. */
      CastReceiverId?: string | null;
    };
    /** @description User data changed message. */
    UserDataChangedMessage: {
      /** @description Class UserDataChangeInfo. */
      Data?: components["schemas"]["UserDataChangeInfo"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default UserDataChanged
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class UserDataChangeInfo. */
    UserDataChangeInfo: {
      /** @description Gets or sets the user id. */
      UserId?: string | null;
      /** @description Gets or sets the user data list. */
      UserDataList?: components["schemas"]["UserItemDataDto"][] | null;
    };
    /** @description User deleted message. */
    UserDeletedMessage: {
      /**
       * Format: uuid
       * @description Gets or sets the data.
       */
      Data?: string;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default UserDeleted
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class UserDto. */
    UserDto: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the server identifier. */
      ServerId?: string | null;
      /**
       * @description Gets or sets the name of the server.
       * This is not used by the server and is for client-side usage only.
       */
      ServerName?: string | null;
      /**
       * Format: uuid
       * @description Gets or sets the id.
       */
      Id?: string;
      /** @description Gets or sets the primary image tag. */
      PrimaryImageTag?: string | null;
      /** @description Gets or sets a value indicating whether this instance has password. */
      HasPassword?: boolean;
      /** @description Gets or sets a value indicating whether this instance has configured password. */
      HasConfiguredPassword?: boolean;
      /**
       * @deprecated
       * @description Gets or sets a value indicating whether this instance has configured easy password.
       */
      HasConfiguredEasyPassword?: boolean;
      /** @description Gets or sets whether async login is enabled or not. */
      EnableAutoLogin?: boolean | null;
      /**
       * Format: date-time
       * @description Gets or sets the last login date.
       */
      LastLoginDate?: string | null;
      /**
       * Format: date-time
       * @description Gets or sets the last activity date.
       */
      LastActivityDate?: string | null;
      /** @description Gets or sets the configuration. */
      Configuration?: components["schemas"]["UserConfiguration"] | null;
      /** @description Gets or sets the policy. */
      Policy?: components["schemas"]["UserPolicy"] | null;
      /**
       * Format: double
       * @description Gets or sets the primary image aspect ratio.
       */
      PrimaryImageAspectRatio?: number | null;
    };
    /** @description Class UserItemDataDto. */
    UserItemDataDto: {
      /**
       * Format: double
       * @description Gets or sets the rating.
       */
      Rating?: number | null;
      /**
       * Format: double
       * @description Gets or sets the played percentage.
       */
      PlayedPercentage?: number | null;
      /**
       * Format: int32
       * @description Gets or sets the unplayed item count.
       */
      UnplayedItemCount?: number | null;
      /**
       * Format: int64
       * @description Gets or sets the playback position ticks.
       */
      PlaybackPositionTicks?: number;
      /**
       * Format: int32
       * @description Gets or sets the play count.
       */
      PlayCount?: number;
      /** @description Gets or sets a value indicating whether this instance is favorite. */
      IsFavorite?: boolean;
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes. */
      Likes?: boolean | null;
      /**
       * Format: date-time
       * @description Gets or sets the last played date.
       */
      LastPlayedDate?: string | null;
      /** @description Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played. */
      Played?: boolean;
      /** @description Gets or sets the key. */
      Key?: string | null;
      /** @description Gets or sets the item identifier. */
      ItemId?: string | null;
    };
    UserPolicy: {
      /** @description Gets or sets a value indicating whether this instance is administrator. */
      IsAdministrator?: boolean;
      /** @description Gets or sets a value indicating whether this instance is hidden. */
      IsHidden?: boolean;
      /**
       * @description Gets or sets a value indicating whether this instance can manage collections.
       * @default false
       */
      EnableCollectionManagement?: boolean;
      /**
       * @description Gets or sets a value indicating whether this instance can manage subtitles.
       * @default false
       */
      EnableSubtitleManagement?: boolean;
      /**
       * @description Gets or sets a value indicating whether this user can manage lyrics.
       * @default false
       */
      EnableLyricManagement?: boolean;
      /** @description Gets or sets a value indicating whether this instance is disabled. */
      IsDisabled?: boolean;
      /**
       * Format: int32
       * @description Gets or sets the max parental rating.
       */
      MaxParentalRating?: number | null;
      BlockedTags?: string[] | null;
      AllowedTags?: string[] | null;
      EnableUserPreferenceAccess?: boolean;
      AccessSchedules?: components["schemas"]["AccessSchedule"][] | null;
      BlockUnratedItems?: components["schemas"]["UnratedItem"][] | null;
      EnableRemoteControlOfOtherUsers?: boolean;
      EnableSharedDeviceControl?: boolean;
      EnableRemoteAccess?: boolean;
      EnableLiveTvManagement?: boolean;
      EnableLiveTvAccess?: boolean;
      EnableMediaPlayback?: boolean;
      EnableAudioPlaybackTranscoding?: boolean;
      EnableVideoPlaybackTranscoding?: boolean;
      EnablePlaybackRemuxing?: boolean;
      ForceRemoteSourceTranscoding?: boolean;
      EnableContentDeletion?: boolean;
      EnableContentDeletionFromFolders?: string[] | null;
      EnableContentDownloading?: boolean;
      /** @description Gets or sets a value indicating whether [enable synchronize]. */
      EnableSyncTranscoding?: boolean;
      EnableMediaConversion?: boolean;
      EnabledDevices?: string[] | null;
      EnableAllDevices?: boolean;
      EnabledChannels?: string[] | null;
      EnableAllChannels?: boolean;
      EnabledFolders?: string[] | null;
      EnableAllFolders?: boolean;
      /** Format: int32 */
      InvalidLoginAttemptCount?: number;
      /** Format: int32 */
      LoginAttemptsBeforeLockout?: number;
      /** Format: int32 */
      MaxActiveSessions?: number;
      EnablePublicSharing?: boolean;
      BlockedMediaFolders?: string[] | null;
      BlockedChannels?: string[] | null;
      /** Format: int32 */
      RemoteClientBitrateLimit?: number;
      AuthenticationProviderId: string;
      PasswordResetProviderId: string;
      /**
       * @description Gets or sets a value indicating what SyncPlay features the user can access.
       * @enum {unknown}
       */
      SyncPlayAccess?: "CreateAndJoinGroups" | "JoinGroups" | "None";
    };
    /** @description User updated message. */
    UserUpdatedMessage: {
      /** @description Class UserDto. */
      Data?: components["schemas"]["UserDto"] | null;
      /**
       * Format: uuid
       * @description Gets or sets the message id.
       */
      MessageId?: string;
      /**
       * @description The different kinds of messages that are used in the WebSocket api.
       * @default UserUpdated
       * @enum {unknown}
       */
      MessageType?: "ForceKeepAlive" | "GeneralCommand" | "UserDataChanged" | "Sessions" | "Play" | "SyncPlayCommand" | "SyncPlayGroupUpdate" | "Playstate" | "RestartRequired" | "ServerShuttingDown" | "ServerRestarting" | "LibraryChanged" | "UserDeleted" | "UserUpdated" | "SeriesTimerCreated" | "TimerCreated" | "SeriesTimerCancelled" | "TimerCancelled" | "RefreshProgress" | "ScheduledTaskEnded" | "PackageInstallationCancelled" | "PackageInstallationFailed" | "PackageInstallationCompleted" | "PackageInstalling" | "PackageUninstalled" | "ActivityLogEntry" | "ScheduledTasksInfo" | "ActivityLogEntryStart" | "ActivityLogEntryStop" | "SessionsStart" | "SessionsStop" | "ScheduledTasksInfoStart" | "ScheduledTasksInfoStop" | "KeepAlive";
    };
    /** @description Class UtcTimeResponse. */
    UtcTimeResponse: {
      /**
       * Format: date-time
       * @description Gets the UTC time when request has been received.
       */
      RequestReceptionTime?: string;
      /**
       * Format: date-time
       * @description Gets the UTC time when response has been sent.
       */
      ResponseTransmissionTime?: string;
    };
    /** @description Validate path object. */
    ValidatePathDto: {
      /** @description Gets or sets a value indicating whether validate if path is writable. */
      ValidateWritable?: boolean;
      /** @description Gets or sets the path. */
      Path?: string | null;
      /** @description Gets or sets is path file. */
      IsFile?: boolean | null;
    };
    /** @description Defines the MediaBrowser.Model.Updates.VersionInfo class. */
    VersionInfo: {
      /** @description Gets or sets the version. */
      version?: string;
      /** @description Gets the version as a System.Version. */
      VersionNumber?: string;
      /** @description Gets or sets the changelog for this version. */
      changelog?: string | null;
      /** @description Gets or sets the ABI that this version was built against. */
      targetAbi?: string | null;
      /** @description Gets or sets the source URL. */
      sourceUrl?: string | null;
      /** @description Gets or sets a checksum for the binary. */
      checksum?: string | null;
      /** @description Gets or sets a timestamp of when the binary was built. */
      timestamp?: string | null;
      /** @description Gets or sets the repository name. */
      repositoryName?: string;
      /** @description Gets or sets the repository url. */
      repositoryUrl?: string;
    };
    /** @enum {string} */
    Video3DFormat: "HalfSideBySide" | "FullSideBySide" | "FullTopAndBottom" | "HalfTopAndBottom" | "MVC";
    /**
     * @description An enum representing video ranges.
     * @enum {string}
     */
    VideoRange: "Unknown" | "SDR" | "HDR";
    /**
     * @description An enum representing types of video ranges.
     * @enum {string}
     */
    VideoRangeType: "Unknown" | "SDR" | "HDR10" | "HLG" | "DOVI" | "DOVIWithHDR10" | "DOVIWithHLG" | "DOVIWithSDR" | "HDR10Plus";
    /**
     * @description Enum VideoType.
     * @enum {string}
     */
    VideoType: "VideoFile" | "Iso" | "Dvd" | "BluRay";
    /** @description Used to hold information about a user's list of configured virtual folders. */
    VirtualFolderInfo: {
      /** @description Gets or sets the name. */
      Name?: string | null;
      /** @description Gets or sets the locations. */
      Locations?: string[] | null;
      /**
       * @description Gets or sets the type of the collection.
       * @enum {unknown|null}
       */
      CollectionType?: "movies" | "tvshows" | "music" | "musicvideos" | "homevideos" | "boxsets" | "books" | "mixed" | null;
      LibraryOptions?: components["schemas"]["LibraryOptions"] | null;
      /** @description Gets or sets the item identifier. */
      ItemId?: string | null;
      /** @description Gets or sets the primary image item identifier. */
      PrimaryImageItemId?: string | null;
      /** Format: double */
      RefreshProgress?: number | null;
      RefreshStatus?: string | null;
    };
    /** @description Provides the MAC address and port for wake-on-LAN functionality. */
    WakeOnLanInfo: {
      /** @description Gets the MAC address of the device. */
      MacAddress?: string | null;
      /**
       * Format: int32
       * @description Gets or sets the wake-on-LAN port.
       */
      Port?: number;
    };
    /** @description Represents the possible websocket types */
    WebSocketMessage: {
      MessageType: "WebSocketMessage";
    } & (Omit<components["schemas"]["InboundWebSocketMessage"], "MessageType"> | Omit<components["schemas"]["OutboundWebSocketMessage"], "MessageType">);
    XbmcMetadataOptions: {
      UserId?: string | null;
      ReleaseDateFormat?: string;
      SaveImagePathsInNfo?: boolean;
      EnablePathSubstitution?: boolean;
      EnableExtraThumbsDuplication?: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Gets activity log entries. */
  GetLogEntries: {
    parameters: {
      query?: {
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. The minimum date. Format = ISO. */
        minDate?: string;
        /** @description Optional. Filter log entries if it has user id, or not. */
        hasUserId?: boolean;
      };
    };
    responses: {
      /** @description Activity log returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ActivityLogEntryQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ActivityLogEntryQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ActivityLogEntryQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get all keys. */
  GetKeys: {
    responses: {
      /** @description Api keys retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["AuthenticationInfoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["AuthenticationInfoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["AuthenticationInfoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Create a new api key. */
  CreateKey: {
    parameters: {
      query: {
        /** @description Name of the app using the authentication key. */
        app: string;
      };
    };
    responses: {
      /** @description Api key created. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Remove an api key. */
  RevokeKey: {
    parameters: {
      path: {
        /** @description The access token to delete. */
        key: string;
      };
    };
    responses: {
      /** @description Api key deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all artists from a given item, folder, or the entire library. */
  GetArtists: {
    parameters: {
      query?: {
        /** @description Optional filter by minimum community rating. */
        minCommunityRating?: number;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Specify additional filters to apply. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. */
        genres?: string[];
        /** @description Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. */
        genreIds?: string[];
        /** @description Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. */
        officialRatings?: string[];
        /** @description Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. */
        tags?: string[];
        /** @description Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. */
        years?: number[];
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person. */
        person?: string;
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person ids. */
        personIds?: string[];
        /** @description Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. */
        personTypes?: string[];
        /** @description Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. */
        studios?: string[];
        /** @description Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. */
        studioIds?: string[];
        /** @description User id. */
        userId?: string;
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. Specify one or more sort orders, comma delimited. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Artists returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an artist by name. */
  GetArtistByName: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description Studio name. */
        name: string;
      };
    };
    responses: {
      /** @description Artist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all album artists from a given item, folder, or the entire library. */
  GetAlbumArtists: {
    parameters: {
      query?: {
        /** @description Optional filter by minimum community rating. */
        minCommunityRating?: number;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Specify additional filters to apply. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. */
        genres?: string[];
        /** @description Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. */
        genreIds?: string[];
        /** @description Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. */
        officialRatings?: string[];
        /** @description Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. */
        tags?: string[];
        /** @description Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. */
        years?: number[];
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person. */
        person?: string;
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person ids. */
        personIds?: string[];
        /** @description Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. */
        personTypes?: string[];
        /** @description Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. */
        studios?: string[];
        /** @description Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. */
        studioIds?: string[];
        /** @description User id. */
        userId?: string;
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. Specify one or more sort orders, comma delimited. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Album artists returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an audio stream. */
  GetAudioStream: {
    parameters: {
      query?: {
        /** @description The audio container. */
        container?: string;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets an audio stream. */
  HeadAudioStream: {
    parameters: {
      query?: {
        /** @description The audio container. */
        container?: string;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets an audio stream. */
  GetAudioStreamByContainer: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamporphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The audio container. */
        container: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets an audio stream. */
  HeadAudioStreamByContainer: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamporphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The audio container. */
        container: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets branding configuration. */
  GetBrandingOptions: {
    responses: {
      /** @description Branding configuration returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BrandingOptions"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BrandingOptions"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BrandingOptions"];
        };
      };
    };
  };
  /** Gets branding css. */
  GetBrandingCss: {
    responses: {
      /** @description Branding css returned. */
      200: {
        content: {
          "text/css": string;
          "application/json": string;
          "application/json; profile=\"CamelCase\"": string;
          "application/json; profile=\"PascalCase\"": string;
        };
      };
      /** @description No branding css configured. */
      204: {
        content: never;
      };
    };
  };
  /** Gets branding css. */
  GetBrandingCss_2: {
    responses: {
      /** @description Branding css returned. */
      200: {
        content: {
          "text/css": string;
          "application/json": string;
          "application/json; profile=\"CamelCase\"": string;
          "application/json; profile=\"PascalCase\"": string;
        };
      };
      /** @description No branding css configured. */
      204: {
        content: never;
      };
    };
  };
  /** Gets available channels. */
  GetChannels: {
    parameters: {
      query?: {
        /** @description User Id to filter by. Use System.Guid.Empty to not filter by user. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Filter by channels that support getting latest items. */
        supportsLatestItems?: boolean;
        /** @description Optional. Filter by channels that support media deletion. */
        supportsMediaDeletion?: boolean;
        /** @description Optional. Filter by channels that are favorite. */
        isFavorite?: boolean;
      };
    };
    responses: {
      /** @description Channels returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get channel features. */
  GetChannelFeatures: {
    parameters: {
      path: {
        /** @description Channel id. */
        channelId: string;
      };
    };
    responses: {
      /** @description Channel features returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelFeatures"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ChannelFeatures"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ChannelFeatures"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get channel items. */
  GetChannelItems: {
    parameters: {
      query?: {
        /** @description Optional. Folder Id. */
        folderId?: string;
        /** @description Optional. User Id. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Optional. Specify additional filters to apply. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description Channel Id. */
        channelId: string;
      };
    };
    responses: {
      /** @description Channel items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get all channel features. */
  GetAllChannelFeatures: {
    responses: {
      /** @description All channel features returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelFeatures"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ChannelFeatures"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ChannelFeatures"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets latest channel items. */
  GetLatestChannelItems: {
    parameters: {
      query?: {
        /** @description Optional. User Id. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional filters to apply. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Specify one or more channel id's, comma delimited. */
        channelIds?: string[];
      };
    };
    responses: {
      /** @description Latest channel items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Upload a document. */
  LogFile: {
    requestBody?: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description Document saved. */
      200: {
        content: {
          "application/json": components["schemas"]["ClientLogDocumentResponseDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ClientLogDocumentResponseDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ClientLogDocumentResponseDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Event logging disabled. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Upload size too large. */
      413: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates a new collection. */
  CreateCollection: {
    parameters: {
      query?: {
        /** @description The name of the collection. */
        name?: string;
        /** @description Item Ids to add to the collection. */
        ids?: string[];
        /** @description Optional. Create the collection within a specific folder. */
        parentId?: string;
        /** @description Whether or not to lock the new collection. */
        isLocked?: boolean;
      };
    };
    responses: {
      /** @description Collection created. */
      200: {
        content: {
          "application/json": components["schemas"]["CollectionCreationResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["CollectionCreationResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["CollectionCreationResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Adds items to a collection. */
  AddToCollection: {
    parameters: {
      query: {
        /** @description Item ids, comma delimited. */
        ids: string[];
      };
      path: {
        /** @description The collection id. */
        collectionId: string;
      };
    };
    responses: {
      /** @description Items added to collection. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Removes items from a collection. */
  RemoveFromCollection: {
    parameters: {
      query: {
        /** @description Item ids, comma delimited. */
        ids: string[];
      };
      path: {
        /** @description The collection id. */
        collectionId: string;
      };
    };
    responses: {
      /** @description Items removed from collection. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets application configuration. */
  GetConfiguration: {
    responses: {
      /** @description Application configuration returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ServerConfiguration"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ServerConfiguration"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ServerConfiguration"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates application configuration. */
  UpdateConfiguration: {
    /** @description Configuration. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ServerConfiguration"];
        "text/json": components["schemas"]["ServerConfiguration"];
        "application/*+json": components["schemas"]["ServerConfiguration"];
      };
    };
    responses: {
      /** @description Configuration updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a named configuration. */
  GetNamedConfiguration: {
    parameters: {
      path: {
        /** @description Configuration key. */
        key: string;
      };
    };
    responses: {
      /** @description Configuration returned. */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates named configuration. */
  UpdateNamedConfiguration: {
    parameters: {
      path: {
        /** @description Configuration key. */
        key: string;
      };
    };
    /** @description Configuration. */
    requestBody: {
      content: {
        "application/json": unknown;
        "text/json": unknown;
        "application/*+json": unknown;
      };
    };
    responses: {
      /** @description Named configuration updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a default MetadataOptions object. */
  GetDefaultMetadataOptions: {
    responses: {
      /** @description Metadata options returned. */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataOptions"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["MetadataOptions"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["MetadataOptions"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a dashboard configuration page. */
  GetDashboardConfigurationPage: {
    parameters: {
      query?: {
        /** @description The name of the page. */
        name?: string;
      };
    };
    responses: {
      /** @description ConfigurationPage returned. */
      200: {
        content: {
          "text/html": string;
          "application/x-javascript": string;
        };
      };
      /** @description Plugin configuration page not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the configuration pages. */
  GetConfigurationPages: {
    parameters: {
      query?: {
        /** @description Whether to enable in the main menu. */
        enableInMainMenu?: boolean;
      };
    };
    responses: {
      /** @description ConfigurationPages returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigurationPageInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ConfigurationPageInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ConfigurationPageInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Server still loading. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get Devices. */
  GetDevices: {
    parameters: {
      query?: {
        /** @description Gets or sets the user identifier. */
        userId?: string;
      };
    };
    responses: {
      /** @description Devices retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["DeviceInfoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["DeviceInfoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["DeviceInfoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Deletes a device. */
  DeleteDevice: {
    parameters: {
      query: {
        /** @description Device Id. */
        id: string;
      };
    };
    responses: {
      /** @description Device deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Device not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get info for a device. */
  GetDeviceInfo: {
    parameters: {
      query: {
        /** @description Device Id. */
        id: string;
      };
    };
    responses: {
      /** @description Device info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["DeviceInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["DeviceInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["DeviceInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Device not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get options for a device. */
  GetDeviceOptions: {
    parameters: {
      query: {
        /** @description Device Id. */
        id: string;
      };
    };
    responses: {
      /** @description Device options retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["DeviceOptions"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["DeviceOptions"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["DeviceOptions"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Device not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Update device options. */
  UpdateDeviceOptions: {
    parameters: {
      query: {
        /** @description Device Id. */
        id: string;
      };
    };
    /** @description Device Options. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceOptionsDto"];
        "text/json": components["schemas"]["DeviceOptionsDto"];
        "application/*+json": components["schemas"]["DeviceOptionsDto"];
      };
    };
    responses: {
      /** @description Device options updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get Display Preferences. */
  GetDisplayPreferences: {
    parameters: {
      query: {
        /** @description User id. */
        userId?: string;
        /** @description Client. */
        client: string;
      };
      path: {
        /** @description Display preferences id. */
        displayPreferencesId: string;
      };
    };
    responses: {
      /** @description Display preferences retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["DisplayPreferencesDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["DisplayPreferencesDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["DisplayPreferencesDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Update Display Preferences. */
  UpdateDisplayPreferences: {
    parameters: {
      query: {
        /** @description User Id. */
        userId?: string;
        /** @description Client. */
        client: string;
      };
      path: {
        /** @description Display preferences id. */
        displayPreferencesId: string;
      };
    };
    /** @description New Display Preferences object. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DisplayPreferencesDto"];
        "text/json": components["schemas"]["DisplayPreferencesDto"];
        "application/*+json": components["schemas"]["DisplayPreferencesDto"];
      };
    };
    responses: {
      /** @description Display preferences updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a video stream using HTTP live streaming. */
  GetHlsAudioSegment: {
    parameters: {
      query: {
        /** @description The position of the requested segment in ticks. */
        runtimeTicks: number;
        /** @description The length of the requested segment in ticks. */
        actualSegmentLengthTicks: number;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The playlist id. */
        playlistId: string;
        /** @description The segment id. */
        segmentId: number;
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an audio stream using HTTP live streaming. */
  GetVariantHlsAudioPlaylist: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vpx, wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an audio hls playlist stream. */
  GetMasterHlsAudioPlaylist: {
    parameters: {
      query: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
        /** @description Enable adaptive bitrate streaming. */
        enableAdaptiveBitrateStreaming?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an audio hls playlist stream. */
  HeadMasterHlsAudioPlaylist: {
    parameters: {
      query: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
        /** @description Enable adaptive bitrate streaming. */
        enableAdaptiveBitrateStreaming?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a video stream using HTTP live streaming. */
  GetHlsVideoSegment: {
    parameters: {
      query: {
        /** @description The position of the requested segment in ticks. */
        runtimeTicks: number;
        /** @description The length of the requested segment in ticks. */
        actualSegmentLengthTicks: number;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The desired segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The playlist id. */
        playlistId: string;
        /** @description The segment id. */
        segmentId: number;
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a hls live stream. */
  GetLiveHlsStream: {
    parameters: {
      query?: {
        /** @description The audio container. */
        container?: string;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
        /** @description Optional. The max width. */
        maxWidth?: number;
        /** @description Optional. The max height. */
        maxHeight?: number;
        /** @description Optional. Whether to enable subtitles in the manifest. */
        enableSubtitlesInManifest?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Hls live stream retrieved. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a video stream using HTTP live streaming. */
  GetVariantHlsVideoPlaylist: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a video hls playlist stream. */
  GetMasterHlsVideoPlaylist: {
    parameters: {
      query: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
        /** @description Enable adaptive bitrate streaming. */
        enableAdaptiveBitrateStreaming?: boolean;
        /** @description Enable trickplay image playlists being added to master playlist. */
        enableTrickplay?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a video hls playlist stream. */
  HeadMasterHlsVideoPlaylist: {
    parameters: {
      query: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
        /** @description Enable adaptive bitrate streaming. */
        enableAdaptiveBitrateStreaming?: boolean;
        /** @description Enable trickplay image playlists being added to master playlist. */
        enableTrickplay?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get Default directory browser. */
  GetDefaultDirectoryBrowser: {
    responses: {
      /** @description Default directory browser returned. */
      200: {
        content: {
          "application/json": components["schemas"]["DefaultDirectoryBrowserInfoDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["DefaultDirectoryBrowserInfoDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["DefaultDirectoryBrowserInfoDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the contents of a given directory in the file system. */
  GetDirectoryContents: {
    parameters: {
      query: {
        /** @description The path. */
        path: string;
        /** @description An optional filter to include or exclude files from the results. true/false. */
        includeFiles?: boolean;
        /** @description An optional filter to include or exclude folders from the results. true/false. */
        includeDirectories?: boolean;
      };
    };
    responses: {
      /** @description Directory contents returned. */
      200: {
        content: {
          "application/json": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["FileSystemEntryInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available drives from the server's file system. */
  GetDrives: {
    responses: {
      /** @description List of entries returned. */
      200: {
        content: {
          "application/json": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["FileSystemEntryInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /**
   * Gets network paths.
   * @deprecated
   */
  GetNetworkShares: {
    responses: {
      /** @description Empty array returned. */
      200: {
        content: {
          "application/json": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["FileSystemEntryInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["FileSystemEntryInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the parent path of a given path. */
  GetParentPath: {
    parameters: {
      query: {
        /** @description The path. */
        path: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": string;
          "application/json; profile=\"CamelCase\"": string;
          "application/json; profile=\"PascalCase\"": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Validates path. */
  ValidatePath: {
    /** @description Validate request object. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ValidatePathDto"];
        "text/json": components["schemas"]["ValidatePathDto"];
        "application/*+json": components["schemas"]["ValidatePathDto"];
      };
    };
    responses: {
      /** @description Path validated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Path not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets legacy query filters. */
  GetQueryFiltersLegacy: {
    parameters: {
      query?: {
        /** @description Optional. User id. */
        userId?: string;
        /** @description Optional. Parent id. */
        parentId?: string;
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
      };
    };
    responses: {
      /** @description Legacy filters retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["QueryFiltersLegacy"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["QueryFiltersLegacy"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["QueryFiltersLegacy"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets query filters. */
  GetQueryFilters: {
    parameters: {
      query?: {
        /** @description Optional. User id. */
        userId?: string;
        /** @description Optional. Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Is item airing. */
        isAiring?: boolean;
        /** @description Optional. Is item movie. */
        isMovie?: boolean;
        /** @description Optional. Is item sports. */
        isSports?: boolean;
        /** @description Optional. Is item kids. */
        isKids?: boolean;
        /** @description Optional. Is item news. */
        isNews?: boolean;
        /** @description Optional. Is item series. */
        isSeries?: boolean;
        /** @description Optional. Search recursive. */
        recursive?: boolean;
      };
    };
    responses: {
      /** @description Filters retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["QueryFilters"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["QueryFilters"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["QueryFilters"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all genres from a given item, folder, or the entire library. */
  GetGenres: {
    parameters: {
      query?: {
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description The search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description User id. */
        userId?: string;
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. Specify one or more sort orders, comma delimited. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Genres returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a genre, by name. */
  GetGenre: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
      path: {
        /** @description The genre name. */
        genreName: string;
      };
    };
    responses: {
      /** @description Genres returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the specified audio segment for an audio item. */
  GetHlsAudioSegmentLegacyAac: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The segment id. */
        segmentId: string;
      };
    };
    responses: {
      /** @description Hls audio segment returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets the specified audio segment for an audio item. */
  GetHlsAudioSegmentLegacyMp3: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The segment id. */
        segmentId: string;
      };
    };
    responses: {
      /** @description Hls audio segment returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
    };
  };
  /** Gets a hls video segment. */
  GetHlsVideoSegmentLegacy: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The playlist id. */
        playlistId: string;
        /** @description The segment id. */
        segmentId: string;
        /** @description The segment container. */
        segmentContainer: string;
      };
    };
    responses: {
      /** @description Hls video segment returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
      /** @description Hls segment not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a hls video playlist. */
  GetHlsPlaylistLegacy: {
    parameters: {
      path: {
        /** @description The video id. */
        itemId: string;
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    responses: {
      /** @description Hls video playlist returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Stops an active encoding. */
  StopEncodingProcess: {
    parameters: {
      query: {
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId: string;
        /** @description The play session id. */
        playSessionId: string;
      };
    };
    responses: {
      /** @description Encoding stopped successfully. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get artist image by name. */
  GetArtistImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Artist name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get artist image by name. */
  HeadArtistImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Artist name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Generates or gets the splashscreen. */
  GetSplashscreen: {
    parameters: {
      query?: {
        /** @description Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Blur image. */
        blur?: number;
        /** @description Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Quality setting, from 0-100. */
        quality?: number;
      };
    };
    responses: {
      /** @description Splashscreen returned successfully. */
      200: {
        content: {
          "image/*": string;
        };
      };
    };
  };
  /**
   * Uploads a custom splashscreen.
   * The body is expected to the image contents base64 encoded.
   */
  UploadCustomSplashscreen: {
    requestBody?: {
      content: {
        "image/*": string;
      };
    };
    responses: {
      /** @description Successfully uploaded new splashscreen. */
      204: {
        content: never;
      };
      /** @description Error reading MimeType from uploaded image. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to upload splashscreen.. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Delete a custom splashscreen. */
  DeleteCustomSplashscreen: {
    responses: {
      /** @description Successfully deleted the custom splashscreen. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to delete splashscreen.. */
      403: {
        content: never;
      };
    };
  };
  /** Get genre image by name. */
  GetGenreImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get genre image by name. */
  HeadGenreImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get genre image by name. */
  GetGenreImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get genre image by name. */
  HeadGenreImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get item image infos. */
  GetItemImageInfos: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item images returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ImageInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ImageInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ImageInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  GetItemImage: {
    parameters: {
      query?: {
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Set item image. */
  SetItemImage: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    requestBody?: {
      content: {
        "image/*": string;
      };
    };
    responses: {
      /** @description Image saved. */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Delete an item's image. */
  DeleteItemImage: {
    parameters: {
      query?: {
        /** @description The image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  HeadItemImage: {
    parameters: {
      query?: {
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  GetItemImageByIndex: {
    parameters: {
      query?: {
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Set item image. */
  SetItemImageByIndex: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description (Unused) Image index. */
        imageIndex: number;
      };
    };
    requestBody?: {
      content: {
        "image/*": string;
      };
    };
    responses: {
      /** @description Image saved. */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Delete an item's image. */
  DeleteItemImageByIndex: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description The image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  HeadItemImageByIndex: {
    parameters: {
      query?: {
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  GetItemImage2: {
    parameters: {
      query?: {
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description The maximum image width to return. */
        maxWidth: number;
        /** @description The maximum image height to return. */
        maxHeight: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount: number;
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the item's image. */
  HeadItemImage2: {
    parameters: {
      query?: {
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description The maximum image width to return. */
        maxWidth: number;
        /** @description The maximum image height to return. */
        maxHeight: number;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount: number;
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Updates the index for an item image. */
  UpdateItemImageIndex: {
    parameters: {
      query: {
        /** @description New image index. */
        newIndex: number;
      };
      path: {
        /** @description Item id. */
        itemId: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Old image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image index updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get music genre image by name. */
  GetMusicGenreImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Music genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get music genre image by name. */
  HeadMusicGenreImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Music genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get music genre image by name. */
  GetMusicGenreImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Music genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get music genre image by name. */
  HeadMusicGenreImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Music genre name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get person image by name. */
  GetPersonImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Person name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get person image by name. */
  HeadPersonImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Person name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get person image by name. */
  GetPersonImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Person name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get person image by name. */
  HeadPersonImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Person name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get studio image by name. */
  GetStudioImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Studio name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get studio image by name. */
  HeadStudioImage: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
      path: {
        /** @description Studio name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get studio image by name. */
  GetStudioImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Studio name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get studio image by name. */
  HeadStudioImageByIndex: {
    parameters: {
      query?: {
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
      };
      path: {
        /** @description Studio name. */
        name: string;
        /** @description Image type. */
        imageType: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Image index. */
        imageIndex: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get user profile image. */
  GetUserImage: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description User id not provided. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Sets the user image. */
  PostUserImage: {
    parameters: {
      query?: {
        /** @description User Id. */
        userId?: string;
      };
    };
    requestBody?: {
      content: {
        "image/*": string;
      };
    };
    responses: {
      /** @description Image updated. */
      204: {
        content: never;
      };
      /** @description Bad Request */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to delete the image. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Delete the user's image. */
  DeleteUserImage: {
    parameters: {
      query?: {
        /** @description User Id. */
        userId?: string;
      };
    };
    responses: {
      /** @description Image deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to delete the image. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get user profile image. */
  HeadUserImage: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Optional. Supply the cache tag from the item object to receive strong caching headers. */
        tag?: string;
        /** @description Determines the output format of the image - original,gif,jpg,png. */
        format?: "Bmp" | "Gif" | "Jpg" | "Png" | "Webp" | "Svg";
        /** @description The maximum image width to return. */
        maxWidth?: number;
        /** @description The maximum image height to return. */
        maxHeight?: number;
        /** @description Optional. Percent to render for the percent played overlay. */
        percentPlayed?: number;
        /** @description Optional. Unplayed count overlay to render. */
        unplayedCount?: number;
        /** @description The fixed image width to return. */
        width?: number;
        /** @description The fixed image height to return. */
        height?: number;
        /** @description Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases. */
        quality?: number;
        /** @description Width of box to fill. */
        fillWidth?: number;
        /** @description Height of box to fill. */
        fillHeight?: number;
        /** @description Optional. Blur image. */
        blur?: number;
        /** @description Optional. Apply a background color for transparent images. */
        backgroundColor?: string;
        /** @description Optional. Apply a foreground layer on top of the image. */
        foregroundLayer?: string;
        /** @description Image index. */
        imageIndex?: number;
      };
    };
    responses: {
      /** @description Image stream returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description User id not provided. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given album. */
  GetInstantMixFromAlbum: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given artist. */
  GetInstantMixFromArtists: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Creates an instant playlist based on a given artist.
   * @deprecated
   */
  GetInstantMixFromArtists2: {
    parameters: {
      query: {
        /** @description The item id. */
        id: string;
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given item. */
  GetInstantMixFromItem: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given genre. */
  GetInstantMixFromMusicGenreByName: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The genre name. */
        name: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Creates an instant playlist based on a given genre. */
  GetInstantMixFromMusicGenreById: {
    parameters: {
      query: {
        /** @description The item id. */
        id: string;
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given playlist. */
  GetInstantMixFromPlaylist: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Creates an instant playlist based on a given song. */
  GetInstantMixFromSong: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Instant playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get the item's external id info. */
  GetExternalIdInfos: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description External id info retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ExternalIdInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ExternalIdInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ExternalIdInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Applies search criteria to an item and refreshes metadata. */
  ApplySearchCriteria: {
    parameters: {
      query?: {
        /** @description Optional. Whether or not to replace all images. Default: True. */
        replaceAllImages?: boolean;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    /** @description The remote search result. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RemoteSearchResult"];
        "text/json": components["schemas"]["RemoteSearchResult"];
        "application/*+json": components["schemas"]["RemoteSearchResult"];
      };
    };
    responses: {
      /** @description Item metadata refreshed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get book remote search. */
  GetBookRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BookInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["BookInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["BookInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Book remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get box set remote search. */
  GetBoxSetRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BoxSetInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["BoxSetInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["BoxSetInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Box set remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get movie remote search. */
  GetMovieRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MovieInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["MovieInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["MovieInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Movie remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get music album remote search. */
  GetMusicAlbumRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AlbumInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["AlbumInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["AlbumInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Music album remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get music artist remote search. */
  GetMusicArtistRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ArtistInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["ArtistInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["ArtistInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Music artist remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get music video remote search. */
  GetMusicVideoRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MusicVideoInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["MusicVideoInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["MusicVideoInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Music video remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get person remote search. */
  GetPersonRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PersonLookupInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["PersonLookupInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["PersonLookupInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Person remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get series remote search. */
  GetSeriesRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SeriesInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["SeriesInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["SeriesInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Series remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get trailer remote search. */
  GetTrailerRemoteSearchResults: {
    /** @description Remote search query. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["TrailerInfoRemoteSearchQuery"];
        "text/json": components["schemas"]["TrailerInfoRemoteSearchQuery"];
        "application/*+json": components["schemas"]["TrailerInfoRemoteSearchQuery"];
      };
    };
    responses: {
      /** @description Trailer remote search executed. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSearchResult"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSearchResult"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Refreshes metadata for an item. */
  RefreshItem: {
    parameters: {
      query?: {
        /** @description (Optional) Specifies the metadata refresh mode. */
        metadataRefreshMode?: "None" | "ValidationOnly" | "Default" | "FullRefresh";
        /** @description (Optional) Specifies the image refresh mode. */
        imageRefreshMode?: "None" | "ValidationOnly" | "Default" | "FullRefresh";
        /** @description (Optional) Determines if metadata should be replaced. Only applicable if mode is FullRefresh. */
        replaceAllMetadata?: boolean;
        /** @description (Optional) Determines if images should be replaced. Only applicable if mode is FullRefresh. */
        replaceAllImages?: boolean;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item metadata refresh queued. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item to refresh not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets items based on a query. */
  GetItems: {
    parameters: {
      query?: {
        /** @description The user id supplied as query parameter; this is required when not using an API key. */
        userId?: string;
        /** @description Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). */
        maxOfficialRating?: string;
        /** @description Optional filter by items with theme songs. */
        hasThemeSong?: boolean;
        /** @description Optional filter by items with theme videos. */
        hasThemeVideo?: boolean;
        /** @description Optional filter by items with subtitles. */
        hasSubtitles?: boolean;
        /** @description Optional filter by items with special features. */
        hasSpecialFeature?: boolean;
        /** @description Optional filter by items with trailers. */
        hasTrailer?: boolean;
        /** @description Optional. Return items that are siblings of a supplied item. */
        adjacentTo?: string;
        /** @description Optional filter by parent index number. */
        parentIndexNumber?: number;
        /** @description Optional filter by items that have or do not have a parental rating. */
        hasParentalRating?: boolean;
        /** @description Optional filter by items that are HD or not. */
        isHd?: boolean;
        /** @description Optional filter by items that are 4K or not. */
        is4K?: boolean;
        /** @description Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited. */
        locationTypes?: components["schemas"]["LocationType"][];
        /** @description Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited. */
        excludeLocationTypes?: components["schemas"]["LocationType"][];
        /** @description Optional filter by items that are missing episodes or not. */
        isMissing?: boolean;
        /** @description Optional filter by items that are unaired episodes or not. */
        isUnaired?: boolean;
        /** @description Optional filter by minimum community rating. */
        minCommunityRating?: number;
        /** @description Optional filter by minimum critic rating. */
        minCriticRating?: number;
        /** @description Optional. The minimum premiere date. Format = ISO. */
        minPremiereDate?: string;
        /** @description Optional. The minimum last saved date. Format = ISO. */
        minDateLastSaved?: string;
        /** @description Optional. The minimum last saved date for the current user. Format = ISO. */
        minDateLastSavedForUser?: string;
        /** @description Optional. The maximum premiere date. Format = ISO. */
        maxPremiereDate?: string;
        /** @description Optional filter by items that have an overview or not. */
        hasOverview?: boolean;
        /** @description Optional filter by items that have an IMDb id or not. */
        hasImdbId?: boolean;
        /** @description Optional filter by items that have a TMDb id or not. */
        hasTmdbId?: boolean;
        /** @description Optional filter by items that have a TVDb id or not. */
        hasTvdbId?: boolean;
        /** @description Optional filter for live tv movies. */
        isMovie?: boolean;
        /** @description Optional filter for live tv series. */
        isSeries?: boolean;
        /** @description Optional filter for live tv news. */
        isNews?: boolean;
        /** @description Optional filter for live tv kids. */
        isKids?: boolean;
        /** @description Optional filter for live tv sports. */
        isSports?: boolean;
        /** @description Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited. */
        excludeItemIds?: string[];
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description When searching within folders, this determines whether or not the search will be recursive. true/false. */
        recursive?: boolean;
        /** @description Optional. Filter based on a search term. */
        searchTerm?: string;
        /** @description Sort Order - Ascending, Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. */
        imageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Optional filter by items that are played, or not. */
        isPlayed?: boolean;
        /** @description Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. */
        genres?: string[];
        /** @description Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. */
        officialRatings?: string[];
        /** @description Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. */
        tags?: string[];
        /** @description Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. */
        years?: number[];
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person. */
        person?: string;
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person id. */
        personIds?: string[];
        /** @description Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. */
        personTypes?: string[];
        /** @description Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. */
        studios?: string[];
        /** @description Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited. */
        artists?: string[];
        /** @description Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited. */
        excludeArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified artist id. */
        artistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified album artist id. */
        albumArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified contributing artist id. */
        contributingArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited. */
        albums?: string[];
        /** @description Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited. */
        albumIds?: string[];
        /** @description Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited. */
        ids?: string[];
        /** @description Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited. */
        videoTypes?: components["schemas"]["VideoType"][];
        /** @description Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). */
        minOfficialRating?: string;
        /** @description Optional filter by items that are locked. */
        isLocked?: boolean;
        /** @description Optional filter by items that are placeholders. */
        isPlaceHolder?: boolean;
        /** @description Optional filter by items that have official ratings. */
        hasOfficialRating?: boolean;
        /** @description Whether or not to hide items behind their boxsets. */
        collapseBoxSetItems?: boolean;
        /** @description Optional. Filter by the minimum width of the item. */
        minWidth?: number;
        /** @description Optional. Filter by the minimum height of the item. */
        minHeight?: number;
        /** @description Optional. Filter by the maximum width of the item. */
        maxWidth?: number;
        /** @description Optional. Filter by the maximum height of the item. */
        maxHeight?: number;
        /** @description Optional filter by items that are 3D, or not. */
        is3D?: boolean;
        /** @description Optional filter by Series Status. Allows multiple, comma delimited. */
        seriesStatus?: components["schemas"]["SeriesStatus"][];
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. */
        studioIds?: string[];
        /** @description Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. */
        genreIds?: string[];
        /** @description Optional. Enable the total record count. */
        enableTotalRecordCount?: boolean;
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Deletes items from the library and filesystem. */
  DeleteItems: {
    parameters: {
      query?: {
        /** @description The item ids. */
        ids?: string[];
      };
    };
    responses: {
      /** @description Items deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized access. */
      401: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get Item User Data. */
  GetItemUserData: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description return item user data. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item is not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Update Item User Data. */
  UpdateItemUserData: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    /** @description New user data object. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserItemDataDto"];
        "text/json": components["schemas"]["UpdateUserItemDataDto"];
        "application/*+json": components["schemas"]["UpdateUserItemDataDto"];
      };
    };
    responses: {
      /** @description return updated user item data. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item is not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets items based on a query. */
  GetResumeItems: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
        /** @description The start index. */
        startIndex?: number;
        /** @description The item limit. */
        limit?: number;
        /** @description The search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Enable the total record count. */
        enableTotalRecordCount?: boolean;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Whether to exclude the currently active sessions. */
        excludeActiveSessions?: boolean;
      };
    };
    responses: {
      /** @description Items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an item from a user's library. */
  GetItem: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates an item. */
  UpdateItem: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    /** @description The new item properties. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BaseItemDto"];
        "text/json": components["schemas"]["BaseItemDto"];
        "application/*+json": components["schemas"]["BaseItemDto"];
      };
    };
    responses: {
      /** @description Item updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Deletes an item from the library and filesystem. */
  DeleteItem: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized access. */
      401: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Updates an item's content type. */
  UpdateItemContentType: {
    parameters: {
      query?: {
        /** @description The content type of the item. */
        contentType?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item content type updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets metadata editor info for an item. */
  GetMetadataEditorInfo: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item metadata editor returned. */
      200: {
        content: {
          "application/json": components["schemas"]["MetadataEditorInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["MetadataEditorInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["MetadataEditorInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets similar items. */
  GetSimilarAlbums: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets similar items. */
  GetSimilarArtists: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all parents of an item. */
  GetAncestors: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item parents returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Gets critic review for an item.
   * @deprecated
   */
  GetCriticReviews: {
    parameters: {
      path: {
        itemId: string;
      };
    };
    responses: {
      /** @description Critic reviews returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Downloads item media. */
  GetDownload: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Media downloaded. */
      200: {
        content: {
          "video/*": string;
          "audio/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get the original file of an item. */
  GetFile: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description File stream returned. */
      200: {
        content: {
          "video/*": string;
          "audio/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets similar items. */
  GetSimilarItems: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get theme songs and videos for an item. */
  GetThemeMedia: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. Determines whether or not parent items should be searched for theme media. */
        inheritFromParent?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Theme songs and videos returned. */
      200: {
        content: {
          "application/json": components["schemas"]["AllThemeMediaResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["AllThemeMediaResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["AllThemeMediaResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: never;
      };
    };
  };
  /** Get theme songs for an item. */
  GetThemeSongs: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. Determines whether or not parent items should be searched for theme media. */
        inheritFromParent?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Theme songs returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ThemeMediaResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ThemeMediaResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ThemeMediaResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get theme videos for an item. */
  GetThemeVideos: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. Determines whether or not parent items should be searched for theme media. */
        inheritFromParent?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Theme videos returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ThemeMediaResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ThemeMediaResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ThemeMediaResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get item counts. */
  GetItemCounts: {
    parameters: {
      query?: {
        /** @description Optional. Get counts from a specific user's library. */
        userId?: string;
        /** @description Optional. Get counts of favorite items. */
        isFavorite?: boolean;
      };
    };
    responses: {
      /** @description Item counts returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ItemCounts"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ItemCounts"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ItemCounts"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the library options info. */
  GetLibraryOptionsInfo: {
    parameters: {
      query?: {
        /** @description Library content type. */
        libraryContentType?: "unknown" | "movies" | "tvshows" | "music" | "musicvideos" | "trailers" | "homevideos" | "boxsets" | "books" | "photos" | "livetv" | "playlists" | "folders";
        /** @description Whether this is a new library. */
        isNewLibrary?: boolean;
      };
    };
    responses: {
      /** @description Library options info returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LibraryOptionsResultDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LibraryOptionsResultDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LibraryOptionsResultDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that new movies have been added by an external source. */
  PostUpdatedMedia: {
    /** @description The update paths. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MediaUpdateInfoDto"];
        "text/json": components["schemas"]["MediaUpdateInfoDto"];
        "application/*+json": components["schemas"]["MediaUpdateInfoDto"];
      };
    };
    responses: {
      /** @description Report success. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all user media folders. */
  GetMediaFolders: {
    parameters: {
      query?: {
        /** @description Optional. Filter by folders that are marked hidden, or not. */
        isHidden?: boolean;
      };
    };
    responses: {
      /** @description Media folders returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that new movies have been added by an external source. */
  PostAddedMovies: {
    parameters: {
      query?: {
        /** @description The tmdbId. */
        tmdbId?: string;
        /** @description The imdbId. */
        imdbId?: string;
      };
    };
    responses: {
      /** @description Report success. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that new movies have been added by an external source. */
  PostUpdatedMovies: {
    parameters: {
      query?: {
        /** @description The tmdbId. */
        tmdbId?: string;
        /** @description The imdbId. */
        imdbId?: string;
      };
    };
    responses: {
      /** @description Report success. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a list of physical paths from virtual folders. */
  GetPhysicalPaths: {
    responses: {
      /** @description Physical paths returned. */
      200: {
        content: {
          "application/json": string[];
          "application/json; profile=\"CamelCase\"": string[];
          "application/json; profile=\"PascalCase\"": string[];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Starts a library scan. */
  RefreshLibrary: {
    responses: {
      /** @description Library scan started. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that new episodes of a series have been added by an external source. */
  PostAddedSeries: {
    parameters: {
      query?: {
        /** @description The tvdbId. */
        tvdbId?: string;
      };
    };
    responses: {
      /** @description Report success. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that new episodes of a series have been added by an external source. */
  PostUpdatedSeries: {
    parameters: {
      query?: {
        /** @description The tvdbId. */
        tvdbId?: string;
      };
    };
    responses: {
      /** @description Report success. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets similar items. */
  GetSimilarMovies: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets similar items. */
  GetSimilarShows: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets similar items. */
  GetSimilarTrailers: {
    parameters: {
      query?: {
        /** @description Exclude artist ids. */
        excludeArtistIds?: string[];
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Similar items returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all virtual folders. */
  GetVirtualFolders: {
    responses: {
      /** @description Virtual folders retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["VirtualFolderInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["VirtualFolderInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["VirtualFolderInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Adds a virtual folder. */
  AddVirtualFolder: {
    parameters: {
      query?: {
        /** @description The name of the virtual folder. */
        name?: string;
        /** @description The type of the collection. */
        collectionType?: "movies" | "tvshows" | "music" | "musicvideos" | "homevideos" | "boxsets" | "books" | "mixed";
        /** @description The paths of the virtual folder. */
        paths?: string[];
        /** @description Whether to refresh the library. */
        refreshLibrary?: boolean;
      };
    };
    /** @description The library options. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["AddVirtualFolderDto"];
        "text/json": components["schemas"]["AddVirtualFolderDto"];
        "application/*+json": components["schemas"]["AddVirtualFolderDto"];
      };
    };
    responses: {
      /** @description Folder added. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Removes a virtual folder. */
  RemoveVirtualFolder: {
    parameters: {
      query?: {
        /** @description The name of the folder. */
        name?: string;
        /** @description Whether to refresh the library. */
        refreshLibrary?: boolean;
      };
    };
    responses: {
      /** @description Folder removed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Update library options. */
  UpdateLibraryOptions: {
    /** @description The library name and options. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["UpdateLibraryOptionsDto"];
        "text/json": components["schemas"]["UpdateLibraryOptionsDto"];
        "application/*+json": components["schemas"]["UpdateLibraryOptionsDto"];
      };
    };
    responses: {
      /** @description Library updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Renames a virtual folder. */
  RenameVirtualFolder: {
    parameters: {
      query?: {
        /** @description The name of the virtual folder. */
        name?: string;
        /** @description The new name. */
        newName?: string;
        /** @description Whether to refresh the library. */
        refreshLibrary?: boolean;
      };
    };
    responses: {
      /** @description Folder renamed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Library doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Library already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Add a media path to a library. */
  AddMediaPath: {
    parameters: {
      query?: {
        /** @description Whether to refresh the library. */
        refreshLibrary?: boolean;
      };
    };
    /** @description The media path dto. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MediaPathDto"];
        "text/json": components["schemas"]["MediaPathDto"];
        "application/*+json": components["schemas"]["MediaPathDto"];
      };
    };
    responses: {
      /** @description Media path added. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Remove a media path. */
  RemoveMediaPath: {
    parameters: {
      query?: {
        /** @description The name of the library. */
        name?: string;
        /** @description The path to remove. */
        path?: string;
        /** @description Whether to refresh the library. */
        refreshLibrary?: boolean;
      };
    };
    responses: {
      /** @description Media path removed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a media path. */
  UpdateMediaPath: {
    /** @description The name of the library and path infos. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateMediaPathRequestDto"];
        "text/json": components["schemas"]["UpdateMediaPathRequestDto"];
        "application/*+json": components["schemas"]["UpdateMediaPathRequestDto"];
      };
    };
    responses: {
      /** @description Media path updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get channel mapping options. */
  GetChannelMappingOptions: {
    parameters: {
      query?: {
        /** @description Provider id. */
        providerId?: string;
      };
    };
    responses: {
      /** @description Channel mapping options returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ChannelMappingOptionsDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ChannelMappingOptionsDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ChannelMappingOptionsDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Set channel mappings. */
  SetChannelMapping: {
    /** @description The set channel mapping dto. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetChannelMappingDto"];
        "text/json": components["schemas"]["SetChannelMappingDto"];
        "application/*+json": components["schemas"]["SetChannelMappingDto"];
      };
    };
    responses: {
      /** @description Created channel mapping returned. */
      200: {
        content: {
          "application/json": components["schemas"]["TunerChannelMapping"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TunerChannelMapping"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TunerChannelMapping"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available live tv channels. */
  GetLiveTvChannels: {
    parameters: {
      query?: {
        /** @description Optional. Filter by channel type. */
        type?: "TV" | "Radio";
        /** @description Optional. Filter by user and attach user data. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. Filter for movies. */
        isMovie?: boolean;
        /** @description Optional. Filter for series. */
        isSeries?: boolean;
        /** @description Optional. Filter for news. */
        isNews?: boolean;
        /** @description Optional. Filter for kids. */
        isKids?: boolean;
        /** @description Optional. Filter for sports. */
        isSports?: boolean;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Filter by channels that are favorites, or not. */
        isFavorite?: boolean;
        /** @description Optional. Filter by channels that are liked, or not. */
        isLiked?: boolean;
        /** @description Optional. Filter by channels that are disliked, or not. */
        isDisliked?: boolean;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description "Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Key to sort by. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Optional. Sort order. */
        sortOrder?: "Ascending" | "Descending";
        /** @description Optional. Incorporate favorite and like status into channel sorting. */
        enableFavoriteSorting?: boolean;
        /** @description Optional. Adds current program info to each channel. */
        addCurrentProgram?: boolean;
      };
    };
    responses: {
      /** @description Available live tv channels returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a live tv channel. */
  GetChannel: {
    parameters: {
      query?: {
        /** @description Optional. Attach user data. */
        userId?: string;
      };
      path: {
        /** @description Channel id. */
        channelId: string;
      };
    };
    responses: {
      /** @description Live tv channel returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get guid info. */
  GetGuideInfo: {
    responses: {
      /** @description Guid info returned. */
      200: {
        content: {
          "application/json": components["schemas"]["GuideInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["GuideInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["GuideInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available live tv services. */
  GetLiveTvInfo: {
    responses: {
      /** @description Available live tv services returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LiveTvInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LiveTvInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LiveTvInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Adds a listings provider. */
  AddListingProvider: {
    parameters: {
      query?: {
        /** @description Password. */
        pw?: string;
        /** @description Validate listings. */
        validateListings?: boolean;
        /** @description Validate login. */
        validateLogin?: boolean;
      };
    };
    /** @description New listings info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["ListingsProviderInfo"];
        "text/json": components["schemas"]["ListingsProviderInfo"];
        "application/*+json": components["schemas"]["ListingsProviderInfo"];
      };
    };
    responses: {
      /** @description Created listings provider returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ListingsProviderInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ListingsProviderInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ListingsProviderInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Delete listing provider. */
  DeleteListingProvider: {
    parameters: {
      query?: {
        /** @description Listing provider id. */
        id?: string;
      };
    };
    responses: {
      /** @description Listing provider deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets default listings provider info. */
  GetDefaultListingProvider: {
    responses: {
      /** @description Default listings provider info returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ListingsProviderInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ListingsProviderInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ListingsProviderInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available lineups. */
  GetLineups: {
    parameters: {
      query?: {
        /** @description Provider id. */
        id?: string;
        /** @description Provider type. */
        type?: string;
        /** @description Location. */
        location?: string;
        /** @description Country. */
        country?: string;
      };
    };
    responses: {
      /** @description Available lineups returned. */
      200: {
        content: {
          "application/json": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["NameIdPair"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available countries. */
  GetSchedulesDirectCountries: {
    responses: {
      /** @description Available countries returned. */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a live tv recording stream. */
  GetLiveRecordingFile: {
    parameters: {
      path: {
        /** @description Recording id. */
        recordingId: string;
      };
    };
    responses: {
      /** @description Recording stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
      /** @description Recording not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a live tv channel stream. */
  GetLiveStreamFile: {
    parameters: {
      path: {
        /** @description Stream id. */
        streamId: string;
        /** @description Container type. */
        container: string;
      };
    };
    responses: {
      /** @description Stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
      /** @description Stream not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets available live tv epgs. */
  GetLiveTvPrograms: {
    parameters: {
      query?: {
        /** @description The channels to return guide information for. */
        channelIds?: string[];
        /** @description Optional. Filter by user id. */
        userId?: string;
        /** @description Optional. The minimum premiere start date. */
        minStartDate?: string;
        /** @description Optional. Filter by programs that have completed airing, or not. */
        hasAired?: boolean;
        /** @description Optional. Filter by programs that are currently airing, or not. */
        isAiring?: boolean;
        /** @description Optional. The maximum premiere start date. */
        maxStartDate?: string;
        /** @description Optional. The minimum premiere end date. */
        minEndDate?: string;
        /** @description Optional. The maximum premiere end date. */
        maxEndDate?: string;
        /** @description Optional. Filter for movies. */
        isMovie?: boolean;
        /** @description Optional. Filter for series. */
        isSeries?: boolean;
        /** @description Optional. Filter for news. */
        isNews?: boolean;
        /** @description Optional. Filter for kids. */
        isKids?: boolean;
        /** @description Optional. Filter for sports. */
        isSports?: boolean;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description The genres to return guide information for. */
        genres?: string[];
        /** @description The genre ids to return guide information for. */
        genreIds?: string[];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Filter by series timer id. */
        seriesTimerId?: string;
        /** @description Optional. Filter by library series id. */
        librarySeriesId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Retrieve total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Live tv epgs returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available live tv epgs. */
  GetPrograms: {
    /** @description Request body. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["GetProgramsDto"];
        "text/json": components["schemas"]["GetProgramsDto"];
        "application/*+json": components["schemas"]["GetProgramsDto"];
      };
    };
    responses: {
      /** @description Live tv epgs returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a live tv program. */
  GetProgram: {
    parameters: {
      query?: {
        /** @description Optional. Attach user data. */
        userId?: string;
      };
      path: {
        /** @description Program id. */
        programId: string;
      };
    };
    responses: {
      /** @description Program returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets recommended live tv epgs. */
  GetRecommendedPrograms: {
    parameters: {
      query?: {
        /** @description Optional. filter by user id. */
        userId?: string;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Filter by programs that are currently airing, or not. */
        isAiring?: boolean;
        /** @description Optional. Filter by programs that have completed airing, or not. */
        hasAired?: boolean;
        /** @description Optional. Filter for series. */
        isSeries?: boolean;
        /** @description Optional. Filter for movies. */
        isMovie?: boolean;
        /** @description Optional. Filter for news. */
        isNews?: boolean;
        /** @description Optional. Filter for kids. */
        isKids?: boolean;
        /** @description Optional. Filter for sports. */
        isSports?: boolean;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description The genres to return guide information for. */
        genreIds?: string[];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. include user data. */
        enableUserData?: boolean;
        /** @description Retrieve total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Recommended epgs returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets live tv recordings. */
  GetRecordings: {
    parameters: {
      query?: {
        /** @description Optional. Filter by channel id. */
        channelId?: string;
        /** @description Optional. Filter by user and attach user data. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Filter by recording status. */
        status?: "New" | "InProgress" | "Completed" | "Cancelled" | "ConflictedOk" | "ConflictedNotOk" | "Error";
        /** @description Optional. Filter by recordings that are in progress, or not. */
        isInProgress?: boolean;
        /** @description Optional. Filter by recordings belonging to a series timer. */
        seriesTimerId?: string;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Filter for movies. */
        isMovie?: boolean;
        /** @description Optional. Filter for series. */
        isSeries?: boolean;
        /** @description Optional. Filter for kids. */
        isKids?: boolean;
        /** @description Optional. Filter for sports. */
        isSports?: boolean;
        /** @description Optional. Filter for news. */
        isNews?: boolean;
        /** @description Optional. Filter for is library item. */
        isLibraryItem?: boolean;
        /** @description Optional. Return total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Live tv recordings returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a live tv recording. */
  GetRecording: {
    parameters: {
      query?: {
        /** @description Optional. Attach user data. */
        userId?: string;
      };
      path: {
        /** @description Recording id. */
        recordingId: string;
      };
    };
    responses: {
      /** @description Recording returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Deletes a live tv recording. */
  DeleteRecording: {
    parameters: {
      path: {
        /** @description Recording id. */
        recordingId: string;
      };
    };
    responses: {
      /** @description Recording deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets recording folders. */
  GetRecordingFolders: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user and attach user data. */
        userId?: string;
      };
    };
    responses: {
      /** @description Recording folders returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /**
   * Gets live tv recording groups.
   * @deprecated
   */
  GetRecordingGroups: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user and attach user data. */
        userId?: string;
      };
    };
    responses: {
      /** @description Recording groups returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /**
   * Get recording group.
   * @deprecated
   */
  GetRecordingGroup: {
    parameters: {
      path: {
        /** @description Group id. */
        groupId: string;
      };
    };
    responses: {
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Gets live tv recording series.
   * @deprecated
   */
  GetRecordingsSeries: {
    parameters: {
      query?: {
        /** @description Optional. Filter by channel id. */
        channelId?: string;
        /** @description Optional. Filter by user and attach user data. */
        userId?: string;
        /** @description Optional. Filter by recording group. */
        groupId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Filter by recording status. */
        status?: "New" | "InProgress" | "Completed" | "Cancelled" | "ConflictedOk" | "ConflictedNotOk" | "Error";
        /** @description Optional. Filter by recordings that are in progress, or not. */
        isInProgress?: boolean;
        /** @description Optional. Filter by recordings belonging to a series timer. */
        seriesTimerId?: string;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Return total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Live tv recordings returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets live tv series timers. */
  GetSeriesTimers: {
    parameters: {
      query?: {
        /** @description Optional. Sort by SortName or Priority. */
        sortBy?: string;
        /** @description Optional. Sort in Ascending or Descending order. */
        sortOrder?: "Ascending" | "Descending";
      };
    };
    responses: {
      /** @description Timers returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesTimerInfoDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SeriesTimerInfoDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SeriesTimerInfoDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Creates a live tv series timer. */
  CreateSeriesTimer: {
    /** @description New series timer info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SeriesTimerInfoDto"];
        "text/json": components["schemas"]["SeriesTimerInfoDto"];
        "application/*+json": components["schemas"]["SeriesTimerInfoDto"];
      };
    };
    responses: {
      /** @description Series timer info created. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a live tv series timer. */
  GetSeriesTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    responses: {
      /** @description Series timer returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesTimerInfoDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SeriesTimerInfoDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SeriesTimerInfoDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Series timer not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Updates a live tv series timer. */
  UpdateSeriesTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    /** @description New series timer info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["SeriesTimerInfoDto"];
        "text/json": components["schemas"]["SeriesTimerInfoDto"];
        "application/*+json": components["schemas"]["SeriesTimerInfoDto"];
      };
    };
    responses: {
      /** @description Series timer updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Cancels a live tv series timer. */
  CancelSeriesTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    responses: {
      /** @description Timer cancelled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the live tv timers. */
  GetTimers: {
    parameters: {
      query?: {
        /** @description Optional. Filter by channel id. */
        channelId?: string;
        /** @description Optional. Filter by timers belonging to a series timer. */
        seriesTimerId?: string;
        /** @description Optional. Filter by timers that are active. */
        isActive?: boolean;
        /** @description Optional. Filter by timers that are scheduled. */
        isScheduled?: boolean;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["TimerInfoDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TimerInfoDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TimerInfoDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Creates a live tv timer. */
  CreateTimer: {
    /** @description New timer info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TimerInfoDto"];
        "text/json": components["schemas"]["TimerInfoDto"];
        "application/*+json": components["schemas"]["TimerInfoDto"];
      };
    };
    responses: {
      /** @description Timer created. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a timer. */
  GetTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    responses: {
      /** @description Timer returned. */
      200: {
        content: {
          "application/json": components["schemas"]["TimerInfoDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TimerInfoDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TimerInfoDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a live tv timer. */
  UpdateTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    /** @description New timer info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TimerInfoDto"];
        "text/json": components["schemas"]["TimerInfoDto"];
        "application/*+json": components["schemas"]["TimerInfoDto"];
      };
    };
    responses: {
      /** @description Timer updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Cancels a live tv timer. */
  CancelTimer: {
    parameters: {
      path: {
        /** @description Timer id. */
        timerId: string;
      };
    };
    responses: {
      /** @description Timer deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the default values for a new timer. */
  GetDefaultTimer: {
    parameters: {
      query?: {
        /** @description Optional. To attach default values based on a program. */
        programId?: string;
      };
    };
    responses: {
      /** @description Default values returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesTimerInfoDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SeriesTimerInfoDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SeriesTimerInfoDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Adds a tuner host. */
  AddTunerHost: {
    /** @description New tuner host. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["TunerHostInfo"];
        "text/json": components["schemas"]["TunerHostInfo"];
        "application/*+json": components["schemas"]["TunerHostInfo"];
      };
    };
    responses: {
      /** @description Created tuner host returned. */
      200: {
        content: {
          "application/json": components["schemas"]["TunerHostInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TunerHostInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TunerHostInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Deletes a tuner host. */
  DeleteTunerHost: {
    parameters: {
      query?: {
        /** @description Tuner host id. */
        id?: string;
      };
    };
    responses: {
      /** @description Tuner host deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get tuner host types. */
  GetTunerHostTypes: {
    responses: {
      /** @description Tuner host types returned. */
      200: {
        content: {
          "application/json": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["NameIdPair"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Resets a tv tuner. */
  ResetTuner: {
    parameters: {
      path: {
        /** @description Tuner id. */
        tunerId: string;
      };
    };
    responses: {
      /** @description Tuner reset. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Discover tuners. */
  DiscoverTuners: {
    parameters: {
      query?: {
        /** @description Only discover new tuners. */
        newDevicesOnly?: boolean;
      };
    };
    responses: {
      /** @description Tuners returned. */
      200: {
        content: {
          "application/json": components["schemas"]["TunerHostInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TunerHostInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TunerHostInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Discover tuners. */
  DiscvoverTuners: {
    parameters: {
      query?: {
        /** @description Only discover new tuners. */
        newDevicesOnly?: boolean;
      };
    };
    responses: {
      /** @description Tuners returned. */
      200: {
        content: {
          "application/json": components["schemas"]["TunerHostInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TunerHostInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TunerHostInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets known countries. */
  GetCountries: {
    responses: {
      /** @description Known countries returned. */
      200: {
        content: {
          "application/json": components["schemas"]["CountryInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["CountryInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["CountryInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets known cultures. */
  GetCultures: {
    responses: {
      /** @description Known cultures returned. */
      200: {
        content: {
          "application/json": components["schemas"]["CultureDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["CultureDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["CultureDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets localization options. */
  GetLocalizationOptions: {
    responses: {
      /** @description Localization options returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LocalizationOption"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LocalizationOption"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LocalizationOption"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets known parental ratings. */
  GetParentalRatings: {
    responses: {
      /** @description Known parental ratings returned. */
      200: {
        content: {
          "application/json": components["schemas"]["ParentalRating"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ParentalRating"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ParentalRating"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an item's lyrics. */
  GetLyrics: {
    parameters: {
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Lyrics returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LyricDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LyricDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LyricDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Something went wrong. No Lyrics will be returned. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Upload an external lyric file. */
  UploadLyrics: {
    parameters: {
      query: {
        /** @description Name of the file being uploaded. */
        fileName: string;
      };
      path: {
        /** @description The item the lyric belongs to. */
        itemId: string;
      };
    };
    requestBody?: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description Lyrics uploaded. */
      200: {
        content: {
          "application/json": components["schemas"]["LyricDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LyricDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LyricDto"];
        };
      };
      /** @description Error processing upload. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Deletes an external lyric file. */
  DeleteLyrics: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Lyric deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Search remote lyrics. */
  SearchRemoteLyrics: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Lyrics retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteLyricInfoDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteLyricInfoDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteLyricInfoDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Downloads a remote lyric. */
  DownloadRemoteLyrics: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The lyric id. */
        lyricId: string;
      };
    };
    responses: {
      /** @description Lyric downloaded. */
      200: {
        content: {
          "application/json": components["schemas"]["LyricDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LyricDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LyricDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the remote lyrics. */
  GetRemoteLyrics: {
    parameters: {
      path: {
        /** @description The remote provider item id. */
        lyricId: string;
      };
    };
    responses: {
      /** @description File returned. */
      200: {
        content: {
          "application/json": components["schemas"]["LyricDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LyricDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LyricDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Lyric not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets live playback media info for an item. */
  GetPlaybackInfo: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Playback info returned. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybackInfoResponse"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PlaybackInfoResponse"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PlaybackInfoResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Gets live playback media info for an item.
   * @description For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
   * Query parameters are obsolete.
   */
  GetPostedPlaybackInfo: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description The user id.
         */
        userId?: string;
        /**
         * @deprecated
         * @description The maximum streaming bitrate.
         */
        maxStreamingBitrate?: number;
        /**
         * @deprecated
         * @description The start time in ticks.
         */
        startTimeTicks?: number;
        /**
         * @deprecated
         * @description The audio stream index.
         */
        audioStreamIndex?: number;
        /**
         * @deprecated
         * @description The subtitle stream index.
         */
        subtitleStreamIndex?: number;
        /**
         * @deprecated
         * @description The maximum number of audio channels.
         */
        maxAudioChannels?: number;
        /**
         * @deprecated
         * @description The media source id.
         */
        mediaSourceId?: string;
        /**
         * @deprecated
         * @description The livestream id.
         */
        liveStreamId?: string;
        /**
         * @deprecated
         * @description Whether to auto open the livestream.
         */
        autoOpenLiveStream?: boolean;
        /**
         * @deprecated
         * @description Whether to enable direct play. Default: true.
         */
        enableDirectPlay?: boolean;
        /**
         * @deprecated
         * @description Whether to enable direct stream. Default: true.
         */
        enableDirectStream?: boolean;
        /**
         * @deprecated
         * @description Whether to enable transcoding. Default: true.
         */
        enableTranscoding?: boolean;
        /**
         * @deprecated
         * @description Whether to allow to copy the video stream. Default: true.
         */
        allowVideoStreamCopy?: boolean;
        /**
         * @deprecated
         * @description Whether to allow to copy the audio stream. Default: true.
         */
        allowAudioStreamCopy?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    /** @description The playback info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PlaybackInfoDto"];
        "text/json": components["schemas"]["PlaybackInfoDto"];
        "application/*+json": components["schemas"]["PlaybackInfoDto"];
      };
    };
    responses: {
      /** @description Playback info returned. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaybackInfoResponse"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PlaybackInfoResponse"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PlaybackInfoResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Closes a media source. */
  CloseLiveStream: {
    parameters: {
      query: {
        /** @description The livestream id. */
        liveStreamId: string;
      };
    };
    responses: {
      /** @description Livestream closed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Opens a media source. */
  OpenLiveStream: {
    parameters: {
      query?: {
        /** @description The open token. */
        openToken?: string;
        /** @description The user id. */
        userId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description The start time in ticks. */
        startTimeTicks?: number;
        /** @description The audio stream index. */
        audioStreamIndex?: number;
        /** @description The subtitle stream index. */
        subtitleStreamIndex?: number;
        /** @description The maximum number of audio channels. */
        maxAudioChannels?: number;
        /** @description The item id. */
        itemId?: string;
        /** @description Whether to enable direct play. Default: true. */
        enableDirectPlay?: boolean;
        /** @description Whether to enable direct stream. Default: true. */
        enableDirectStream?: boolean;
      };
    };
    /** @description The open live stream dto. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["OpenLiveStreamDto"];
        "text/json": components["schemas"]["OpenLiveStreamDto"];
        "application/*+json": components["schemas"]["OpenLiveStreamDto"];
      };
    };
    responses: {
      /** @description Media source opened. */
      200: {
        content: {
          "application/json": components["schemas"]["LiveStreamResponse"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LiveStreamResponse"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LiveStreamResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Tests the network with a request with the size of the bitrate. */
  GetBitrateTestBytes: {
    parameters: {
      query?: {
        /** @description The bitrate. Defaults to 102400. */
        size?: number;
      };
    };
    responses: {
      /** @description Test buffer returned. */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets movie recommendations. */
  GetMovieRecommendations: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. The fields to return. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description The max number of categories to return. */
        categoryLimit?: number;
        /** @description The max number of items to return per category. */
        itemLimit?: number;
      };
    };
    responses: {
      /** @description Movie recommendations returned. */
      200: {
        content: {
          "application/json": components["schemas"]["RecommendationDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RecommendationDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RecommendationDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /**
   * Gets all music genres from a given item, folder, or the entire library.
   * @deprecated
   */
  GetMusicGenres: {
    parameters: {
      query?: {
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description The search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered in based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description User id. */
        userId?: string;
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. Specify one or more sort orders, comma delimited. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Music genres returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a music genre, by name. */
  GetMusicGenre: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description The genre name. */
        genreName: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets available packages. */
  GetPackages: {
    responses: {
      /** @description Available packages returned. */
      200: {
        content: {
          "application/json": components["schemas"]["PackageInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PackageInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PackageInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a package by name or assembly GUID. */
  GetPackageInfo: {
    parameters: {
      query?: {
        /** @description The GUID of the associated assembly. */
        assemblyGuid?: string;
      };
      path: {
        /** @description The name of the package. */
        name: string;
      };
    };
    responses: {
      /** @description Package retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["PackageInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PackageInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PackageInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Installs a package. */
  InstallPackage: {
    parameters: {
      query?: {
        /** @description GUID of the associated assembly. */
        assemblyGuid?: string;
        /** @description Optional version. Defaults to latest version. */
        version?: string;
        /** @description Optional. Specify the repository to install from. */
        repositoryUrl?: string;
      };
      path: {
        /** @description Package name. */
        name: string;
      };
    };
    responses: {
      /** @description Package found. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Package not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Cancels a package installation. */
  CancelPackageInstallation: {
    parameters: {
      path: {
        /** @description Installation Id. */
        packageId: string;
      };
    };
    responses: {
      /** @description Installation cancelled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all package repositories. */
  GetRepositories: {
    responses: {
      /** @description Package repositories returned. */
      200: {
        content: {
          "application/json": components["schemas"]["RepositoryInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RepositoryInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RepositoryInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Sets the enabled and existing package repositories. */
  SetRepositories: {
    /** @description The list of package repositories. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RepositoryInfo"][];
        "text/json": components["schemas"]["RepositoryInfo"][];
        "application/*+json": components["schemas"]["RepositoryInfo"][];
      };
    };
    responses: {
      /** @description Package repositories saved. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all persons. */
  GetPersons: {
    parameters: {
      query?: {
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description The search term. */
        searchTerm?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Specify additional filters to apply. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional filter by items that are marked as favorite, or not. userId is required. */
        isFavorite?: boolean;
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified results will be filtered to exclude those containing the specified PersonType. Allows multiple, comma-delimited. */
        excludePersonTypes?: string[];
        /** @description Optional. If specified results will be filtered to include only those containing the specified PersonType. Allows multiple, comma-delimited. */
        personTypes?: string[];
        /** @description Optional. If specified, person results will be filtered on items related to said persons. */
        appearsInItemId?: string;
        /** @description User id. */
        userId?: string;
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
      };
    };
    responses: {
      /** @description Persons returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get person by name. */
  GetPerson: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description Person name. */
        name: string;
      };
    };
    responses: {
      /** @description Person returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Person not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Creates a new playlist.
   * @description For backwards compatibility parameters can be sent via Query or Body, with Query having higher precedence.
   * Query parameters are obsolete.
   */
  CreatePlaylist: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description The playlist name.
         */
        name?: string;
        /**
         * @deprecated
         * @description The item ids.
         */
        ids?: string[];
        /**
         * @deprecated
         * @description The user id.
         */
        userId?: string;
        /**
         * @deprecated
         * @description The media type.
         */
        mediaType?: "Unknown" | "Video" | "Audio" | "Photo" | "Book";
      };
    };
    /** @description The create playlist payload. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreatePlaylistDto"];
        "text/json": components["schemas"]["CreatePlaylistDto"];
        "application/*+json": components["schemas"]["CreatePlaylistDto"];
      };
    };
    responses: {
      /** @description Playlist created. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaylistCreationResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PlaylistCreationResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PlaylistCreationResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a playlist. */
  UpdatePlaylist: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    /** @description The Jellyfin.Api.Models.PlaylistDtos.UpdatePlaylistDto id. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlaylistDto"];
        "text/json": components["schemas"]["UpdatePlaylistDto"];
        "application/*+json": components["schemas"]["UpdatePlaylistDto"];
      };
    };
    responses: {
      /** @description Playlist updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the original items of a playlist. */
  GetPlaylistItems: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
      };
      path: {
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    responses: {
      /** @description Original playlist returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Adds items to a playlist. */
  AddItemToPlaylist: {
    parameters: {
      query?: {
        /** @description Item id, comma delimited. */
        ids?: string[];
        /** @description The userId. */
        userId?: string;
      };
      path: {
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    responses: {
      /** @description Items added to playlist. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Removes items from a playlist. */
  RemoveItemFromPlaylist: {
    parameters: {
      query?: {
        /** @description The item ids, comma delimited. */
        entryIds?: string[];
      };
      path: {
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    responses: {
      /** @description Items removed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Moves a playlist item. */
  MoveItem: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
        /** @description The item id. */
        itemId: string;
        /** @description The new index. */
        newIndex: number;
      };
    };
    responses: {
      /** @description Item moved to new index. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get a playlist's users. */
  GetPlaylistUsers: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
      };
    };
    responses: {
      /** @description Found shares. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaylistUserPermissions"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PlaylistUserPermissions"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PlaylistUserPermissions"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get a playlist user. */
  GetPlaylistUser: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User permission found. */
      200: {
        content: {
          "application/json": components["schemas"]["PlaylistUserPermissions"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PlaylistUserPermissions"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PlaylistUserPermissions"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Modify a user of a playlist's users. */
  UpdatePlaylistUser: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
        /** @description The user id. */
        userId: string;
      };
    };
    /** @description The Jellyfin.Api.Models.PlaylistDtos.UpdatePlaylistUserDto. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlaylistUserDto"];
        "text/json": components["schemas"]["UpdatePlaylistUserDto"];
        "application/*+json": components["schemas"]["UpdatePlaylistUserDto"];
      };
    };
    responses: {
      /** @description User's permissions modified. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Access forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Playlist not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Remove a user from a playlist's users. */
  RemoveUserFromPlaylist: {
    parameters: {
      path: {
        /** @description The playlist id. */
        playlistId: string;
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User permissions removed from playlist. */
      204: {
        content: never;
      };
      /** @description Unauthorized access. */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description No playlist or user permissions found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Reports that a session has begun playing an item. */
  OnPlaybackStart: {
    parameters: {
      query?: {
        /** @description The id of the MediaSource. */
        mediaSourceId?: string;
        /** @description The audio stream index. */
        audioStreamIndex?: number;
        /** @description The subtitle stream index. */
        subtitleStreamIndex?: number;
        /** @description The play method. */
        playMethod?: "Transcode" | "DirectStream" | "DirectPlay";
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description Indicates if the client can seek. */
        canSeek?: boolean;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Play start recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that a session has stopped playing an item. */
  OnPlaybackStopped: {
    parameters: {
      query?: {
        /** @description The id of the MediaSource. */
        mediaSourceId?: string;
        /** @description The next media type that will play. */
        nextMediaType?: string;
        /** @description Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms. */
        positionTicks?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description The play session id. */
        playSessionId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Playback stop recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports a session's playback progress. */
  OnPlaybackProgress: {
    parameters: {
      query?: {
        /** @description The id of the MediaSource. */
        mediaSourceId?: string;
        /** @description Optional. The current position, in ticks. 1 tick = 10000 ms. */
        positionTicks?: number;
        /** @description The audio stream index. */
        audioStreamIndex?: number;
        /** @description The subtitle stream index. */
        subtitleStreamIndex?: number;
        /** @description Scale of 0-100. */
        volumeLevel?: number;
        /** @description The play method. */
        playMethod?: "Transcode" | "DirectStream" | "DirectPlay";
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The repeat mode. */
        repeatMode?: "RepeatNone" | "RepeatAll" | "RepeatOne";
        /** @description Indicates if the player is paused. */
        isPaused?: boolean;
        /** @description Indicates if the player is muted. */
        isMuted?: boolean;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Play progress recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports playback has started within a session. */
  ReportPlaybackStart: {
    /** @description The playback start info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PlaybackStartInfo"];
        "text/json": components["schemas"]["PlaybackStartInfo"];
        "application/*+json": components["schemas"]["PlaybackStartInfo"];
      };
    };
    responses: {
      /** @description Playback start recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Pings a playback session. */
  PingPlaybackSession: {
    parameters: {
      query: {
        /** @description Playback session id. */
        playSessionId: string;
      };
    };
    responses: {
      /** @description Playback session pinged. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports playback progress within a session. */
  ReportPlaybackProgress: {
    /** @description The playback progress info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PlaybackProgressInfo"];
        "text/json": components["schemas"]["PlaybackProgressInfo"];
        "application/*+json": components["schemas"]["PlaybackProgressInfo"];
      };
    };
    responses: {
      /** @description Playback progress recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports playback has stopped within a session. */
  ReportPlaybackStopped: {
    /** @description The playback stop info. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["PlaybackStopInfo"];
        "text/json": components["schemas"]["PlaybackStopInfo"];
        "application/*+json": components["schemas"]["PlaybackStopInfo"];
      };
    };
    responses: {
      /** @description Playback stop recorded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Marks an item as played for user. */
  MarkPlayedItem: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Optional. The date the item was played. */
        datePlayed?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item marked as played. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Marks an item as unplayed for user. */
  MarkUnplayedItem: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item marked as unplayed. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a list of currently installed plugins. */
  GetPlugins: {
    responses: {
      /** @description Installed plugins returned. */
      200: {
        content: {
          "application/json": components["schemas"]["PluginInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PluginInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PluginInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /**
   * Uninstalls a plugin.
   * @deprecated
   */
  UninstallPlugin: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
      };
    };
    responses: {
      /** @description Plugin uninstalled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Uninstalls a plugin by version. */
  UninstallPluginByVersion: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
        /** @description Plugin version. */
        version: string;
      };
    };
    responses: {
      /** @description Plugin uninstalled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Disable a plugin. */
  DisablePlugin: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
        /** @description Plugin version. */
        version: string;
      };
    };
    responses: {
      /** @description Plugin disabled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Enables a disabled plugin. */
  EnablePlugin: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
        /** @description Plugin version. */
        version: string;
      };
    };
    responses: {
      /** @description Plugin enabled. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a plugin's image. */
  GetPluginImage: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
        /** @description Plugin version. */
        version: string;
      };
    };
    responses: {
      /** @description Plugin image returned. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets plugin configuration. */
  GetPluginConfiguration: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
      };
    };
    responses: {
      /** @description Plugin configuration returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BasePluginConfiguration"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BasePluginConfiguration"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BasePluginConfiguration"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found or plugin configuration not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Updates plugin configuration.
   * @description Accepts plugin configuration as JSON body.
   */
  UpdatePluginConfiguration: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
      };
    };
    responses: {
      /** @description Plugin configuration updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found or plugin does not have configuration. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a plugin's manifest. */
  GetPluginManifest: {
    parameters: {
      path: {
        /** @description Plugin id. */
        pluginId: string;
      };
    };
    responses: {
      /** @description Plugin manifest returned. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Plugin not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Authorizes a pending quick connect request. */
  AuthorizeQuickConnect: {
    parameters: {
      query: {
        /** @description Quick connect code to authorize. */
        code: string;
        /** @description The user the authorize. Access to the requested user is required. */
        userId?: string;
      };
    };
    responses: {
      /** @description Quick connect result authorized successfully. */
      200: {
        content: {
          "application/json": boolean;
          "application/json; profile=\"CamelCase\"": boolean;
          "application/json; profile=\"PascalCase\"": boolean;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Unknown user id. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Attempts to retrieve authentication information. */
  GetQuickConnectState: {
    parameters: {
      query: {
        /** @description Secret previously returned from the Initiate endpoint. */
        secret: string;
      };
    };
    responses: {
      /** @description Quick connect result returned. */
      200: {
        content: {
          "application/json": components["schemas"]["QuickConnectResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["QuickConnectResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["QuickConnectResult"];
        };
      };
      /** @description Unknown quick connect secret. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the current quick connect state. */
  GetQuickConnectEnabled: {
    responses: {
      /** @description Quick connect state returned. */
      200: {
        content: {
          "application/json": boolean;
          "application/json; profile=\"CamelCase\"": boolean;
          "application/json; profile=\"PascalCase\"": boolean;
        };
      };
    };
  };
  /** Initiate a new quick connect request. */
  InitiateQuickConnect: {
    responses: {
      /** @description Quick connect request successfully created. */
      200: {
        content: {
          "application/json": components["schemas"]["QuickConnectResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["QuickConnectResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["QuickConnectResult"];
        };
      };
      /** @description Quick connect is not active on this server. */
      401: {
        content: never;
      };
    };
  };
  /** Gets available remote images for an item. */
  GetRemoteImages: {
    parameters: {
      query?: {
        /** @description The image type. */
        type?: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. The image provider to use. */
        providerName?: string;
        /** @description Optional. Include all languages. */
        includeAllLanguages?: boolean;
      };
      path: {
        /** @description Item Id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Remote Images returned. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteImageResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteImageResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteImageResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Downloads a remote image for an item. */
  DownloadRemoteImage: {
    parameters: {
      query: {
        /** @description The image type. */
        type: "Primary" | "Art" | "Backdrop" | "Banner" | "Logo" | "Thumb" | "Disc" | "Box" | "Screenshot" | "Menu" | "Chapter" | "BoxRear" | "Profile";
        /** @description The image url. */
        imageUrl?: string;
      };
      path: {
        /** @description Item Id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Remote image downloaded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Remote image not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets available remote image providers for an item. */
  GetRemoteImageProviders: {
    parameters: {
      path: {
        /** @description Item Id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Returned remote image providers. */
      200: {
        content: {
          "application/json": components["schemas"]["ImageProviderInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ImageProviderInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ImageProviderInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get tasks. */
  GetTasks: {
    parameters: {
      query?: {
        /** @description Optional filter tasks that are hidden, or not. */
        isHidden?: boolean;
        /** @description Optional filter tasks that are enabled, or not. */
        isEnabled?: boolean;
      };
    };
    responses: {
      /** @description Scheduled tasks retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["TaskInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TaskInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TaskInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get task by id. */
  GetTask: {
    parameters: {
      path: {
        /** @description Task Id. */
        taskId: string;
      };
    };
    responses: {
      /** @description Task retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["TaskInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["TaskInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["TaskInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Task not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Update specified task triggers. */
  UpdateTask: {
    parameters: {
      path: {
        /** @description Task Id. */
        taskId: string;
      };
    };
    /** @description Triggers. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["TaskTriggerInfo"][];
        "text/json": components["schemas"]["TaskTriggerInfo"][];
        "application/*+json": components["schemas"]["TaskTriggerInfo"][];
      };
    };
    responses: {
      /** @description Task triggers updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Task not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Start specified task. */
  StartTask: {
    parameters: {
      path: {
        /** @description Task Id. */
        taskId: string;
      };
    };
    responses: {
      /** @description Task started. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Task not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Stop specified task. */
  StopTask: {
    parameters: {
      path: {
        /** @description Task Id. */
        taskId: string;
      };
    };
    responses: {
      /** @description Task stopped. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Task not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the search hint result. */
  GetSearchHints: {
    parameters: {
      query: {
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Supply a user id to search within a user's library or omit to search all. */
        userId?: string;
        /** @description The search term to filter on. */
        searchTerm: string;
        /** @description If specified, only results with the specified item types are returned. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description If specified, results with these item types are filtered out. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description If specified, only results with the specified media types are returned. This allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description If specified, only children of the parent are returned. */
        parentId?: string;
        /** @description Optional filter for movies. */
        isMovie?: boolean;
        /** @description Optional filter for series. */
        isSeries?: boolean;
        /** @description Optional filter for news. */
        isNews?: boolean;
        /** @description Optional filter for kids. */
        isKids?: boolean;
        /** @description Optional filter for sports. */
        isSports?: boolean;
        /** @description Optional filter whether to include people. */
        includePeople?: boolean;
        /** @description Optional filter whether to include media. */
        includeMedia?: boolean;
        /** @description Optional filter whether to include genres. */
        includeGenres?: boolean;
        /** @description Optional filter whether to include studios. */
        includeStudios?: boolean;
        /** @description Optional filter whether to include artists. */
        includeArtists?: boolean;
      };
    };
    responses: {
      /** @description Search hint returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SearchHintResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SearchHintResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SearchHintResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get all password reset providers. */
  GetPasswordResetProviders: {
    responses: {
      /** @description Password reset providers retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["NameIdPair"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get all auth providers. */
  GetAuthProviders: {
    responses: {
      /** @description Auth providers retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["NameIdPair"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["NameIdPair"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a list of sessions. */
  GetSessions: {
    parameters: {
      query?: {
        /** @description Filter by sessions that a given user is allowed to remote control. */
        controllableByUserId?: string;
        /** @description Filter by device Id. */
        deviceId?: string;
        /** @description Optional. Filter by sessions that were active in the last n seconds. */
        activeWithinSeconds?: number;
      };
    };
    responses: {
      /** @description List of sessions returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SessionInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SessionInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SessionInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Issues a full general command to a client. */
  SendFullGeneralCommand: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
      };
    };
    /** @description The MediaBrowser.Model.Session.GeneralCommand. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["GeneralCommand"];
        "text/json": components["schemas"]["GeneralCommand"];
        "application/*+json": components["schemas"]["GeneralCommand"];
      };
    };
    responses: {
      /** @description Full general command sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Issues a general command to a client. */
  SendGeneralCommand: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
        /** @description The command to send. */
        command: "MoveUp" | "MoveDown" | "MoveLeft" | "MoveRight" | "PageUp" | "PageDown" | "PreviousLetter" | "NextLetter" | "ToggleOsd" | "ToggleContextMenu" | "Select" | "Back" | "TakeScreenshot" | "SendKey" | "SendString" | "GoHome" | "GoToSettings" | "VolumeUp" | "VolumeDown" | "Mute" | "Unmute" | "ToggleMute" | "SetVolume" | "SetAudioStreamIndex" | "SetSubtitleStreamIndex" | "ToggleFullscreen" | "DisplayContent" | "GoToSearch" | "DisplayMessage" | "SetRepeatMode" | "ChannelUp" | "ChannelDown" | "Guide" | "ToggleStats" | "PlayMediaSource" | "PlayTrailers" | "SetShuffleQueue" | "PlayState" | "PlayNext" | "ToggleOsdMenu" | "Play" | "SetMaxStreamingBitrate" | "SetPlaybackOrder";
      };
    };
    responses: {
      /** @description General command sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Issues a command to a client to display a message to the user. */
  SendMessageCommand: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
      };
    };
    /** @description The MediaBrowser.Model.Session.MessageCommand object containing Header, Message Text, and TimeoutMs. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageCommand"];
        "text/json": components["schemas"]["MessageCommand"];
        "application/*+json": components["schemas"]["MessageCommand"];
      };
    };
    responses: {
      /** @description Message sent. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Instructs a session to play an item. */
  Play: {
    parameters: {
      query: {
        /** @description The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now. */
        playCommand: "PlayNow" | "PlayNext" | "PlayLast" | "PlayInstantMix" | "PlayShuffle";
        /** @description The ids of the items to play, comma delimited. */
        itemIds: string[];
        /** @description The starting position of the first item. */
        startPositionTicks?: number;
        /** @description Optional. The media source id. */
        mediaSourceId?: string;
        /** @description Optional. The index of the audio stream to play. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the subtitle stream to play. */
        subtitleStreamIndex?: number;
        /** @description Optional. The start index. */
        startIndex?: number;
      };
      path: {
        /** @description The session id. */
        sessionId: string;
      };
    };
    responses: {
      /** @description Instruction sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Issues a playstate command to a client. */
  SendPlaystateCommand: {
    parameters: {
      query?: {
        /** @description The optional position ticks. */
        seekPositionTicks?: number;
        /** @description The optional controlling user id. */
        controllingUserId?: string;
      };
      path: {
        /** @description The session id. */
        sessionId: string;
        /** @description The MediaBrowser.Model.Session.PlaystateCommand. */
        command: "Stop" | "Pause" | "Unpause" | "NextTrack" | "PreviousTrack" | "Seek" | "Rewind" | "FastForward" | "PlayPause";
      };
    };
    responses: {
      /** @description Playstate command sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Issues a system command to a client. */
  SendSystemCommand: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
        /** @description The command to send. */
        command: "MoveUp" | "MoveDown" | "MoveLeft" | "MoveRight" | "PageUp" | "PageDown" | "PreviousLetter" | "NextLetter" | "ToggleOsd" | "ToggleContextMenu" | "Select" | "Back" | "TakeScreenshot" | "SendKey" | "SendString" | "GoHome" | "GoToSettings" | "VolumeUp" | "VolumeDown" | "Mute" | "Unmute" | "ToggleMute" | "SetVolume" | "SetAudioStreamIndex" | "SetSubtitleStreamIndex" | "ToggleFullscreen" | "DisplayContent" | "GoToSearch" | "DisplayMessage" | "SetRepeatMode" | "ChannelUp" | "ChannelDown" | "Guide" | "ToggleStats" | "PlayMediaSource" | "PlayTrailers" | "SetShuffleQueue" | "PlayState" | "PlayNext" | "ToggleOsdMenu" | "Play" | "SetMaxStreamingBitrate" | "SetPlaybackOrder";
      };
    };
    responses: {
      /** @description System command sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Adds an additional user to a session. */
  AddUserToSession: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User added to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Removes an additional user from a session. */
  RemoveUserFromSession: {
    parameters: {
      path: {
        /** @description The session id. */
        sessionId: string;
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User removed from session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Instructs a session to browse to an item or view. */
  DisplayContent: {
    parameters: {
      query: {
        /** @description The type of item to browse to. */
        itemType: "AggregateFolder" | "Audio" | "AudioBook" | "BasePluginFolder" | "Book" | "BoxSet" | "Channel" | "ChannelFolderItem" | "CollectionFolder" | "Episode" | "Folder" | "Genre" | "ManualPlaylistsFolder" | "Movie" | "LiveTvChannel" | "LiveTvProgram" | "MusicAlbum" | "MusicArtist" | "MusicGenre" | "MusicVideo" | "Person" | "Photo" | "PhotoAlbum" | "Playlist" | "PlaylistsFolder" | "Program" | "Recording" | "Season" | "Series" | "Studio" | "Trailer" | "TvChannel" | "TvProgram" | "UserRootFolder" | "UserView" | "Video" | "Year";
        /** @description The Id of the item. */
        itemId: string;
        /** @description The name of the item. */
        itemName: string;
      };
      path: {
        /** @description The session Id. */
        sessionId: string;
      };
    };
    responses: {
      /** @description Instruction sent to session. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates capabilities for a device. */
  PostCapabilities: {
    parameters: {
      query?: {
        /** @description The session id. */
        id?: string;
        /** @description A list of playable media types, comma delimited. Audio, Video, Book, Photo. */
        playableMediaTypes?: components["schemas"]["MediaType"][];
        /** @description A list of supported remote control commands, comma delimited. */
        supportedCommands?: components["schemas"]["GeneralCommandType"][];
        /** @description Determines whether media can be played remotely.. */
        supportsMediaControl?: boolean;
        /** @description Determines whether the device supports a unique identifier. */
        supportsPersistentIdentifier?: boolean;
      };
    };
    responses: {
      /** @description Capabilities posted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates capabilities for a device. */
  PostFullCapabilities: {
    parameters: {
      query?: {
        /** @description The session id. */
        id?: string;
      };
    };
    /** @description The MediaBrowser.Model.Session.ClientCapabilities. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClientCapabilitiesDto"];
        "text/json": components["schemas"]["ClientCapabilitiesDto"];
        "application/*+json": components["schemas"]["ClientCapabilitiesDto"];
      };
    };
    responses: {
      /** @description Capabilities updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that a session has ended. */
  ReportSessionEnded: {
    responses: {
      /** @description Session end reported to server. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Reports that a session is viewing an item. */
  ReportViewing: {
    parameters: {
      query: {
        /** @description The session id. */
        sessionId?: string;
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Session reported to server. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Completes the startup wizard. */
  CompleteWizard: {
    responses: {
      /** @description Startup wizard completed. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the initial startup wizard configuration. */
  GetStartupConfiguration: {
    responses: {
      /** @description Initial startup wizard configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["StartupConfigurationDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["StartupConfigurationDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["StartupConfigurationDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Sets the initial startup wizard configuration. */
  UpdateInitialConfiguration: {
    /** @description The updated startup configuration. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StartupConfigurationDto"];
        "text/json": components["schemas"]["StartupConfigurationDto"];
        "application/*+json": components["schemas"]["StartupConfigurationDto"];
      };
    };
    responses: {
      /** @description Configuration saved. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the first user. */
  GetFirstUser_2: {
    responses: {
      /** @description Initial user retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["StartupUserDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["StartupUserDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["StartupUserDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Sets remote access and UPnP. */
  SetRemoteAccess: {
    /** @description The startup remote access dto. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StartupRemoteAccessDto"];
        "text/json": components["schemas"]["StartupRemoteAccessDto"];
        "application/*+json": components["schemas"]["StartupRemoteAccessDto"];
      };
    };
    responses: {
      /** @description Configuration saved. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the first user. */
  GetFirstUser: {
    responses: {
      /** @description Initial user retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["StartupUserDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["StartupUserDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["StartupUserDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Sets the user name and password. */
  UpdateStartupUser: {
    /** @description The DTO containing username and password. */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["StartupUserDto"];
        "text/json": components["schemas"]["StartupUserDto"];
        "application/*+json": components["schemas"]["StartupUserDto"];
      };
    };
    responses: {
      /** @description Updated user name and password. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all studios from a given item, folder, or the entire library. */
  GetStudios: {
    parameters: {
      query?: {
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Search term. */
        searchTerm?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description User id. */
        userId?: string;
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Studios returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a studio by name. */
  GetStudio: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description Studio name. */
        name: string;
      };
    };
    responses: {
      /** @description Studio returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a list of available fallback font files. */
  GetFallbackFontList: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["FontFile"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["FontFile"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["FontFile"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a fallback font file. */
  GetFallbackFont: {
    parameters: {
      path: {
        /** @description The name of the fallback font file to get. */
        name: string;
      };
    };
    responses: {
      /** @description Fallback font file retrieved. */
      200: {
        content: {
          "font/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Search remote subtitles. */
  SearchRemoteSubtitles: {
    parameters: {
      query?: {
        /** @description Optional. Only show subtitles which are a perfect match. */
        isPerfectMatch?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The language of the subtitles. */
        language: string;
      };
    };
    responses: {
      /** @description Subtitles retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["RemoteSubtitleInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["RemoteSubtitleInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["RemoteSubtitleInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Downloads a remote subtitle. */
  DownloadRemoteSubtitles: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The subtitle id. */
        subtitleId: string;
      };
    };
    responses: {
      /** @description Subtitle downloaded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets the remote subtitles. */
  GetRemoteSubtitles: {
    parameters: {
      path: {
        /** @description The item id. */
        subtitleId: string;
      };
    };
    responses: {
      /** @description File returned. */
      200: {
        content: {
          "text/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an HLS subtitle playlist. */
  GetSubtitlePlaylist: {
    parameters: {
      query: {
        /** @description The subtitle segment length. */
        segmentLength: number;
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The subtitle stream index. */
        index: number;
        /** @description The media source id. */
        mediaSourceId: string;
      };
    };
    responses: {
      /** @description Subtitle playlist retrieved. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Upload an external subtitle file. */
  UploadSubtitle: {
    parameters: {
      path: {
        /** @description The item the subtitle belongs to. */
        itemId: string;
      };
    };
    /** @description The request body. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UploadSubtitleDto"];
        "text/json": components["schemas"]["UploadSubtitleDto"];
        "application/*+json": components["schemas"]["UploadSubtitleDto"];
      };
    };
    responses: {
      /** @description Subtitle uploaded. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Deletes an external subtitle file. */
  DeleteSubtitle: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The index of the subtitle file. */
        index: number;
      };
    };
    responses: {
      /** @description Subtitle deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets subtitles in a specified format. */
  GetSubtitleWithTicks: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description The item id.
         */
        itemId?: string;
        /**
         * @deprecated
         * @description The media source id.
         */
        mediaSourceId?: string;
        /**
         * @deprecated
         * @description The subtitle stream index.
         */
        index?: number;
        /**
         * @deprecated
         * @description The start position of the subtitle in ticks.
         */
        startPositionTicks?: number;
        /**
         * @deprecated
         * @description The format of the returned subtitle.
         */
        format?: string;
        /** @description Optional. The end position of the subtitle in ticks. */
        endPositionTicks?: number;
        /** @description Optional. Whether to copy the timestamps. */
        copyTimestamps?: boolean;
        /** @description Optional. Whether to add a VTT time map. */
        addVttTimeMap?: boolean;
      };
      path: {
        /** @description The (route) item id. */
        routeItemId: string;
        /** @description The (route) media source id. */
        routeMediaSourceId: string;
        /** @description The (route) subtitle stream index. */
        routeIndex: number;
        /** @description The (route) start position of the subtitle in ticks. */
        routeStartPositionTicks: number;
        /** @description The (route) format of the returned subtitle. */
        routeFormat: string;
      };
    };
    responses: {
      /** @description File returned. */
      200: {
        content: {
          "text/*": string;
        };
      };
    };
  };
  /** Gets subtitles in a specified format. */
  GetSubtitle: {
    parameters: {
      query?: {
        /**
         * @deprecated
         * @description The item id.
         */
        itemId?: string;
        /**
         * @deprecated
         * @description The media source id.
         */
        mediaSourceId?: string;
        /**
         * @deprecated
         * @description The subtitle stream index.
         */
        index?: number;
        /**
         * @deprecated
         * @description The format of the returned subtitle.
         */
        format?: string;
        /** @description Optional. The end position of the subtitle in ticks. */
        endPositionTicks?: number;
        /** @description Optional. Whether to copy the timestamps. */
        copyTimestamps?: boolean;
        /** @description Optional. Whether to add a VTT time map. */
        addVttTimeMap?: boolean;
        /** @description The start position of the subtitle in ticks. */
        startPositionTicks?: number;
      };
      path: {
        /** @description The (route) item id. */
        routeItemId: string;
        /** @description The (route) media source id. */
        routeMediaSourceId: string;
        /** @description The (route) subtitle stream index. */
        routeIndex: number;
        /** @description The (route) format of the returned subtitle. */
        routeFormat: string;
      };
    };
    responses: {
      /** @description File returned. */
      200: {
        content: {
          "text/*": string;
        };
      };
    };
  };
  /** Gets suggestions. */
  GetSuggestions: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
        /** @description The media types. */
        mediaType?: components["schemas"]["MediaType"][];
        /** @description The type. */
        type?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. The start index. */
        startIndex?: number;
        /** @description Optional. The limit. */
        limit?: number;
        /** @description Whether to enable the total record count. */
        enableTotalRecordCount?: boolean;
      };
    };
    responses: {
      /** @description Suggestions returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Notify SyncPlay group that member is buffering. */
  SyncPlayBuffering: {
    /** @description The player status. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BufferRequestDto"];
        "text/json": components["schemas"]["BufferRequestDto"];
        "application/*+json": components["schemas"]["BufferRequestDto"];
      };
    };
    responses: {
      /** @description Group state update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Join an existing SyncPlay group. */
  SyncPlayJoinGroup: {
    /** @description The group to join. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["JoinGroupRequestDto"];
        "text/json": components["schemas"]["JoinGroupRequestDto"];
        "application/*+json": components["schemas"]["JoinGroupRequestDto"];
      };
    };
    responses: {
      /** @description Group join successful. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Leave the joined SyncPlay group. */
  SyncPlayLeaveGroup: {
    responses: {
      /** @description Group leave successful. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets all SyncPlay groups. */
  SyncPlayGetGroups: {
    responses: {
      /** @description Groups returned. */
      200: {
        content: {
          "application/json": components["schemas"]["GroupInfoDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["GroupInfoDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["GroupInfoDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to move an item in the playlist in SyncPlay group. */
  SyncPlayMovePlaylistItem: {
    /** @description The new position for the item. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MovePlaylistItemRequestDto"];
        "text/json": components["schemas"]["MovePlaylistItemRequestDto"];
        "application/*+json": components["schemas"]["MovePlaylistItemRequestDto"];
      };
    };
    responses: {
      /** @description Queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Create a new SyncPlay group. */
  SyncPlayCreateGroup: {
    /** @description The settings of the new group. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["NewGroupRequestDto"];
        "text/json": components["schemas"]["NewGroupRequestDto"];
        "application/*+json": components["schemas"]["NewGroupRequestDto"];
      };
    };
    responses: {
      /** @description New group created. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request next item in SyncPlay group. */
  SyncPlayNextItem: {
    /** @description The current item information. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["NextItemRequestDto"];
        "text/json": components["schemas"]["NextItemRequestDto"];
        "application/*+json": components["schemas"]["NextItemRequestDto"];
      };
    };
    responses: {
      /** @description Next item update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request pause in SyncPlay group. */
  SyncPlayPause: {
    responses: {
      /** @description Pause update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Update session ping. */
  SyncPlayPing: {
    /** @description The new ping. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PingRequestDto"];
        "text/json": components["schemas"]["PingRequestDto"];
        "application/*+json": components["schemas"]["PingRequestDto"];
      };
    };
    responses: {
      /** @description Ping updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request previous item in SyncPlay group. */
  SyncPlayPreviousItem: {
    /** @description The current item information. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PreviousItemRequestDto"];
        "text/json": components["schemas"]["PreviousItemRequestDto"];
        "application/*+json": components["schemas"]["PreviousItemRequestDto"];
      };
    };
    responses: {
      /** @description Previous item update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to queue items to the playlist of a SyncPlay group. */
  SyncPlayQueue: {
    /** @description The items to add. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["QueueRequestDto"];
        "text/json": components["schemas"]["QueueRequestDto"];
        "application/*+json": components["schemas"]["QueueRequestDto"];
      };
    };
    responses: {
      /** @description Queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Notify SyncPlay group that member is ready for playback. */
  SyncPlayReady: {
    /** @description The player status. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReadyRequestDto"];
        "text/json": components["schemas"]["ReadyRequestDto"];
        "application/*+json": components["schemas"]["ReadyRequestDto"];
      };
    };
    responses: {
      /** @description Group state update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to remove items from the playlist in SyncPlay group. */
  SyncPlayRemoveFromPlaylist: {
    /** @description The items to remove. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RemoveFromPlaylistRequestDto"];
        "text/json": components["schemas"]["RemoveFromPlaylistRequestDto"];
        "application/*+json": components["schemas"]["RemoveFromPlaylistRequestDto"];
      };
    };
    responses: {
      /** @description Queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request seek in SyncPlay group. */
  SyncPlaySeek: {
    /** @description The new playback position. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SeekRequestDto"];
        "text/json": components["schemas"]["SeekRequestDto"];
        "application/*+json": components["schemas"]["SeekRequestDto"];
      };
    };
    responses: {
      /** @description Seek update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request SyncPlay group to ignore member during group-wait. */
  SyncPlaySetIgnoreWait: {
    /** @description The settings to set. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["IgnoreWaitRequestDto"];
        "text/json": components["schemas"]["IgnoreWaitRequestDto"];
        "application/*+json": components["schemas"]["IgnoreWaitRequestDto"];
      };
    };
    responses: {
      /** @description Member state updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to set new playlist in SyncPlay group. */
  SyncPlaySetNewQueue: {
    /** @description The new playlist to play in the group. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PlayRequestDto"];
        "text/json": components["schemas"]["PlayRequestDto"];
        "application/*+json": components["schemas"]["PlayRequestDto"];
      };
    };
    responses: {
      /** @description Queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to change playlist item in SyncPlay group. */
  SyncPlaySetPlaylistItem: {
    /** @description The new item to play. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetPlaylistItemRequestDto"];
        "text/json": components["schemas"]["SetPlaylistItemRequestDto"];
        "application/*+json": components["schemas"]["SetPlaylistItemRequestDto"];
      };
    };
    responses: {
      /** @description Queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to set repeat mode in SyncPlay group. */
  SyncPlaySetRepeatMode: {
    /** @description The new repeat mode. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetRepeatModeRequestDto"];
        "text/json": components["schemas"]["SetRepeatModeRequestDto"];
        "application/*+json": components["schemas"]["SetRepeatModeRequestDto"];
      };
    };
    responses: {
      /** @description Play queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request to set shuffle mode in SyncPlay group. */
  SyncPlaySetShuffleMode: {
    /** @description The new shuffle mode. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetShuffleModeRequestDto"];
        "text/json": components["schemas"]["SetShuffleModeRequestDto"];
        "application/*+json": components["schemas"]["SetShuffleModeRequestDto"];
      };
    };
    responses: {
      /** @description Play queue update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request stop in SyncPlay group. */
  SyncPlayStop: {
    responses: {
      /** @description Stop update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Request unpause in SyncPlay group. */
  SyncPlayUnpause: {
    responses: {
      /** @description Unpause update sent to all group members. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets information about the request endpoint. */
  GetEndpointInfo: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["EndPointInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["EndPointInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["EndPointInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to get endpoint information. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets information about the server. */
  GetSystemInfo: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["SystemInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SystemInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SystemInfo"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to retrieve information. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets public information about the server. */
  GetPublicSystemInfo: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["PublicSystemInfo"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PublicSystemInfo"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PublicSystemInfo"];
        };
      };
    };
  };
  /** Gets a list of available server log files. */
  GetServerLogs: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["LogFile"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["LogFile"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["LogFile"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to get server logs. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a log file. */
  GetLogFile: {
    parameters: {
      query: {
        /** @description The name of the log file to get. */
        name: string;
      };
    };
    responses: {
      /** @description Log file retrieved. */
      200: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to get log files. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Could not find a log file with the name. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Pings the system. */
  GetPingSystem: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": string;
          "application/json; profile=\"CamelCase\"": string;
          "application/json; profile=\"PascalCase\"": string;
        };
      };
    };
  };
  /** Pings the system. */
  PostPingSystem: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": string;
          "application/json; profile=\"CamelCase\"": string;
          "application/json; profile=\"PascalCase\"": string;
        };
      };
    };
  };
  /** Restarts the application. */
  RestartApplication: {
    responses: {
      /** @description Server restarted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to restart server. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Shuts down the application. */
  ShutdownApplication: {
    responses: {
      /** @description Server shut down. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User does not have permission to shutdown server. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /**
   * Gets wake on lan information.
   * @deprecated
   */
  GetWakeOnLanInfo: {
    responses: {
      /** @description Information retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["WakeOnLanInfo"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["WakeOnLanInfo"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["WakeOnLanInfo"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the current UTC time. */
  GetUtcTime: {
    responses: {
      /** @description Time returned. */
      200: {
        content: {
          "application/json": components["schemas"]["UtcTimeResponse"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UtcTimeResponse"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UtcTimeResponse"];
        };
      };
    };
  };
  /** Gets the TMDb image configuration options. */
  TmdbClientConfiguration: {
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["ConfigImageTypes"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Finds movies and trailers similar to a given trailer. */
  GetTrailers: {
    parameters: {
      query?: {
        /** @description The user id supplied as query parameter; this is required when not using an API key. */
        userId?: string;
        /** @description Optional filter by maximum official rating (PG, PG-13, TV-MA, etc). */
        maxOfficialRating?: string;
        /** @description Optional filter by items with theme songs. */
        hasThemeSong?: boolean;
        /** @description Optional filter by items with theme videos. */
        hasThemeVideo?: boolean;
        /** @description Optional filter by items with subtitles. */
        hasSubtitles?: boolean;
        /** @description Optional filter by items with special features. */
        hasSpecialFeature?: boolean;
        /** @description Optional filter by items with trailers. */
        hasTrailer?: boolean;
        /** @description Optional. Return items that are siblings of a supplied item. */
        adjacentTo?: string;
        /** @description Optional filter by parent index number. */
        parentIndexNumber?: number;
        /** @description Optional filter by items that have or do not have a parental rating. */
        hasParentalRating?: boolean;
        /** @description Optional filter by items that are HD or not. */
        isHd?: boolean;
        /** @description Optional filter by items that are 4K or not. */
        is4K?: boolean;
        /** @description Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited. */
        locationTypes?: components["schemas"]["LocationType"][];
        /** @description Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited. */
        excludeLocationTypes?: components["schemas"]["LocationType"][];
        /** @description Optional filter by items that are missing episodes or not. */
        isMissing?: boolean;
        /** @description Optional filter by items that are unaired episodes or not. */
        isUnaired?: boolean;
        /** @description Optional filter by minimum community rating. */
        minCommunityRating?: number;
        /** @description Optional filter by minimum critic rating. */
        minCriticRating?: number;
        /** @description Optional. The minimum premiere date. Format = ISO. */
        minPremiereDate?: string;
        /** @description Optional. The minimum last saved date. Format = ISO. */
        minDateLastSaved?: string;
        /** @description Optional. The minimum last saved date for the current user. Format = ISO. */
        minDateLastSavedForUser?: string;
        /** @description Optional. The maximum premiere date. Format = ISO. */
        maxPremiereDate?: string;
        /** @description Optional filter by items that have an overview or not. */
        hasOverview?: boolean;
        /** @description Optional filter by items that have an IMDb id or not. */
        hasImdbId?: boolean;
        /** @description Optional filter by items that have a TMDb id or not. */
        hasTmdbId?: boolean;
        /** @description Optional filter by items that have a TVDb id or not. */
        hasTvdbId?: boolean;
        /** @description Optional filter for live tv movies. */
        isMovie?: boolean;
        /** @description Optional filter for live tv series. */
        isSeries?: boolean;
        /** @description Optional filter for live tv news. */
        isNews?: boolean;
        /** @description Optional filter for live tv kids. */
        isKids?: boolean;
        /** @description Optional filter for live tv sports. */
        isSports?: boolean;
        /** @description Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited. */
        excludeItemIds?: string[];
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description When searching within folders, this determines whether or not the search will be recursive. true/false. */
        recursive?: boolean;
        /** @description Optional. Filter based on a search term. */
        searchTerm?: string;
        /** @description Sort Order - Ascending, Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes. */
        filters?: components["schemas"]["ItemFilter"][];
        /** @description Optional filter by items that are marked as favorite, or not. */
        isFavorite?: boolean;
        /** @description Optional filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited. */
        imageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Optional filter by items that are played, or not. */
        isPlayed?: boolean;
        /** @description Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited. */
        genres?: string[];
        /** @description Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited. */
        officialRatings?: string[];
        /** @description Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited. */
        tags?: string[];
        /** @description Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited. */
        years?: number[];
        /** @description Optional, include user data. */
        enableUserData?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person. */
        person?: string;
        /** @description Optional. If specified, results will be filtered to include only those containing the specified person id. */
        personIds?: string[];
        /** @description Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited. */
        personTypes?: string[];
        /** @description Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited. */
        studios?: string[];
        /** @description Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited. */
        artists?: string[];
        /** @description Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited. */
        excludeArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified artist id. */
        artistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified album artist id. */
        albumArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered to include only those containing the specified contributing artist id. */
        contributingArtistIds?: string[];
        /** @description Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited. */
        albums?: string[];
        /** @description Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited. */
        albumIds?: string[];
        /** @description Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited. */
        ids?: string[];
        /** @description Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited. */
        videoTypes?: components["schemas"]["VideoType"][];
        /** @description Optional filter by minimum official rating (PG, PG-13, TV-MA, etc). */
        minOfficialRating?: string;
        /** @description Optional filter by items that are locked. */
        isLocked?: boolean;
        /** @description Optional filter by items that are placeholders. */
        isPlaceHolder?: boolean;
        /** @description Optional filter by items that have official ratings. */
        hasOfficialRating?: boolean;
        /** @description Whether or not to hide items behind their boxsets. */
        collapseBoxSetItems?: boolean;
        /** @description Optional. Filter by the minimum width of the item. */
        minWidth?: number;
        /** @description Optional. Filter by the minimum height of the item. */
        minHeight?: number;
        /** @description Optional. Filter by the maximum width of the item. */
        maxWidth?: number;
        /** @description Optional. Filter by the maximum height of the item. */
        maxHeight?: number;
        /** @description Optional filter by items that are 3D, or not. */
        is3D?: boolean;
        /** @description Optional filter by Series Status. Allows multiple, comma delimited. */
        seriesStatus?: components["schemas"]["SeriesStatus"][];
        /** @description Optional filter by items whose name is sorted equally or greater than a given input string. */
        nameStartsWithOrGreater?: string;
        /** @description Optional filter by items whose name is sorted equally than a given input string. */
        nameStartsWith?: string;
        /** @description Optional filter by items whose name is equally or lesser than a given input string. */
        nameLessThan?: string;
        /** @description Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited. */
        studioIds?: string[];
        /** @description Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited. */
        genreIds?: string[];
        /** @description Optional. Enable the total record count. */
        enableTotalRecordCount?: boolean;
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a trickplay tile image. */
  GetTrickplayTileImage: {
    parameters: {
      query?: {
        /** @description The media version id, if using an alternate version. */
        mediaSourceId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The width of a single tile. */
        width: number;
        /** @description The index of the desired tile. */
        index: number;
      };
    };
    responses: {
      /** @description Tile image not found at specified index. */
      200: {
        content: {
          "image/*": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets an image tiles playlist for trickplay. */
  GetTrickplayHlsPlaylist: {
    parameters: {
      query?: {
        /** @description The media version id, if using an alternate version. */
        mediaSourceId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The width of a single tile. */
        width: number;
      };
    };
    responses: {
      /** @description Tiles playlist returned. */
      200: {
        content: {
          "application/x-mpegURL": string;
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets episodes for a tv season. */
  GetEpisodes: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional filter by season number. */
        season?: number;
        /** @description Optional. Filter by season id. */
        seasonId?: string;
        /** @description Optional. Filter by items that are missing episodes or not. */
        isMissing?: boolean;
        /** @description Optional. Return items that are siblings of a supplied item. */
        adjacentTo?: string;
        /** @description Optional. Skip through the list until a given item is found. */
        startItemId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional, include image information in output. */
        enableImages?: boolean;
        /** @description Optional, the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. */
        sortBy?: "Default" | "AiredEpisodeOrder" | "Album" | "AlbumArtist" | "Artist" | "DateCreated" | "OfficialRating" | "DatePlayed" | "PremiereDate" | "StartDate" | "SortName" | "Name" | "Random" | "Runtime" | "CommunityRating" | "ProductionYear" | "PlayCount" | "CriticRating" | "IsFolder" | "IsUnplayed" | "IsPlayed" | "SeriesSortName" | "VideoBitRate" | "AirTime" | "Studio" | "IsFavoriteOrLiked" | "DateLastContentAdded" | "SeriesDatePlayed" | "ParentIndexNumber" | "IndexNumber" | "SimilarityScore" | "SearchScore";
      };
      path: {
        /** @description The series id. */
        seriesId: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets seasons for a tv series. */
  GetSeasons: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Filter by special season. */
        isSpecialSeason?: boolean;
        /** @description Optional. Filter by items that are missing episodes or not. */
        isMissing?: boolean;
        /** @description Optional. Return items that are siblings of a supplied item. */
        adjacentTo?: string;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
      };
      path: {
        /** @description The series id. */
        seriesId: string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a list of next up episodes. */
  GetNextUp: {
    parameters: {
      query?: {
        /** @description The user id of the user to get the next up episodes for. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Filter by series id. */
        seriesId?: string;
        /** @description Optional. Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. Starting date of shows to show in Next Up section. */
        nextUpDateCutoff?: string;
        /** @description Whether to enable the total records count. Defaults to true. */
        enableTotalRecordCount?: boolean;
        /** @description Whether to disable sending the first episode in a series as next up. */
        disableFirstEpisode?: boolean;
        /** @description Whether to include resumable episodes in next up results. */
        enableResumable?: boolean;
        /** @description Whether to include watched episodes in next up results. */
        enableRewatching?: boolean;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a list of upcoming episodes. */
  GetUpcomingEpisodes: {
    parameters: {
      query?: {
        /** @description The user id of the user to get the upcoming episodes for. */
        userId?: string;
        /** @description Optional. The record index to start at. All items with a lower index will be dropped from the results. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
      };
    };
    responses: {
      /** @description Success */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets an audio stream. */
  GetUniversalAudioStream: {
    parameters: {
      query?: {
        /** @description Optional. The audio container. */
        container?: string[];
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. The user id. */
        userId?: string;
        /** @description Optional. The audio codec to transcode to. */
        audioCodec?: string;
        /** @description Optional. The maximum number of audio channels. */
        maxAudioChannels?: number;
        /** @description Optional. The number of how many audio channels to transcode to. */
        transcodingAudioChannels?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The container to transcode to. */
        transcodingContainer?: string;
        /** @description Optional. The transcoding protocol. */
        transcodingProtocol?: "http" | "hls";
        /** @description Optional. The maximum audio sample rate. */
        maxAudioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Whether to enable remote media. */
        enableRemoteMedia?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Whether to enable redirection. Defaults to true. */
        enableRedirection?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
      /** @description Redirected to remote audio stream. */
      302: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets an audio stream. */
  HeadUniversalAudioStream: {
    parameters: {
      query?: {
        /** @description Optional. The audio container. */
        container?: string[];
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. The user id. */
        userId?: string;
        /** @description Optional. The audio codec to transcode to. */
        audioCodec?: string;
        /** @description Optional. The maximum number of audio channels. */
        maxAudioChannels?: number;
        /** @description Optional. The number of how many audio channels to transcode to. */
        transcodingAudioChannels?: number;
        /** @description Optional. The maximum streaming bitrate. */
        maxStreamingBitrate?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The container to transcode to. */
        transcodingContainer?: string;
        /** @description Optional. The transcoding protocol. */
        transcodingProtocol?: "http" | "hls";
        /** @description Optional. The maximum audio sample rate. */
        maxAudioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Whether to enable remote media. */
        enableRemoteMedia?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Whether to enable redirection. Defaults to true. */
        enableRedirection?: boolean;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Audio stream returned. */
      200: {
        content: {
          "audio/*": string;
        };
      };
      /** @description Redirected to remote audio stream. */
      302: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Item not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a list of users. */
  GetUsers: {
    parameters: {
      query?: {
        /** @description Optional filter by IsHidden=true or false. */
        isHidden?: boolean;
        /** @description Optional filter by IsDisabled=true or false. */
        isDisabled?: boolean;
      };
    };
    responses: {
      /** @description Users returned. */
      200: {
        content: {
          "application/json": components["schemas"]["UserDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a user. */
  UpdateUser: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
    };
    /** @description The updated user model. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserDto"];
        "text/json": components["schemas"]["UserDto"];
        "application/*+json": components["schemas"]["UserDto"];
      };
    };
    responses: {
      /** @description User updated. */
      204: {
        content: never;
      };
      /** @description User information was not supplied. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User update forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a user by Id. */
  GetUserById: {
    parameters: {
      path: {
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User returned. */
      200: {
        content: {
          "application/json": components["schemas"]["UserDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description User not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Deletes a user. */
  DeleteUser: {
    parameters: {
      path: {
        /** @description The user id. */
        userId: string;
      };
    };
    responses: {
      /** @description User deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description User not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Updates a user policy. */
  UpdateUserPolicy: {
    parameters: {
      path: {
        /** @description The user id. */
        userId: string;
      };
    };
    /** @description The new user policy. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserPolicy"];
        "text/json": components["schemas"]["UserPolicy"];
        "application/*+json": components["schemas"]["UserPolicy"];
      };
    };
    responses: {
      /** @description User policy updated. */
      204: {
        content: never;
      };
      /** @description User policy was not supplied. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User policy update forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Authenticates a user by name. */
  AuthenticateUserByName: {
    /** @description The M:Jellyfin.Api.Controllers.UserController.AuthenticateUserByName(Jellyfin.Api.Models.UserDtos.AuthenticateUserByName) request. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AuthenticateUserByName"];
        "text/json": components["schemas"]["AuthenticateUserByName"];
        "application/*+json": components["schemas"]["AuthenticateUserByName"];
      };
    };
    responses: {
      /** @description User authenticated. */
      200: {
        content: {
          "application/json": components["schemas"]["AuthenticationResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["AuthenticationResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["AuthenticationResult"];
        };
      };
    };
  };
  /** Authenticates a user with quick connect. */
  AuthenticateWithQuickConnect: {
    /** @description The Jellyfin.Api.Models.UserDtos.QuickConnectDto request. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["QuickConnectDto"];
        "text/json": components["schemas"]["QuickConnectDto"];
        "application/*+json": components["schemas"]["QuickConnectDto"];
      };
    };
    responses: {
      /** @description User authenticated. */
      200: {
        content: {
          "application/json": components["schemas"]["AuthenticationResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["AuthenticationResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["AuthenticationResult"];
        };
      };
      /** @description Missing token. */
      400: {
        content: never;
      };
    };
  };
  /** Updates a user configuration. */
  UpdateUserConfiguration: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
    };
    /** @description The new user configuration. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserConfiguration"];
        "text/json": components["schemas"]["UserConfiguration"];
        "application/*+json": components["schemas"]["UserConfiguration"];
      };
    };
    responses: {
      /** @description User configuration updated. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User configuration update forbidden. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Initiates the forgot password process for a local user. */
  ForgotPassword: {
    /** @description The forgot password request containing the entered username. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForgotPasswordDto"];
        "text/json": components["schemas"]["ForgotPasswordDto"];
        "application/*+json": components["schemas"]["ForgotPasswordDto"];
      };
    };
    responses: {
      /** @description Password reset process started. */
      200: {
        content: {
          "application/json": components["schemas"]["ForgotPasswordResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ForgotPasswordResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ForgotPasswordResult"];
        };
      };
    };
  };
  /** Redeems a forgot password pin. */
  ForgotPasswordPin: {
    /** @description The forgot password pin request containing the entered pin. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ForgotPasswordPinDto"];
        "text/json": components["schemas"]["ForgotPasswordPinDto"];
        "application/*+json": components["schemas"]["ForgotPasswordPinDto"];
      };
    };
    responses: {
      /** @description Pin reset process started. */
      200: {
        content: {
          "application/json": components["schemas"]["PinRedeemResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["PinRedeemResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["PinRedeemResult"];
        };
      };
    };
  };
  /** Gets the user based on auth token. */
  GetCurrentUser: {
    responses: {
      /** @description User returned. */
      200: {
        content: {
          "application/json": components["schemas"]["UserDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserDto"];
        };
      };
      /** @description Token is not owned by a user. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Creates a user. */
  CreateUserByName: {
    /** @description The create user by name request body. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUserByName"];
        "text/json": components["schemas"]["CreateUserByName"];
        "application/*+json": components["schemas"]["CreateUserByName"];
      };
    };
    responses: {
      /** @description User created. */
      200: {
        content: {
          "application/json": components["schemas"]["UserDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a user's password. */
  UpdateUserPassword: {
    parameters: {
      query?: {
        /** @description The user id. */
        userId?: string;
      };
    };
    /** @description The M:Jellyfin.Api.Controllers.UserController.UpdateUserPassword(System.Nullable{System.Guid},Jellyfin.Api.Models.UserDtos.UpdateUserPassword) request. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPassword"];
        "text/json": components["schemas"]["UpdateUserPassword"];
        "application/*+json": components["schemas"]["UpdateUserPassword"];
      };
    };
    responses: {
      /** @description Password successfully reset. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description User is not allowed to update the password. */
      403: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description User not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a list of publicly visible users for display on a login screen. */
  GetPublicUsers: {
    responses: {
      /** @description Public users returned. */
      200: {
        content: {
          "application/json": components["schemas"]["UserDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserDto"][];
        };
      };
    };
  };
  /** Gets intros to play before the main media item plays. */
  GetIntros: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Intros returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets local trailers for an item. */
  GetLocalTrailers: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description An Microsoft.AspNetCore.Mvc.OkResult containing the item's local trailers. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets special features for an item. */
  GetSpecialFeatures: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Special features returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets latest media. */
  GetLatestMedia: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Filter by items that are played, or not. */
        isPlayed?: boolean;
        /** @description Optional. include image information in output. */
        enableImages?: boolean;
        /** @description Optional. the max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description Optional. include user data. */
        enableUserData?: boolean;
        /** @description Return item limit. */
        limit?: number;
        /** @description Whether or not to group items into a parent container. */
        groupItems?: boolean;
      };
    };
    responses: {
      /** @description Latest media returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets the root folder from a user's library. */
  GetRootFolder: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
    };
    responses: {
      /** @description Root folder returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Marks an item as a favorite. */
  MarkFavoriteItem: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item marked as favorite. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Unmarks item as a favorite. */
  UnmarkFavoriteItem: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item unmarked as favorite. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Updates a user's rating for an item. */
  UpdateUserItemRating: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Whether this M:Jellyfin.Api.Controllers.UserLibraryController.UpdateUserItemRating(System.Nullable{System.Guid},System.Guid,System.Nullable{System.Boolean}) is likes. */
        likes?: boolean;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Item rating updated. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Deletes a user's saved personal rating for an item. */
  DeleteUserItemRating: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
      path: {
        /** @description Item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Personal rating removed. */
      200: {
        content: {
          "application/json": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["UserItemDataDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["UserItemDataDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get user views. */
  GetUserViews: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
        /** @description Whether or not to include external views such as channels or live tv. */
        includeExternalContent?: boolean;
        /** @description Preset views. */
        presetViews?: components["schemas"]["CollectionType"][];
        /** @description Whether or not to include hidden content. */
        includeHidden?: boolean;
      };
    };
    responses: {
      /** @description User views returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get user view grouping options. */
  GetGroupingOptions: {
    parameters: {
      query?: {
        /** @description User id. */
        userId?: string;
      };
    };
    responses: {
      /** @description User view grouping options returned. */
      200: {
        content: {
          "application/json": components["schemas"]["SpecialViewOptionDto"][];
          "application/json; profile=\"CamelCase\"": components["schemas"]["SpecialViewOptionDto"][];
          "application/json; profile=\"PascalCase\"": components["schemas"]["SpecialViewOptionDto"][];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description User not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Get video attachment. */
  GetAttachment: {
    parameters: {
      path: {
        /** @description Video ID. */
        videoId: string;
        /** @description Media Source ID. */
        mediaSourceId: string;
        /** @description Attachment Index. */
        index: number;
      };
    };
    responses: {
      /** @description Attachment retrieved. */
      200: {
        content: {
          "application/octet-stream": string;
        };
      };
      /** @description Video or attachment not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets additional parts for a video. */
  GetAdditionalPart: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Additional parts returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Removes alternate video sources. */
  DeleteAlternateSources: {
    parameters: {
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Alternate sources deleted. */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Video not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
  /** Gets a video stream. */
  GetVideoStream: {
    parameters: {
      query?: {
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container?: string;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
    };
  };
  /** Gets a video stream. */
  HeadVideoStream: {
    parameters: {
      query?: {
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container?: string;
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /**
         * @deprecated
         * @description Optional. The dlna device profile id to utilize.
         */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
    };
  };
  /** Gets a video stream. */
  GetVideoStreamByContainer: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /** @description Optional. The dlna device profile id to utilize. */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
    };
  };
  /** Gets a video stream. */
  HeadVideoStreamByContainer: {
    parameters: {
      query?: {
        /** @description Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false. */
        static?: boolean;
        /** @description The streaming parameters. */
        params?: string;
        /** @description The tag. */
        tag?: string;
        /** @description Optional. The dlna device profile id to utilize. */
        deviceProfileId?: string;
        /** @description The play session id. */
        playSessionId?: string;
        /** @description The segment container. */
        segmentContainer?: string;
        /** @description The segment length. */
        segmentLength?: number;
        /** @description The minimum number of segments. */
        minSegments?: number;
        /** @description The media version id, if playing an alternate version. */
        mediaSourceId?: string;
        /** @description The device id of the client requesting. Used to stop encoding processes when needed. */
        deviceId?: string;
        /** @description Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma. */
        audioCodec?: string;
        /** @description Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true. */
        enableAutoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the video stream url. */
        allowVideoStreamCopy?: boolean;
        /** @description Whether or not to allow copying of the audio stream url. */
        allowAudioStreamCopy?: boolean;
        /** @description Optional. Whether to break on non key frames. */
        breakOnNonKeyFrames?: boolean;
        /** @description Optional. Specify a specific audio sample rate, e.g. 44100. */
        audioSampleRate?: number;
        /** @description Optional. The maximum audio bit depth. */
        maxAudioBitDepth?: number;
        /** @description Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults. */
        audioBitRate?: number;
        /** @description Optional. Specify a specific number of audio channels to encode to, e.g. 2. */
        audioChannels?: number;
        /** @description Optional. Specify a maximum number of audio channels to encode to, e.g. 2. */
        maxAudioChannels?: number;
        /** @description Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high. */
        profile?: string;
        /** @description Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1. */
        level?: string;
        /** @description Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        framerate?: number;
        /** @description Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements. */
        maxFramerate?: number;
        /** @description Whether or not to copy timestamps when transcoding with an offset. Defaults to false. */
        copyTimestamps?: boolean;
        /** @description Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms. */
        startTimeTicks?: number;
        /** @description Optional. The fixed horizontal resolution of the encoded video. */
        width?: number;
        /** @description Optional. The fixed vertical resolution of the encoded video. */
        height?: number;
        /** @description Optional. The maximum horizontal resolution of the encoded video. */
        maxWidth?: number;
        /** @description Optional. The maximum vertical resolution of the encoded video. */
        maxHeight?: number;
        /** @description Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults. */
        videoBitRate?: number;
        /** @description Optional. The index of the subtitle stream to use. If omitted no subtitles will be used. */
        subtitleStreamIndex?: number;
        /** @description Optional. Specify the subtitle delivery method. */
        subtitleMethod?: "Encode" | "Embed" | "External" | "Hls" | "Drop";
        /** @description Optional. */
        maxRefFrames?: number;
        /** @description Optional. The maximum video bit depth. */
        maxVideoBitDepth?: number;
        /** @description Optional. Whether to require avc. */
        requireAvc?: boolean;
        /** @description Optional. Whether to deinterlace the video. */
        deInterlace?: boolean;
        /** @description Optional. Whether to require a non anamorphic stream. */
        requireNonAnamorphic?: boolean;
        /** @description Optional. The maximum number of audio channels to transcode. */
        transcodingMaxAudioChannels?: number;
        /** @description Optional. The limit of how many cpu cores to use. */
        cpuCoreLimit?: number;
        /** @description The live stream id. */
        liveStreamId?: string;
        /** @description Optional. Whether to enable the MpegtsM2Ts mode. */
        enableMpegtsM2TsMode?: boolean;
        /** @description Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h265, h264, mpeg4, theora, vp8, vp9, vpx (deprecated), wmv. */
        videoCodec?: string;
        /** @description Optional. Specify a subtitle codec to encode to. */
        subtitleCodec?: string;
        /** @description Optional. The transcoding reason. */
        transcodeReasons?: string;
        /** @description Optional. The index of the audio stream to use. If omitted the first audio stream will be used. */
        audioStreamIndex?: number;
        /** @description Optional. The index of the video stream to use. If omitted the first video stream will be used. */
        videoStreamIndex?: number;
        /** @description Optional. The MediaBrowser.Model.Dlna.EncodingContext. */
        context?: "Streaming" | "Static";
        /** @description Optional. The streaming options. */
        streamOptions?: {
          [key: string]: string | null;
        };
      };
      path: {
        /** @description The item id. */
        itemId: string;
        /** @description The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv. */
        container: string;
      };
    };
    responses: {
      /** @description Video stream returned. */
      200: {
        content: {
          "video/*": string;
        };
      };
    };
  };
  /** Merges videos into a single record. */
  MergeVersions: {
    parameters: {
      query: {
        /** @description Item id list. This allows multiple, comma delimited. */
        ids: string[];
      };
    };
    responses: {
      /** @description Videos merged. */
      204: {
        content: never;
      };
      /** @description Supply at least 2 video ids. */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Get years. */
  GetYears: {
    parameters: {
      query?: {
        /** @description Skips over a given number of items within the results. Use for paging. */
        startIndex?: number;
        /** @description Optional. The maximum number of records to return. */
        limit?: number;
        /** @description Sort Order - Ascending,Descending. */
        sortOrder?: components["schemas"]["SortOrder"][];
        /** @description Specify this to localize the search to a specific item or folder. Omit to use the root. */
        parentId?: string;
        /** @description Optional. Specify additional fields of information to return in the output. */
        fields?: components["schemas"]["ItemFields"][];
        /** @description Optional. If specified, results will be excluded based on item type. This allows multiple, comma delimited. */
        excludeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. If specified, results will be included based on item type. This allows multiple, comma delimited. */
        includeItemTypes?: components["schemas"]["BaseItemKind"][];
        /** @description Optional. Filter by MediaType. Allows multiple, comma delimited. */
        mediaTypes?: components["schemas"]["MediaType"][];
        /** @description Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime. */
        sortBy?: components["schemas"]["ItemSortBy"][];
        /** @description Optional. Include user data. */
        enableUserData?: boolean;
        /** @description Optional. The max number of images to return, per image type. */
        imageTypeLimit?: number;
        /** @description Optional. The image types to include in the output. */
        enableImageTypes?: components["schemas"]["ImageType"][];
        /** @description User Id. */
        userId?: string;
        /** @description Search recursively. */
        recursive?: boolean;
        /** @description Optional. Include image information in output. */
        enableImages?: boolean;
      };
    };
    responses: {
      /** @description Year query returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDtoQueryResult"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDtoQueryResult"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
    };
  };
  /** Gets a year. */
  GetYear: {
    parameters: {
      query?: {
        /** @description Optional. Filter by user id, and attach user data. */
        userId?: string;
      };
      path: {
        /** @description The year. */
        year: number;
      };
    };
    responses: {
      /** @description Year returned. */
      200: {
        content: {
          "application/json": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["BaseItemDto"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["BaseItemDto"];
        };
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
      /** @description Forbidden */
      403: {
        content: never;
      };
      /** @description Year not found. */
      404: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"CamelCase\"": components["schemas"]["ProblemDetails"];
          "application/json; profile=\"PascalCase\"": components["schemas"]["ProblemDetails"];
        };
      };
    };
  };
}
